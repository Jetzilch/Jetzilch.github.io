<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[javaday12]]></title>
    <url>%2F2019%2F07%2F28%2Fjavaday12%2F</url>
    <content type="text"><![CDATA[一、Scanner类概述及其构造方法1.Scanner概述JDK5之后，用于接收键盘录入数据 2.详解Scanner sc = new Scanner(System.in);System是一个类，System类下有一个静态成员变量in:public static final InputStream in;(in的数据类型是InputStream) //标准的输入流，对应着键盘录入。根据上述的信息再去查找Scanner类的构造方法，可以发现：我们当初键盘录入创建对象所使用的构造方法是：Scanner(InputStream source)12PS：在cmd输入时，无论是a，123，String等都是字符串类型的数据，通过Scanner类创建的对象sc接收后，在使用sc.nextXxx()方法转成我们所需要的数据类型。 3.Scanner类的成员方法基本格式：（1）public boolean hasNextXxx():判断是否是某种类型的元素。（2）public Xxx nextXxx():获取该元素。默认情况下，Scanner使用空格，回车作为分隔符。常用方法：public int nextInt()public String nextLine() 4.Scanner获取数据存在的问题如果先获取一个数值，再获取一个字符串，就会出现问题：刚打完回车，准备输入字符串时，Java自动将回车认为是输入的字符串，导致真正想输入的字符串无法输入。如何解决呢？(1)先获取一个数值后，再创建一个新的键盘录入对象获取字符串。123456789public class ScannerDemo2 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int a = sc.nextInt(); Scanner sc2 = new Scanner(System.in); String str = sc2.nextLine(); System.out.println(&quot;a:&quot;+a+&quot;,str:&quot;+str); &#125;&#125; 这个方法的弊端：输入多个数据和字符串时，可能要创建多个Scanner对象。(2)把所有数据都按照字符串获取，然后要什么，你就对应的转换成什么。（推荐用这种方法） 二、String类概述及其构造方法1.String类概述字符串是由多个字符组成的一串数据（字符序列）字符串可以看成是字符数组字符串字面值”abc”也可以看成是一个字符串对象。字符串是常量，一旦被赋值，就不能被改变。 2.构造方法public String() //无参构造public String(byte[] bytes) //把字节数组转换成字符串public String(byte[] bytes,int offset,int length) //把字节数组从某个索引开始的几个数字转成字符串public String(char[] value) //把字符数组转成字符串public String(char[] value,int offset,int count) //把字符数组从某个索引开始的几个字符转成字符串public String(String original) //把字符串常量值转换成字符串tips：字符串的一个方法：public int length():返回此字符串的长度。 2.1public String() //无参构造1234567public class StringDemo &#123; public static void main(String[] args) &#123; String s1 = new String(); System.out.println(&quot;s1:&quot;+s1); //s1: System.out.println(&quot;s1.length():&quot;+s1.length());//s1.length():0 &#125;&#125; 我们知道输出一个对象的变量名等价于调用这个对象的toString()，而toString()默认全路径对象名+‘@’+转换成十六进制的地址值，而我们输出s1的接口是“ ”，说明String类改写了toString()。 2.2public String(byte[] bytes) //把字节数组转换成字符串1234byte[] bys = &#123;97,98,99,100,101&#125;;String s2 = new String(bys);System.out.println(&quot;s2:&quot;+s2); //s2:abcdeSystem.out.println(&quot;s2.length():&quot;+s2.length()); //s2.length():5 2.3public String(byte[] bytes,int offset,int length) //把字节数组从某个索引开始的几个数字转成字符串1234byte[] bys = &#123;97,98,99,100,101&#125;;String s3 = new String(bys,1,3);System.out.println(&quot;s3:&quot; + s3); //s3:bcdSystem.out.println(&quot;s3.length():&quot; + s3.length()); //s3.length():3 2.4public String(char[] value) //把字符数组转成字符串1234char[] chs = &#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;虾&apos;,&apos;哈&apos;&#125;;String s4 = new String(chs);System.out.println(&quot;s4:&quot; + s4); //s4:abcde虾哈System.out.println(&quot;s4.length():&quot; + s4.length()); //s4.length():7 2.5public String(char[] value,int offset,int count) //把字符数组从某个索引开始的几个字符转成字符串123String s5 = new String(chs,0,5);System.out.println(&quot;s5:&quot;+s5); //s5:abcdeSystem.out.println(&quot;s5.length():&quot;+s5.length()); //s5.length():5 2.6public String(String original) //把字符串常量值转换成字符串123String s6 = new String(&quot;abcde&quot;);System.out.println(&quot;s6:&quot;+s6); //s6:abcdeSystem.out.println(&quot;s6.length():&quot;+s6.length()); //s6.length():5 没什么意义，不如直接用String s6 = “abcde”; 3.String类的特点一旦被赋值，就不能改变。（指的是值不改变，引用可以变，即地址值可以变）123String s = &quot;hello&quot;;s += &quot;world&quot;;System.out.println(&quot;s:&quot;+s); //helloworld 这是通过直接赋值的方式创建String对象，字符串直接赋值时，会先到方法区中的字符串常量池里寻找是否有被赋值的字符串(hello),没有的话在常量池创建一个字符串常量，并把地址值0x001赋于String对象s。执行s += “world”时，并不是直接将hello和world进行拼接，因为字符串一旦被赋值，就不能被改变。所以真实的情况时先在常量池里寻找是否有world，没有的话就创建一个world，并赋予地址值0x002，但这个地址值并没有对象指向它。进行拼接操作时，是将创建一个由hello和world两个字符串组成的新字符串常量helloworld，并赋予地址值0x003，将0x003赋给s。 String类面试题1.String s = new String(“hello”);String s = “hello”;两者的区别？有，前者会创建两个对象；后者创建一个对象。==:进行引用类型比较，比较的是地址值是否相同equals():比较引用类型默认也是比较地址值是否相同，而String类重写了equals()，比较的是内容是否相同。12345String s1 = new String(&quot;helloworld&quot;); String s2 = &quot;helloworld&quot;; System.out.println(s1.equals(s2)); //true System.out.println(s1 == s2); //false 2.看程序写结果123456789101112131415161718192021public class StringDemo3 &#123; public static void main(String[] args) &#123; String s1 = new String(&quot;hello&quot;); String s2 = new String(&quot;hello&quot;); System.out.println(s1 == s2); // false System.out.println(s1.equals(s2)); // true System.out.println(&quot;------&quot;); String s3 = new String(&quot;hello&quot;); String s4 = &quot;hello&quot;; System.out.println(s3 == s4); // false System.out.println(s3.equals(s4)); // true System.out.println(&quot;-------&quot;); String s5 = &quot;hello&quot;; String s6 = &quot;hello&quot;; System.out.println(s5 == s6); // true System.out.println(s5.equals(s6)); // true System.out.println(&quot;------&quot;); &#125;&#125; 3.看程序写结果1234567891011public class StringDemo4 &#123; public static void main(String[] args) &#123; String s1 = &quot;hello&quot;; String s2 = &quot;world&quot;; String s3 = &quot;helloworld&quot;; System.out.println(s3 == s1 + s2); // false,因为s1，s2是变量，字符串变量进行拼接时，先开辟空间再拼接。 System.out.println(s3.equals((s1 + s2))); // true System.out.println(s3 == &quot;hello&quot; + &quot;world&quot;); // true，因为&quot;hello&quot;,&quot;world&quot;是常量，先拼接后到常量池寻找，有就直接返回以后的常量，没有就创建后再返回。 System.out.println(s3.equals(&quot;hello&quot; + &quot;world&quot;)); // true &#125;&#125; 结论：字符串如果是变量相加，先开空间，再拼接。字符串如果是常量相加，是先加，然后在常量池找，如果有就直接返回，否则，就创建。 4.String类的判断功能boolean equals(Object obj):比较字符串的内容是否相同boolean equalsIgnoreCase(String str)：比较字符串的内容是否相同，忽略大小写boolean contains(String str)：判断大串中是否包含小串boolean startsWith(String str)：判断字符串是否以某个指定的字符串开头boolean endsWith(String str)：判断字符串是否以某个指定的字符串结尾boolean isEmpty()：判断字符串是否为空。注意：内容为空和字符串对象为空不同。内容为空指对象存在，内容为空。对象为空指对象都不存在。String s = “”； //字符串内容为空String s = null; //字符串对象为空1234567891011121314151617181920212223242526272829303132333435363738public class StringDemo &#123; public static void main(String[] args) &#123; // 创建字符串对象 String s1 = &quot;helloworld&quot;; String s2 = &quot;helloworld&quot;; String s3 = &quot;HelloWorld&quot;; String s4 = &quot;&quot;; String s5 = null; // boolean equals(Object obj):比较字符串的内容是否相同 System.out.println(&quot;equals():&quot; + s1.equals(s2)); // true System.out.println(&quot;equals():&quot; + s1.equals(s3)); // flase System.out.println(&quot;------------&quot;); // boolean equalsIgnoreCase(String str)：比较字符串的内容是否相同，忽略大小写 System.out.println(&quot;equalsIgnoreCase():&quot; + s1.equalsIgnoreCase(s2)); // true System.out.println(&quot;equalsIgnoreCase():&quot; + s1.equalsIgnoreCase(s3)); // true System.out.println(&quot;------------&quot;); // boolean contains(String str)：判断大串中是否包含小串 System.out.println(&quot;contains():&quot; + s1.contains(&quot;hello&quot;)); // true System.out.println(&quot;contains():&quot; + s1.contains(&quot;hw&quot;)); // false System.out.println(&quot;------------&quot;); // boolean startsWith(String str)：判断字符串是否以某个指定的字符串开头 System.out.println(&quot;startsWith():&quot; + s1.startsWith(&quot;h&quot;)); // true System.out.println(&quot;startsWith():&quot; + s1.startsWith(&quot;hello&quot;)); // true System.out.println(&quot;------------&quot;); // boolean endsWith(String str)：判断字符串是否以某个指定的字符串结尾 System.out.println(&quot;endsWith():&quot; + s1.endsWith(&quot;world&quot;)); // true System.out.println(&quot;endsWith():&quot; + s1.endsWith(&quot;d&quot;)); // true System.out.println(&quot;------------&quot;); // boolean isEmpty()：判断字符串是否为空。 System.out.println(s1.isEmpty()); // false System.out.println(s2.isEmpty()); // false System.out.println(s3.isEmpty()); // false System.out.println(s4.isEmpty()); // true System.out.println(s5.isEmpty()); // NullPointerException,因为s5对象都不存在，无法调用方法，空指针异常。 &#125;&#125; String类判断功能练习1.模拟用户登陆案例给三次机会，错误时，提示还有多少次机会。自己的做法：123456789101112131415161718192021222324252627282930313233343536373839404142public class StringTest &#123; public static void main(String[] args) &#123; //定义正确的用户名和密码 String username = &quot;helloworld&quot;; String password = &quot;123456&quot;; String inviteNumber = &quot;hello&quot;; for(int x=1;x&lt;=3;x++) &#123; //创建键盘录入对西那个，并创建String对象进行接收 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入用户名：&quot;); String str1 = sc.nextLine(); System.out.println(&quot;请输入密码：&quot;); String str2 = sc.nextLine(); System.out.println(&quot;请输入邀请码：&quot;); String str3 = sc.nextLine(); if(str1.equals(username)) &#123; if(str2.equals(password)) &#123; if(str3.equalsIgnoreCase(inviteNumber)) &#123; System.out.println(&quot;恭喜你登陆成功&quot;); break; &#125;else &#123; System.out.println(&quot;你输入的邀请码有误&quot;); &#125; &#125;else &#123; System.out.println(&quot;你输入的密码有误&quot;); &#125; &#125;else &#123; System.out.println(&quot;你输入的用户名有误&quot;); &#125; if(x != 3) &#123; System.out.println(&quot;请重试，你还有&quot;+(3-x)+&quot;次机会&quot;); &#125;else &#123; System.out.println(&quot;登陆失败&quot;); &#125; &#125; &#125;&#125; 视频做法知识点相同，就不放上来了。Debug的点加在每个方法的第一条语句，需要使用到的每个方法都要加。2.模拟用户登陆案例，登陆成功，开始玩猜数字小游戏。登陆失败，账号冻结，不能玩游戏。（猜数字小游戏另外写一个类） 5.String类的获取功能int length():获取字符串长度。char charAt(int index):获取指定索引位置的字符。int indexOf(int ch):返回指定字符在此字符串中第一次出现处的索引。为什么这里是int类型，而不是char类型？原因是：‘a’和97其实都可以代表’a’，如果限定是char类型的话，就不能使用数字了。int类型比较方便，两个都可以接收int indexOf(String str):返回指定字符串再此字符串中第一次出现的索引。int indexOf(int ch,int fromIndex):返回指定字符在此字符串中从指定位置后第一次出现的索引。int indexOf(String str,int fromIndex):返回指定字符串在此字符串中从指定位置后第一次出现的索引。String substring(int start):从指定位置开始截取字符串。String substring(int start,int end):从指定位置开始到指定位置结束，截取字符串。1234567891011121314151617181920212223242526272829303132333435363738394041public class StringDemo &#123; public static void main(String[] args) &#123; String s = &quot;helloworld&quot;; // int length():获取字符串长度。 System.out.println(&quot;s.length():&quot; + s.length());// s.length():10 System.out.println(&quot;--------------&quot;); // char charAt(int index):获取指定索引位置的字符。 System.out.println(&quot;s.charAt():&quot; + s.charAt(7)); // s.charAt():r System.out.println(&quot;------------&quot;); // int indexOf(int ch):返回指定字符在此字符串中第一次出现处的索引。 System.out.println(&quot;s.indexOf():&quot; + s.indexOf(&apos;l&apos;)); // s.indexOf():2 System.out.println(&quot;------------&quot;); // int indexOf(String str):返回指定字符串再此字符串中第一次出现的索引。 System.out.println(&quot;s.indexOf():&quot; + s.indexOf(&quot;owo&quot;)); // s.indexOf():4 System.out.println(&quot;-----------&quot;); // int indexOf(int ch,int fromIndex):返回指定字符在此字符串中从指定位置后第一次出现的索引。 System.out.println(&quot;s.indexOf():&quot; + s.indexOf(&apos;l&apos;, 4)); // s.indexOf():8 System.out.println(&quot;s.indexOf():&quot; + s.indexOf(&apos;k&apos;, 4)); // s.indexOf():-1 System.out.println(&quot;s.indexOf():&quot; + s.indexOf(&apos;l&apos;, 40)); // s.indexOf():-1 System.out.println(&quot;-------------&quot;); // int indexOf(String str,int fromIndex):返回指定字符串在此字符串中从指定位置后第一次出现的索引。 String s2 = &quot;hellowordlhelloworld&quot;; System.out.println(&quot;s2.indexOf():&quot; + s2.indexOf(&quot;hello&quot;, 4));// s2.indexOf():10 System.out.println(&quot;---------&quot;); // String substring(int start):从指定位置开始截取字符串。 System.out.println(&quot;s.substring():&quot; + s.substring(5));// s.substring():world System.out.println(&quot;---------&quot;); //String substring(int start,int end):从指定位置开始到指定位置结束，截取字符串。 System.out.println(&quot;s.substring():&quot;+s.substring(0,5));//s.substring():hello System.out.println(&quot;----------&quot;); &#125;&#125; String类获取功能练习1.String类：字符串遍历12345678910111213141516171819202122232425/* * String类:字符串遍历 * * * 分析： * 1.如何获得每一个字符？ * char charAt(int index); * 2.我怎么知道字符到底有多少个？ * int length() */import java.util.Scanner;public class StringTest &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入想要遍历的字符串：&quot;); String str = sc.nextLine(); for(int x=0;x&lt;str.length();x++) &#123; System.out.println(str.charAt(x)); &#125; &#125;&#125; 2.统计一个字符串中大写字母字符，小写字母字符，数字字符出现的次数。（不考虑其他字符）举例：“Hello123World”结果：大写字符：2个小写字符：8个数字字符：3个1234567891011121314151617181920public class StringTest2 &#123; public static void main(String[] args) &#123; String str = &quot;Hello123World&quot;; int bigCount = 0; int smallCount = 0; int numCount = 0; for(int x=0;x&lt;str.length();x++) &#123; if(str.charAt(x)&gt;=&apos;A&apos; &amp;&amp; str.charAt(x)&lt;=&apos;Z&apos;) &#123;// 做比较运算时，char类型会先转成int类型再比较。 bigCount++; &#125;else if(str.charAt(x)&gt;=&apos;a&apos; &amp;&amp; str.charAt(x)&lt;=&apos;z&apos;) &#123; smallCount++; &#125;else if(str.charAt(x)&gt;=&apos;0&apos; &amp;&amp; str.charAt(x)&lt;=&apos;9&apos;) &#123; numCount++; &#125; &#125; System.out.println(&quot;大写字符：&quot;+bigCount); System.out.println(&quot;小写字符：&quot;+smallCount); System.out.println(&quot;数字：&quot;+numCount); &#125;&#125; 6.String类的转换功能byte[] getBytes():把字符串转换成字节数组。char[] toCharArray():把字符串转换成字符数组。static String valueOf(char[] chs):把字符数组转成字符串。static String valueOf(int i):把int类型的数据转成字符串。//不只这两个，valueOf()可以把任意类型的数据转成字符串。（包括引用类型）String toLowerCase():把字符串转成小写。String toUpperCase():把字符串转化成大写。String concat(String str):把字符串拼接。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class StringDemo &#123; public static void main(String[] args) &#123; String str = &quot;JavaSE&quot;; //byte[] getBytes():把字符串转换成字节数组。 byte[] bys = str.getBytes(); for(int x=0;x&lt;bys.length;x++) &#123; System.out.println(bys[x]); &#125; System.out.println(&quot;-----------&quot;); //char[] toCharArray():把字符串转换成字符数组。 char[] chs = str.toCharArray(); for(int x=0;x&lt;chs.length;x++) &#123; System.out.println(chs[x]); &#125; System.out.println(&quot;-----------&quot;); //static String valueOf(char[] chs):把字符数组转成字符串。 String str2 = new String().valueOf(chs); System.out.println(str2); System.out.println(&quot;-----------&quot;); //static String valueOf(int i):把int类型的数据转成字符串。 int x = 120; System.out.println(new String().valueOf(x)); System.out.println(&quot;-----------&quot;); //String toLowerCase():把字符串转成小写。 String str3 = str.toLowerCase(); System.out.println(str); System.out.println(str3); System.out.println(&quot;---------&quot;); //String toUpperCase():把字符串转化成大写。 String str4 = str.toUpperCase(); System.out.println(str); System.out.println(str4); System.out.println(&quot;------------&quot;); //String concat(String str):把字符串拼接。 String str5 = &quot;helloworld&quot;; String str6 = str.concat(str5); System.out.println(str6); System.out.println(&quot;------------&quot;); System.out.println(str.concat(&quot;helloworld&quot;)); &#125;&#125; String类转换功能练习题1.把字符串首字母转大写，其他字母转小写。1234567891011121314public class StringTest &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入想要转换的字符串：&quot;); String str = sc.nextLine(); String str2 = &quot;&quot;; String str3 = &quot;&quot;; str2 = str.toUpperCase().substring(0, 1); str3 = str.toLowerCase().substring(1); System.out.println(str2.concat(str3)); &#125;&#125; 7.String类的其他功能7.1替换功能String replace(char old,char new)String replace(String old,String new) 7.2去除字符串两端空格String trim() 7.3按字典顺序比较两个字符串int compareTo(String str)int compareToIgnoreCase(String str) String类练习1.把数组中的数据按照指定格式拼接成一个字符串举例：int[] arr = {1,2,3}; 输出结果：[1, 2, 3]自己的做法1234567891011121314public class StringTest &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,3&#125;; String str = &quot;[&quot;; for(int x=0;x&lt;arr.length;x++) &#123; if(x == arr.length-1) &#123; str = str.concat(arr[x]+&quot;]&quot;); &#125;else &#123; str = str.concat(arr[x]+&quot;, &quot;); &#125; &#125; System.out.println(str); &#125;&#125; 2.字符串反转举例：键盘录入“abc” 输出结果：”cba”123456789101112131415161718192021222324252627282930313233public class StringTest2 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入想要反转的字符串：&quot;); String str = sc.nextLine(); //方法1 System.out.println(reverse1(str)); System.out.println(&quot;----------&quot;); //方法2 System.out.println(reverse2(str)); &#125; public static String reverse1(String str) &#123; // 方法1:转成字符数组，然后倒序拼接 char[] chs = str.toCharArray(); String str2 = &quot;&quot;; for (int x = chs.length - 1; x &gt;= 0; x--) &#123; str2 += chs[x]; &#125; return str2; &#125; public static String reverse2(String str) &#123; //方法2:length()和charAt()结合。 //不用将字符串转成字符数组 String str2 = &quot;&quot;; for(int x=str.length()-1;x&gt;=0;x--) &#123; str2+=str.charAt(x); &#125; return str2; &#125;&#125; 3.统计大串中小串出现的次数举例：在字符串“woaijavawozhenaijavawozhendeaijavawozhendehenaijavaxinbuxinwoaijavagun”中java出现了5次123456789101112131415161718192021public class StringTest3 &#123; public static void main(String[] args) &#123; String maxStr = &quot;woaijavawozhenaijavawozhendeaijavawozhendehenaijavaxinbuxinwoaijavagun&quot;; String minStr = &quot;java&quot;; System.out.println(&quot;java一共出现了&quot; + con(maxStr,minStr) + &quot;次&quot;); &#125; public static int con(String maxStr,String minStr) &#123; // 创建一个统计变量 int count = 0; // 找到&quot;java&quot;第一次出现的索引 // 截取字符串。 while (maxStr.contains(minStr)) &#123; int index = maxStr.indexOf(minStr); count++; maxStr = maxStr.substring(index + minStr.length()); &#125; return count; &#125;&#125; 可以试着改成键盘录入大串，小串。]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday11]]></title>
    <url>%2F2019%2F07%2F28%2Fjavaday11%2F</url>
    <content type="text"><![CDATA[一、eclipse基本使用略。 二、API（application programming interface应用程序编程接口）1.API概述简单的说就是JDK提供的各种方便我们开发的java类。 三、Object类1.Object类概述类层次结构的根类。每个类都直接或间接继承自Object类。 2.构造方法只有public Object()无参构造。这也是子类继承父类时，默认访问无参构造的原因。 3.Object类的hashCode()方法public int hashCode():返回该对象的哈希值。哈希值是根据实际地址值利用哈希算法换算出来的一个int类型的值，与地址值有关，但并不是真正的地址值。 4.Object类的getClass()方法public final Class getClass():返回此Object的运行时类。简单记住返回的是一个Class类的类名（即返回该类的对象）即可，day27的反射会详细讲。而Class类中还有一个方法public String getName()：以String形式返回此Class对象所表示的实体名称。案例：123456Student s = new Student();Class c = s.getClass();String str = c.getName();System.out.println(str); //结果：cn.itcast_01.Student//链式编程简化System.out.println(new Student().getClass().getName()); //结果：cn.itcast_01.Student 5.Object类的toString()方法public String toString():返回该对象的字符串表示。结果是1对象名.getClass().getName()+&apos;@&apos;+Integer.toHexString(对象名.hashCode()) Integer类下的一个static方法：public static String toHexString(int i):把一个int类型的数据转成十六进制无符号形式的字符串案例：1System.out.println(s.toString()); //结果：cn.itcast_02.Student@7852e922 这个结果的组成我们已经知道了，但是我们获得这个信息是没有意义的。所以，建议所有子类都重写该方法。（说明书中也是这样建议的）怎么重写呢？把该类的所有成员变量值组成返回即可。案例：12345@Overridepublic String toString() &#123; // TODO Auto-generated method stub //return super.toString(); return &quot;姓名：&quot;+name+&quot;，年龄：&quot;+age; 也可以command+option+s自动生成(建议自动生成)1234@Override public String toString() &#123; return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; &#125; 注意：直接输出对象名称等价于调用对象的toString()方法1System.out.println(s);//Student [name=null, age=0] 6.Object类的equals()方法public boolean equals(Object obj):指示其他某个对象是否与此对象”相等“。默认比较对象的地址值。比较地址值一般来说意义不大，所以我们要重写该方法。怎么重写呢？一般都是用来比较对象的成员变量值是否相同。因为name是字符串，字符串是引用类型，用“==”和Object类的equals()方法都无法比较它的内容，好在String类中已重写equals()方法，String类的equals()方法比较的就是字符串的内容。自己重写学生类的equals()方法:12345678public boolean equals(Object obj) &#123; Student s = (Student)obj; //name和age是Student类特有的成员变量，如果不向下转型的话，obj是多态的形式，无法访问Student的特有成员变量。 if(this.name.equals(s.name) &amp;&amp; this.age == s.age) &#123; return true; &#125;else &#123; return false; &#125; &#125; 上述重写存在一些问题：（1）同一个对象是否还需要比较？（自己跟自己还用比吗？）（2）假如我接收的是一个Demo类，向下转型时会失败。所以需要先判断我接收的类是不是一个学生类。判断方法如下：格式：obj instanceof Student //instanceof是关键字，这个语句返回的是true或者false。所以改进equals()方法的代码如下：12345678910111213141516public boolean equals(Object obj) &#123; if(this == obj) &#123; //判断是否是跟自己比 return true; &#125; if(!(obj instanceof Student)) &#123; //判断接收的类是不是一个学生类 return false; &#125; Student s = (Student)obj; if(this.name.equals(s.name) &amp;&amp; this.age == s.age) &#123; return true; &#125;else &#123; return false; &#125; &#125; 同理，这个也是可以自动生成的。自动生成的代码如下：1234567891011121314151617public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) //返回字节码文件对象，同一个类的字节码文件对象在内存中只有一个，如果两者是同一个类型的对象，那它们的字节码文件相同。 return false; Student other = (Student) obj; if (age != other.age) return false; if (name == null) &#123; if (other.name != null) return false; &#125; else if (!name.equals(other.name)) return false; return true;&#125; 1234PS：比较运算符==:基本类型：比较的就是值是否形同。引用类型：比较地址值是否相同。 7.Object类的其他方法7.1 finalize()protected void finalize():当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。用于垃圾回收，但是什么时候回收不确定。 7.2 clone()protected Object clone():创建并返回此对象的一个副本。该方法是protected修饰，在此案例中是Student的父类Object类的方法，在StudentTest类（不同包下的无关类）中就算创建Object的子类对象Student也无法进行访问。如何访问呢？（1）重写该方法。借助option+/半自动生成。重写后代码如下：123protected Object clone() throws CloneNotSupportedException &#123; //抛出异常后面会讲，先不用管 return super.clone(); &#125; 测试类中代码如下：123456789public class StudentTest &#123; public static void main(String[] args) throws CloneNotSupportedException &#123;// 创建学生对象 Student s = new Student(); //克隆学生对象 Object obj = s.clone(); &#125;&#125; 上述代码会报错，需要在Student类中实现一个接口Cloneable（个人认为类默认是不能被克隆的，实现这个接口后就可以被克隆了）Cloneable:实现此接口，以指示Object.clone()方法可以合法地对该类对象进行按字段复制。这个接口是标记接口，告诉我们实现该接口的类就可以实现对象的复制了。 Object类的6个方法总结Student类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class Student implements Cloneable&#123; private String name; private int age; public Student() &#123; super(); // TODO Auto-generated constructor stub &#125; public Student(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; &#125; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + age; result = prime * result + ((name == null) ? 0 : name.hashCode()); return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Student other = (Student) obj; if (age != other.age) return false; if (name == null) &#123; if (other.name != null) return false; &#125; else if (!name.equals(other.name)) return false; return true; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; // TODO Auto-generated method stub return super.clone(); &#125; &#125; 测试类123456789101112131415161718192021222324252627public class StudentTest &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; //创建对象 Student s = new Student(); Student s2 = new Student(&quot;哈哈哈&quot;,3); //hashCode():返回地址值经过hash算法得到的int类型数据 System.out.println(s.hashCode()); //getClass():返回的时Class类的对象，Class类中有个getName()，可以返回String类型的全路径类名。 String str = s.getClass().getName(); System.out.println(str); //toString():默认输出格式时String类型的全路径名称+&apos;@&apos;+Integer.toHexString(d对象名.hashCode) //建议重写，一般自动生成，重写成显示类名和成员变量的值 String str2 = s.toString(); System.out.println(str2); //equals():默认是用比较运算符&quot;==&quot;进行比较，没有意义。一般进行重写。自动生成。 //重写后比较的是对象中的成员变量是否相等。 boolean result = s.equals(s2); System.out.println(result); //finalize():Java识别对象不再被使用时，对象的垃圾回收器调用此方法进行回收，但是回收时间不确定。 //clone():复制一个对象的副本。Java的类默认是不能复制的，需要先实现Cloneable接口后才能实现，期间的抛出异常问题先忽略，后面会讲解。 //另外，clone()也要进行重写，因为clone()是父类Object的方法，并且是protected修饰，在其他类中进行访问时（不同包下的无关类），就算是创建子类对象进行访问也不行。 //重写可以半自动生成，先打&quot;clone&quot;,之后option+/ //克隆返回的是一个Objecet类的对象，借助向下转型转成相应的对象 //在测试类中也要抛出异常，同样，这个问题后面讲解。 Student s3 = (Student)s.clone(); &#125;&#125;]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday10]]></title>
    <url>%2F2019%2F07%2F27%2Fjavaday10%2F</url>
    <content type="text"><![CDATA[一、抽象类和接口的形式参数、返回值类型问题1.形式参数：（1）基本类型（太简单，不是我今天要讲解的）（2）引用类型：类：匿名对象的时候已经讲过，需要的是类的一个对象。抽象类：需要的是该抽象类的子类对象。接口：需要的是该接口的实现类对象。 2.返回值类型（1）基本类型（太简单，不讲）（2）引用类型：类：返回的事该类的对象。抽象类：返回的是该抽象类的子类对象接口：返回的是该接口的实现类对象。 3.链式编程举例：1234StudentDemo sd = new StudentDemo();//Student s = new Student();//s.study();sd.getStudent().study(); //等同于上面两个“//”，并且之后如果有方法，还可以继续调用下去，这个就称为链式编程。 链式编程的特点：每次调用完毕方法后，返回的是一个对象。 二、包1.包的概述其实就是文件夹，作用是对类进行分类管理。 2.包的格式：package 包名; //多级包用.分开。 3.包的注意事项(1)package语句必须是程序的第一条可执行的代码。(2)package语句在一个java文件中只能有一个。(3)如果没有package，默认表示无包名。 4.带包类的编译和运行4.1手动式手动创建包（文件夹）然后在cmd里输入java cn.itcast.HelloWorld(包名，类名可修改)4.2自动式javac编译的时候带上-d即可。 java -d . Test.java执行命令和手动式一样。 5.不同包之间的访问视频10.14（了解即可，需要用的时候回来看一下就行，基本用不到） 三、导包1.前提不同包下的类之间的访问，我们发现，每次使用不同包下的类的时候，都需要加包的全路径。比较麻烦。这个时候，java就提供了导包的功能。 2.导包格式import 包名;注意：这种方式倒入是到类的名称,虽然最后可以写*，但是不建议，因为这样就导入了所有。 面试题：1.package，import，class有没有顺序关系？package–&gt;import–&gt;class只能有一个 可以有多个 可以有多个，建议是一个。 四、权限修饰符权限修饰符 本类中 同一个包下(包含子类和无关类) 不同包下子类 不同包下无关类private Y默认 Y Yprotected Y Y Ypublic Y Y Y Y 五、常见的修饰符1.类及其组成所使用的常见修饰符权限修饰符：private，默认，protected，public状态修饰符：static，final抽象修饰符：abstract 可以使用的修饰符类：权限修饰符：默认，public状态修饰符：final抽象修饰符：abstract用得最多：public 成员变量：权限修饰符：private，默认，protected，public状态修饰符：static，final用得最多：private 构造方法：权限修饰符：private，默认，protected，public用得最多：public 成员方法：权限修饰符：private，默认，protected，public状态修饰符：static，final抽象修饰符：abstract用得最多：public 除上述之外的组合规则：成员变量：public static final成员方法：public staticpublic finalpublic abstract 补充：成员内部类：权限修饰符：private，默认，protected，public状态修饰符：static，final抽象修饰符：abstract 局部内部类： //局部位置没有权限修饰符，没有意义。状态修饰符：final抽象修饰符：abstract 六、内部类1.内部类概述把类定义在其他类的内部，这个类就被称为内部类。举例：在类A中定义一个类B，类B就是内部类。 2.内部类的访问特点：（1）内部类可以直接访问外部类的成员，包括私有。（2）外部内要访问内部类的成员，必须创建对象。 3.内部类位置3.1成员内部类成员内部类：在成员位置定义的内部类称为成员内部类。如何直接访问成员内部类的成员？外部类名.内部类名 对象名 = 外部类对象.内部类对象;Outer.Inner oi = new Outer().new Inner(); 3.2成员内部类的修饰符(1)private //为了保证数据的安全性.(2)static //为了方便访问数据。注意：a、静态内部类访问的外部类数据必须用静态修饰。b、内部类被静态修饰的方法可以是静态或非静态。成员内部类被静态修饰后的访问方式：格式：外部类名.内部类名 对象名 = new 外部类名.内部类名(); 成员内部类面试题1.补齐程序12345678910111213class Outer &#123; public int num = 10; class Inner &#123; public int num = 20; public void show() &#123; int num = 30; System.out.println(?); //num System.out.println(??); //this.num System.out.println(???); //new Outer().num或者Outer.this.num &#125; &#125;&#125;在控制台分别输出30，20，10 注意：（1）内部类和外部类没有继承关系。（所以不能用super.num）（2）通过外部类名限定this对象。Outer.this 3.3局部内部类局部内部类：在局部位置定义的内部类称为局部内部类。3.3.1 局部内部类的特点： //其实这个特点就对应着上面2.内部类的访问特点。（1）可以直接访问外部类的成员。（2）在局部位置，可以创建内部类对象，通过对象调用内部类方法，来使用局部内部类功能。 3.3.2 面试题1.1234567891011121314151617class Outer &#123; private int num = 10; public void method() &#123; final int num2 = 20; //记住这个final class Inner &#123; public void show() &#123; System.out.println(num); //从内部类中访问本地变量num2，需要被声明为最终类型。 System.out.println(num2); &#125; &#125; Inner i = new Inner(); i.show(); &#125;&#125; 局部内部类访问局部变量的注意事项？局部内部类访问的局部变量必须用final修饰。因为局部变量会随着方法的调用完毕而消失，这个时候，局部对象并没有立马从堆内存消失，还要使用那个变量。为了让数据还能继续被使用，就用final修饰。这样，在堆内存里面存储的其实是一个常量值。 4.匿名内部类就是内部类的简化写法（类似于匿名对象） 4.1匿名内部类的前提存在一个类或者接口。可以是具体类也可以是抽象类。 4.2匿名内部类的格式new 类名或者接口名() { 重写方法;}；//注意这个分号的使用。//根据这个格式只能存在于方法中，要存在于类中需要如下格式：类名或接口名 标识符 = new 类名或者接口名() { 重写方法;}；本质是一个继承了该类或者实现了该接口的子类匿名对象。案例：12345678910111213interface Inter &#123; public abstract void show();&#125;class Outer &#123; public void method() &#123; new Inter() &#123; public void show() &#123; System.out.println(&quot;show&quot;); &#125; &#125;.show(); //匿名内部类的调用。这样的调用很麻烦，下面有比较方便的调用方法。 &#125;&#125; 方便的调用方法如下所示12345678910111213interface Inter &#123; public abstract void show();&#125;class Outer &#123; public void method() &#123; Inter i = new Inter() &#123; //这个是多态，不是接口创建对象（接口是不能实例化的）。new Inter() &#123;...&#125;;是接口Inter的实现类对象， public void show() &#123; System.out.println(&quot;show&quot;); &#125; &#125;.show(); //匿名内部类的调用。这样的调用很麻烦，下面有比较方便的调用方法。 &#125;&#125; 4.3匿名内部类在开发中的应用调用study方法的常规做法和匿名内部类做法，匿名内部类一般用于只调用一次的方法，调用完后变成垃圾回收。123456789101112131415161718192021222324252627282930interface Person &#123; public abstract void study(); &#125;class PersonDemo &#123; public void method(Person p) &#123; p.study(); &#125;&#125;class Student implements Person &#123; public void study() &#123; System.out.println(&quot;好好学习，天天向上&quot;); &#125;&#125;public class InnerClassTest2 &#123; public static void main(String[] args) &#123; PersonDemo pd = new PersonDemo(); pd.method(new Student()); System.out.println(&quot;----------&quot;); pd.method(new Person() &#123; public void study() &#123; System.out.println(&quot;好好学习，天天向上啊&quot;); &#125; &#125;); &#125;&#125; 匿名内部类面试题按照要求，补齐代码12345678interface Inter &#123;void show();&#125;class Outer &#123;//补齐代码&#125;class OuterDemo &#123; public static void main(String[] args) &#123; Outer.method().show(); &#125;&#125;//要求在控制台输出&quot;HelloWorld&quot; 自己的做法1234567891011121314151617181920interface Inter &#123; void show();//隐藏了public abstract&#125;class Outer &#123; public static Inter method() &#123; return new Inter() &#123; public void show() &#123; //注意这个public，对于上面的public abstract，因为实现类方法重写权限不能小于原抽象方法。 System.out.println(&quot;Helloworld&quot;); &#125; &#125;; &#125;&#125;public class OuterDemo &#123; public static void main(String[] args) &#123; Outer.method().show(); &#125;&#125;]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday09]]></title>
    <url>%2F2019%2F07%2F25%2Fjavaday09%2F</url>
    <content type="text"><![CDATA[一、final关键字1.前提：由于继承中方法存在一个现象：方法重写。所以，父类的功能，就会被子类所覆盖掉。有些时候，我们不想让子类覆盖掉父类的功能。针对这种情况，Java提供了关键字：final 2.final概述最终的意思，常见的是它可以修饰类，方法，变量。 3.final修饰类、方法、变量的特点3.1 final修饰类的特点该类不能被继承。 3.2 final修饰方法的特点该方法不能被重写。 3.3 final修饰变量的特点该变量不能被重新赋值（只能被赋值一次）。因为这个变量其实就是常量。（这个就是自定义常量，例：final int x =10;） 面试题1.final修饰局部变量的问题123456789101112131415161718192021222324252627282930class Student &#123; int age = 10;&#125;public class FinalTest &#123; public static void main(String[] args) &#123; //局部变量为基本数据类型 int x =10; x =100; System.out.println(x); final int y = 10; //无法为最终变量y分配值 //y = 100; System.out.println(y); System.out.println(&quot;--------&quot;); //局部变量是引用数据类型 Student s = new Student(); System.out.println(s.age); s.age = 100; System.out.println(s.age); System.out.println(&quot;-----------&quot;); final Student ss = new Student(); System.out.println(ss.age); ss.age = 100;//这并不会报错，因为final修饰引用类型的局部变量是指该变量的地址值不能被重新赋值，与该引用类型变量中的成员变量没有关系 System.out.println(ss.age); &#125;&#125; final修饰局部变量的特点：修饰基本数据类型的局部变量：其值不能被重新赋值。修饰引用类型的局部变量：其地址值不能被重新赋值。2.final修饰变量的初始化时机在对象构造完毕前即可。 二、多态1.多态概述多态：某一个事物（可以理解为java中的对象），在不同时刻表现出来的不同状态。举例：猫可以是猫的类型，猫 m = new 猫();同时猫也可以是动物的一种，也可以把猫称为动物。动物 d = new 猫();举例2:水在不同时刻的状态。 2.多态的前提和体现（1）有继承关系。（2）有方法重写。(没有也可以，但是就没有意义了，因为方法重写才是多态的体现，才能发挥它的作用)（3）有父类引用指向子类对象。//父 f = new 子(); 2# 根据多态前提写一个案例1234567891011121314151617class Fu &#123; public void show() &#123; System.out.println(&quot;show Fu&quot;); &#125;&#125;class Zi extends Fu&#123;//方法继承 public void show() &#123; System.out.println(&quot;show Zi&quot;);//方法重写 &#125;&#125;public class DuoTaiDemo &#123; public static void main(String[] args) &#123; Fu f = new Zi();//父类引用指向子类对象 &#125;&#125; 3.多态中成员访问的特点(1)成员变量编译看左边，运行看左边。(2)构造方法创建子类对象的时候，访问父类的构造方法，对父类的数据进行初始化。(3)成员方法编译看左边，运行看右边。(4)静态方法编译看左边，运行看左边。（静态和类相关，算不上方法重写，所以访问的还是左边的）总结：由于成员方法存在方法重写，所以它运行看右边（子类）。其他编译，运行都是看左边（父类）。 4.多态的好处（1）提高了代码的维护性。（继承保证）（2）提高了代码的扩展性。1234public static void useAnimal(Animal a) &#123;//参数列表中是Animal，但是可以接收继承Animal的所有对象，这其实就是多态，不理解看day09.08视频（多态的好处） a.eat(); a.sleep();&#125; 5.多态的弊端不能使用子类的特有功能。我就想使用子类的特有功能，行不行？行。怎们用呢？（1）创建子类对象调用方法。（可以，但是很多时候不合理，而且，太占内存了）（2）向下转型（既然能够把子类的对象赋值给父类，可以把父类的引用赋值给子类引用。）格式如下：Zi z = (Zi) f;//前提：前面已经有Fu f = new Zi();且Zi继承Fu。 5.1 对象间的转型问题(1)向上转型：Fu f = new Zi();(2)向下转型：Zi z = (Zi)f;//要求是该f必须是能转换为Zi的。回想孔子装爹案例帮助理解。 多态练习1.猫狗案例多态版12345678910111213141516171819202122232425262728293031323334353637383940414243class Animals &#123; public void eat() &#123;&#125;;&#125; class Dog extends Animals &#123; public void eat() &#123; System.out.println(&quot;狗吃肉&quot;); &#125; public void lookDoor() &#123; System.out.println(&quot;狗看门&quot;); &#125;&#125;class Cat extends Animals &#123; public void eat() &#123; System.out.println(&quot;猫吃鱼&quot;); &#125; public void playGame() &#123; System.out.println(&quot;猫做迷藏&quot;); &#125;&#125;public class DuoTaiTest &#123; public static void main(String[] args) &#123; Animals a = new Dog(); a.eat(); Dog d = (Dog)a; d.eat(); d.lookDoor(); System.out.println(&quot;-------&quot;); a = new Cat(); a.eat(); Cat c =(Cat)a; c.eat(); c.playGame(); System.out.println(&quot;-----------&quot;); &#125;&#125; 2.南北方人饮食多态版1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Person &#123; public void eat() &#123; System.out.println(&quot;吃饭&quot;); &#125;&#125;class NorthPerson extends Person &#123; public void eat() &#123; System.out.println(&quot;炖菜，吃馒头&quot;); &#125; public void yanJiu() &#123; System.out.println(&quot;研究&quot;); &#125;&#125;class SouthPerson extends Person &#123; public void eat() &#123; System.out.println(&quot;炒菜，吃米饭&quot;); &#125; public void jingShang() &#123; System.out.println(&quot;经商&quot;); &#125;&#125;public class DuoTaiTest2 &#123; public static void main(String[] args) &#123; //北方人 Person p = new NorthPerson(); p.eat(); NorthPerson np = (NorthPerson)p; np.eat(); np.yanJiu(); //南方人 p = new SouthPerson(); p.eat(); SouthPerson sp = (SouthPerson)p; sp.eat(); sp.jingShang(); &#125;&#125; 3.看程序有没有问题，如果没问题，写出结果。1234567891011121314151617181920212223242526272829303132333435class A &#123; public void show() &#123; show2(); &#125; public void show2() &#123; System.out.println(&quot;我&quot;); &#125;&#125;class B extends A &#123; public void show2() &#123; System.out.println(&quot;爱&quot;); &#125;&#125;class C extends B &#123; public void show() &#123; super.show(); &#125; public void show2() &#123; System.out.println(&quot;你&quot;); &#125;&#125;public class DuoTaiTest3 &#123; public static void main(String[] args) &#123; A a = new B(); a.show();//爱 B b = new C(); b.show();//你 &#125;&#125; 三、抽象类1.抽象类概述虽然我们前面提到了动物类，并创建了动物类对象，但这其实与实际是不相符的，因为动物是一个抽象的概念。所以，我们不应该在动物类中给出具体体现，而是应该给出一个声明即可。在Java中，一个没有方法体的方法应该定义为抽象方法，而类中，如果有抽象方法，则应该被定义为抽象类。（抽象类中其实不一定要有抽象方法，只要有abstract就是抽象类。） 2.抽象类的特点（1）抽象类和抽象方法必须用abstract关键字修饰。（2）抽象类中不一定有抽象方法，但是有抽象方法的类一定要背定义成抽象类。（3）抽象类不能实例化。但是抽象类有构造方法，构造方法的作用是：用于子类访问父类数据的初始化。（4）抽象类的子类必须是抽象类或者重写所有抽象方法的具体类。 3.抽象类的成员特点（1）成员变量：既可以是变量，也可以是常量。（2）构造方法：有。用于子类访问父类数据的初始化。（3）成员方法：既可以是抽象的，也可以是非抽象的。 抽象类练习1.猫狗案例具体事物：猫、狗共性：姓名，年龄，吃饭123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566abstract class Animal &#123; private String name; private int age; public Animal() &#123;&#125; public Animal(String name,int age) &#123; this.name = name; this.age = age; &#125; public void setName(String name) &#123; this.name =name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; public abstract void eat();&#125;class Dog extends Animal &#123; public Dog() &#123;&#125; public Dog(String name,int age) &#123; super(name,age); &#125; public void eat() &#123; System.out.println(&quot;狗吃肉&quot;); &#125;&#125;public class AbstractTest1 &#123; public static void main(String[] args) &#123; //具体类实现 Dog d = new Dog(); d.setAge(3); d.setName(&quot;旺财&quot;); System.out.println(d.getName()+&quot;---&quot;+d.getAge()); d.eat(); Dog d2 = new Dog(&quot;旺财&quot;,3); System.out.println(d.getName()+&quot;---&quot;+d.getAge()); d2.eat(); System.out.println(&quot;---------&quot;); //多态实现 Animal a = new Dog(); a.setName(&quot;旺财&quot;); a.setAge(3); System.out.println(a.getName()+&quot;----&quot;+a.getAge()); d2.eat(); Animal a2 = new Dog(&quot;旺财&quot;,3); System.out.println(a2.getName()+&quot;---&quot;+a2.getAge()); d2.eat(); &#125;&#125; 2.老师案例具体事物：基础班老师，就业班老师共性：姓名，年龄，讲课。3.学生案例具体事物：基础班学员，就业班学员共性：姓名，年龄，班级，学习，吃饭4.员工案例假如我们在开发一个系统时需要对员工类进行设计，员工包含三个属性：姓名、工号以及工资。经理也是员工，除了含有员工属性外，另外还有一个奖金属性。请使用继承的思想设计出员工类和经理类。要求类中提供必要的方法进行属性访问。 4.抽象类的几个小问题4.1 没有抽象方法的抽象类有什么意义？不让外界创建对象。让其只能通过子类去访问它。4.2 abstract不能和哪些关键字共存？abstract一般修饰的是方法和类。private 冲突 子类无法重写抽象类方法，没有意义final 冲突 final修饰的方法不能被重写，修饰的类不能被继承。static 无意义 报错。就算不报错，abstract修饰的方法没有方法体，就算用static修饰，可以使用类名调用也没有意义。 四、接口1.接口引入猫狗除了自身的吃饭，睡觉功能外，还能通过人为训练获得钻火圈，跳高等功能。但这些功能并不是一开始就具备的，放在抽象动物类不合适，也不适合放在猫，狗类中。为了体现事物功能的扩展性，Java就提供了接口来定义这些额外功能，并不给出具体实现，将来哪些猫狗需要被培训，只需要这部分猫狗把这些额外功能实现即可。 2.接口的特点(1)接口用关键字interface表示. 格式： interface 接口名 {}(2)类实现接口用implements表示格式：class 类名 implements 接口名 {}(3)接口不能实例化如果要实现实例化，必须用多态的方式来进行实例化。* 多态的三种实例化a、具体类多态（几乎没有）b、抽象类多态（常用）c、接口多态（最常用）(4)接口的子类a、可以是抽象类，但是意义不大。b、可以是具体类。要重写接口中的所有抽象方法。 3.接口的成员特点（1）成员变量：只能是常量，并且是静态的。可以理解成存在默认修饰符：public static final （建议自己手动给出）（2）构造方法：接口没有构造方法。（ps：所有类都默认继承Object类）（3）成员方法：只能是抽象方法。默认修饰符：public abstract （建议自己手动给出） 4.类与类、类与接口、接口与接口的关系（1）类与类继承关系。只能单继承，但是可以多层继承。（2）类与接口实现关系，可以单实现，也可以多实现。并且还可以在继承一个类的时候实现多个接口。（3）接口与接口继承关系。可以单继承，也可以多继承。 5.抽象类和接口的区别（1）成员区别抽象类：成员变量：可以变量，也可以常量。构造方法：有。成员方法：可以抽象，也可以非抽象。接口：成员变量：只能是常量。public static final构造方法：无。成员方法：只能是抽象方法。 public abstract(2)关系区别1）类与类继承关系。只能单继承，但是可以多层继承。2）类与接口实现关系，可以单实现，也可以多实现。并且还可以在继承一个类的时候实现多个接口。3）接口与接口继承关系。可以单继承，也可以多继承。(3)设计理念区别抽象类 被继承体现的是“is a”的关系。接口 被实现体现的是“like a”的关系。 练习1.猫狗案例，加入跳高的额外功能2.老师和学生案例，加入抽烟的额外功能3.教练和运动员案例乒乓球运动员和篮球运动员。乒乓球教练和篮球教练为了出国交流，跟乒乓球相关的人员都需要学习英语。请用所学知识，分析这个案例中有哪些抽象类，哪些接口，哪些具体类。]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday08]]></title>
    <url>%2F2019%2F07%2F19%2Fjavaday08%2F</url>
    <content type="text"><![CDATA[一、如何制作帮助文档（了解）1.零散知识点1.1在同一个文件夹下，类定义在两个文件中和定义在一个文件中其实是一样的。1.2把构造方法私有，外界就不能再创建该类的对象了。2.练习 二、通过jdk提供的api学习了Math类（掌握）1.猜数字小游戏12345678910111213141516171819import java.util.Scanner;public class GuessNumber &#123; public static void main(String[] args) &#123; int number = (int)(Math.random()*100+1); Scanner sc = new Scanner(System.in); while(true) &#123; System.out.println(&quot;请输入你猜的数字：&quot;); int guessNumber = sc.nextInt(); if(guessNumber &gt; number) &#123; System.out.println(&quot;你输入的数字大了&quot;); &#125;else if(guessNumber &lt; number) &#123; System.out.println(&quot;你输入的数字小了&quot;); &#125;else &#123; System.out.println(&quot;恭喜你猜对了&quot;); break; &#125; &#125; &#125;&#125; 三、代码块（掌握）1.局部代码块位置：局部位置（方法内）作用：限定变量生命周期，及早释放，提高内存利用率。 2.构造代码块位置：类中的成员位置，用{}括起来的代码。作用：每次调用构造方法执行前，都会先执行构造代码块。可以把多个构造方法中的共同代码放到一起，对对象进行初始化。 3.静态代码块位置：在类中的成员位置，用{}括起来的代码，只不过用static修饰了。作用：一般是对类进行初始化。 面试题静态代码块、构造代码块、构造方法的执行顺序：静态代码块–构造代码块–构造方法只执行一次–每次调用构造方法都执行 练习1.看程序写结果123456789101112131415161718192021222324252627class Student &#123; static &#123; System.out.println(&quot;Student 静态代码块&quot;); &#125; &#123; System.out.println(&quot;Student 构造代码块&quot;); &#125; public Student() &#123; System.out.println(&quot;Student 构造方法&quot;); &#125;&#125;public class StudentDemo &#123; static &#123; System.out.println(&quot;main 静态代码块&quot;); &#125; public static void main(String[] args) &#123; System.out.println(&quot;main&quot;); Student s1 = new Student(); Student s2 = new Student(); &#125;&#125; 分析：12345678910111.把带有main方法的类加载到内存中，先执行该类的静态代码块，之后执行main方法。main 静态代码块main2.生成对象前，先加载创建对象所需要的类，此时该类的静态代码块随类加载而加载，即执行Student 静态代码块3.生成对象后，按构造代码块--构造方法的顺序执行代码Student 构造代码块Student 构造方法4.生成的对象有两个，所以再重复执行一次Student 构造代码块Student 构造方法 四、继承（掌握）1.继承概述多个类中存在相同属性和行为时，将这些内容提取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。通过extends关键字可以实现类与类的继承class 子类名 extends 父类名 {}单独的这个类称为父类，基类或者超类；这多个类可以称为子类或派生类。总结：把多个类中相同的内容给提取出来定义到一个类中。 2.继承的案例和继承的好处####2.1 通过一个具体案例来演示代码案例1:学生类和老师。定义两个功能（吃饭，睡觉）案例2:加入人类后改进。 ####2.2 继承的好处（1）多个类相同的成员可以放到同一个类中，提供了代码的复用性。（2）如果功能的代码需要修改，修改一处即可，提高了代码的维护性。（3）让类与类之间产生关系，是多态的前提。这也是一个弊端：类的耦合性很强。开发原则：低耦合，高内聚。耦合：类与类的关系内聚：自己完成某件事情的能力。 3.Java中继承的特点(1)Java只支持单继承，不支持多继承。(2)Java支持多层继承。 4.Java中继承的注意事项(1)子类只能继承父类所有非私有的成员（成员方法和成员变量）(2)子类不能继承父类的构造方法，但是可以通过super（后面讲）关键字区访问父类构造方法。(3)不要为了部分功能而去继承。什么时候考虑使用继承？继承体现的是“is a”的关系，根据这个思路去判断需不需要使用继承。 5.继承中类的成员变量、构造方法、成员方法的关系5.1继承中成员变量的关系（1）子类中的成员变量和父类中的成员变量名称不同简单，不是重点。（2）子类中的成员变量和父类中的成员变量名称相同就近原则。1234在子类方法中访问一个变量的查找顺序：（1）在子类方法的局部范围内寻找，有就使用（2）在子类的成员范围找，有就使用（3）在父类的成员范围找，有就使用 5.2this和super的区别12345678910111213141516171819202122232425/* * * 我要输出局部范围的num，本类成员范围的num，父类成员范围的num。 */class Father &#123; int num = 10;&#125;class Son extends Father &#123; int num = 20; public void show() &#123; int num = 30; System.out.println(num); System.out.println(this.num); System.out.println(super.num); &#125;&#125;public class ExtendsDemo5 &#123; public static void main(String[] args) &#123; Son s = new Son(); s.show(); &#125;&#125; 5.2.1 this和super的区别？(1)this代表本类对应的引用(2)super代表父类存储空间的标识（可以理解为父类引用，可以操作父类的成员。个人理解是这个标识让子类可以操作父类的成员，但是并没有创建一个父类对象） 5.2.2 如何使用?（1）调用成员变量this.成员变量 //调用本类的成员变量super.成员变量 //调用父类的成员变量（2）调用构造方法this(…) //调用本类的构造方法super(…) //调用父类的构造方法 //super()调用父类无参构造 super(String name)调用父类带参构造（3）调用成员方法this.成员方法 //调用本类的成员方法super.成员方法 //调用父类的成员方法 5.3继承中构造方法的关系5.3.1 子类中所有构造方法默认都会访问父类中无参构造方法。为什么呢？（1）因为子类会继承父类中的数据，可能还会使用父类的数据，所以子类初始化之前，一定要先完成父类数据的初始化。（2）每一个构造方法的第一条语句默认都是：super() 5.4继承中构造方法的注意事项如果父类没有无参构造方法，那么子类的构造方法会出现什么现象？报错。如何解决？（1）在父类中加一个无参构造方法.（2）通过使用super关键字去显示的调用父类的带参构造方法。举例：123456789101112131415161718192021222324class Father &#123; public Father(String name) &#123; System.out.println(&quot;Father的带参构造方法&quot;); &#125;&#125;class Son extends Father &#123; public Son() &#123; super(&quot;随便给&quot;); System.out.println(&quot;Son的无参构造方法&quot;); &#125; public Son(String name) &#123; super(&quot;随便给&quot;); System.out.println(&quot;Son的带参构造方法&quot;); &#125;&#125;public class ExtendsDemo7 &#123; public static void main(String[] args) &#123; Son s1 = new Son(); System.out.println(&quot;-------&quot;); Son s2 = new Son(&quot;小强&quot;); &#125;&#125; （3）子类通过this去调用本类的其他构造方法(子类中一定有一个去访问父类的构造方法，否则父类数据就没有初始化)12345678910111213141516171819202122232425class Father &#123; public Father(String name) &#123; System.out.println(&quot;Father的带参构造方法&quot;); &#125;&#125;class Son extends Father &#123; public Son() &#123; super(&quot;随便给&quot;); System.out.println(&quot;Son的无参构造方法&quot;); &#125; public Son(String name) &#123; //super(&quot;随便给&quot;); this(); System.out.println(&quot;Son的带参构造方法&quot;); &#125;&#125;public class ExtendsDemo7 &#123; public static void main(String[] args) &#123; Son s1 = new Son(); System.out.println(&quot;-------&quot;); Son s2 = new Son(&quot;小强&quot;); &#125;&#125; 注意事项：this(…)或者super(…)必须出现在第一条语句上。如果不是放在第一条语句上，就可能对父类的数据进行多次初始化，所以必须放在第一条语句上。 继承中的面试题1.看程序写结果12345678910111213141516171819202122232425262728class Fu &#123; public int num = 10; public Fu() &#123; System.out.println(&quot;fu&quot;); &#125;&#125;class Zi extends Fu&#123; public int num = 20; public Zi() &#123; System.out.println(&quot;zi&quot;); &#125; public void show() &#123; int num = 30; System.out.println(num); System.out.println(this.num); System.out.println(super.num); &#125;&#125;public class ExtendsTest &#123; public static void main(String[] args) &#123; Zi z = new Zi(); z.show(); &#125;&#125; 结果：12345fuzi302010 2.看程序写结果123456789101112131415161718192021222324252627282930313233class Fu &#123; static &#123; System.out.println(&quot;静态代码块Fu&quot;); &#125; &#123; System.out.println(&quot;构造代码块Fu&quot;); &#125; public Fu() &#123; System.out.println(&quot;构造方法Fu&quot;); &#125;&#125;class Zi extends Fu&#123; static &#123; System.out.println(&quot;静态代码块Zi&quot;); &#125; &#123; System.out.println(&quot;构造代码块Zi&quot;); &#125; public Zi() &#123; System.out.println(&quot;构造方法Zi&quot;); &#125;&#125;public class ExtendsTest2 &#123; public static void main(String[] args) &#123; Zi z = new Zi(); &#125;&#125; 结果：123456静态代码块Fu静态代码块Zi构造代码块Fu构造方法Fu //子类初始化会先进行父类的初始化构造代码块Zi构造方法Zi 3.看程序写结果1234567891011121314151617181920212223242526class X &#123; Y b = new Y(); X() &#123; System.out.println(&quot;X&quot;); &#125;&#125;class Y &#123; Y() &#123; System.out.println(&quot;Y&quot;); &#125;&#125;class Z extends X &#123; Y y = new Y(); Z() &#123; //super(); System.out.println(&quot;Z&quot;); &#125; &#125;public class ExtendsTest3 &#123; public static void main(String[] args) &#123; new Z(); &#125;&#125; 结果：1YXYZ 注意：虽然子类中构造方法默认有一个super()但是初始化的时候，不是按照语句的顺序进行的而是按照分层初始化进行的。它仅仅表示要先初始化父类数据，再初始化子类数据。 5.5 继承中成员方法的关系1.子父类不同名方法访问 简单，不是重点2.子父类同名方法访问顺序：（1）先在子类中寻找。（2）然后在父类中寻找。（3）如果还是没有就报错。 5.6 方法重写5.6.1 方法重写：子类中出现了和父类中方法声明一模一样的方法。（一模一样指方法名、参数列表、返回值类型都相同）5.6.2 方法重写的应用1234567891011121314151617181920class Phone &#123; public void call(String name) &#123; System.out.println(&quot;给&quot;+name+&quot;打电话&quot;); &#125;&#125;class NewPhone extends Phone &#123; public void call(String name) &#123; //System.out.println(&quot;给&quot;+name+&quot;打电话&quot;); super.call(name); System.out.println(&quot;听天气预报&quot;); &#125;&#125;public class ExtendsDemo9 &#123; public static void main(String[] args) &#123; NewPhone np = new NewPhone(); np.call(&quot;小强&quot;); &#125;&#125; 注意super.call(name);这个语句，这是方法重写应用的关键。5.6.3 方法重写的注意事项（1）子类不能重写父类的私有方法。1234567class Father &#123; private void show() &#123;&#125;&#125;class Son extends Father &#123; private void show() &#123;&#125; //这个不是方法重写，因为Son并没有继承父类的show（），父类show（）方法是私有的&#125; （2）子类重写父类方法时，权限不能更低。（3）父类静态方法，子类也必须通过静态方法重写。（这个算不上方法重写，但是现象确实如此，至于为什么算不上方法重写，多态中会讲解）5.6.4 面试题1.方法重写和方法重载的区别？方法重载能改变返回值类型吗？Overload和Override我的答案：12方法重写指继承中，子类继承父类的方法，但对父类方法进行改进，在不改变返回值类型、参数列表、方法名的情况下。方法重载指本类中，存在多个方法名相同，但参数列表不同的方法，这是为了应对参数的不同需求，方法重载能改变返回值类型，因为它与返回值类型无关。 视频答案：12345方法重写：在子类中，出现和父类一模一样的方法声明的现象。这里的一模一样指方法名，返回值类型，参数列表都相同。方法重载：同一个类中出现的方法名相同，参数列表不同的现象。方法重载能改变返回值类型，因为它和返回值类型无关。 2.this关键字和super关键字代表什么？以及他们各自的使用场景和作用。this代表本类的对象引用。super代表父类存储空间的标识。 场景：（1）访问成员变量（2）访问构造方法this(…)super(…)（3）访问成员方法 练习1.使用继承后的老师学生类，猫狗案例演示。注意：继承类中父类的this指的是：如果子类重写了，this指的是子类的对象。如果子类没有重写，this指的是父类对象。]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>技能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday07]]></title>
    <url>%2F2019%2F07%2F18%2Fjavaday07%2F</url>
    <content type="text"><![CDATA[一、面向对象_成员变量与局部变量的区别1.在类中的位置不同成员变量：类中方法外局部变量：方法声明上或方法内 2.在内存中的位置不同成员变量：堆内存局部变量：栈内存 3.生命周期不同成员变量：随着对象存在而存在，随着对象消失而消失局部变量：随着方法调用而存在，随着方法调用完毕而消失 4.初始化值不同成员变量：有默认的初始化值局部变量：没有默认的初始化值，必须先定义、赋值，才能使用。 思考题：成员变量名称可不可以和局部变量一样？可以，但是使用的时候要注意，先找小范围，再找大范围。（就近原则） 二、形式参数的问题前面讲到：基本类型：形式参数的改变对实际参数没有影响。引用类型：形式参数的改变直接影响实际参数。类也是一种引用类型，也可以作为调用方法的一个参数，见如下案例1234567891011121314151617181920212223242526272829303132class Demo &#123; public int sum(int a,int b) &#123; return a+b; &#125;&#125;class Student &#123; public void show() &#123; System.out.println(&quot;学生学习&quot;); &#125;&#125;class StudentDemo &#123; public void method(Student s) &#123; s.show(); &#125;&#125;public class ArgsTest &#123; public static void main(String[] args) &#123; //形式参数是基本类型的调用 Demo d = new Demo(); int result = d.sum(10,20); System.out.println(result); System.out.println(&quot;---------&quot;); //形式参数是引用类型的调用 StudentDemo sd = new StudentDemo(); Student s = new Student(); sd.method(s); //类和接口作为形式参数时，实际调用的是它的一个对象。 &#125;&#125; 三、匿名对象1.匿名对象：就是没有名字的对象，是对象的一种简化表示形式。例子：12345678//匿名对象new Student();//匿名对象调用方法new Studnet().show();2.匿名对象的应用场景（1）调用方法，仅仅调用一次的时候。这种调用的好处是：匿名对象调用完毕就是垃圾，可以被垃圾回收器回收。（2）匿名对象可以作为实际参数传递。 四、封装1.封装概述为了防止类中的成员变量被直接使用（非法数据赋值），Java提供了关键字：privateprivate：私有的。可以修饰成员变量和成员方法。注意：被private修饰的成员只能在本类中被访问。这其实是一个封装的思想。封装：指隐藏对象的属性和实现细节，仅对外提供公共访问方式。封装的好处：隐藏实现细节，提供公共的访问方式提高了代码的复用性提高了安全性。封装原则：将不需要对外提供的内容隐藏起来。把属性隐藏，提供公共方法对其访问。 五、private关键字1.privare关键字概述是一个权限修饰符可以修饰成员（成员变量和成员方法）被private修饰的成员只能在本类中被访问。 2.private最常见的应用把成员变量用private修饰提供对应的getXxx()/setXxx()方法 3.private应用的标准案例12345678910111213141516171819202122232425262728293031class Student &#123; private String name; private int age; public void setName(String n) &#123; name = n; &#125; public void setAge(int a) &#123; age = a; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125;&#125;public class StudentTest &#123; public static void main(String[] args) &#123; Student s = new Student(); System.out.println(s.getName()+&quot;---&quot;+s.getAge()); s.setName(&quot;小强&quot;); s.setAge(36); System.out.println(s.getName()+&quot;---&quot;+s.getAge()); &#125;&#125; 六、this关键字1.this:代表所在类的对象引用。方法被哪个对象调用，this就代表那个对象。2.什么时候使用this？（1）局部变量隐藏成员变量（2）其他用法后面和super一起讲解。 3.标准手机类练习12345678910111213141516171819202122232425262728class Phone &#123; private String brand; private int price; public void setBrand(String brand) &#123; this.brand = brand; &#125; public void setPrice(int price) &#123; this.price = price; &#125; public String getBrand() &#123; return brand; &#125; public int getPrice() &#123; return price; &#125;&#125;public class StudentTest &#123; public static void main(String[] args) &#123; Phone p = new Phone(); p.setBrand(&quot;huawei&quot;); p.setPrice(50); System.out.println(p.getBrand()+&quot;---&quot;+p.getPrice()); &#125;&#125; 七、构造方法1.构造方法的作用：给对象的数据进行初始化2.格式方法名与类名相同没有返回值类型，连void都没有没有具体的返回值 3.构造方法的注意事项（1）如果我们没有给出构造方法，系统将自动提供一个无参构造方法。（2）如果我们给出了构造方法，系统将不再提供。 注意：这个时候，如果我们还想使用无参构造方法，就必须自己给出。建议永远自己给出无参构造方法。 4.一个类的组成有三部分：成员变量，构造方法，成员方法。练习：1.一个基本类的标准代码写法（学生类,手机类） 八、类的初始化过程Student s = new Student();在内存中做了哪些事情？加载Student.class文件进内存在栈内存为s开辟空间在堆内存为学生对象开辟空间对学生对象的成员变量进行默认初始化对学生对象的成员变量进行显示初始化通过构造方法对学生对象的成员变量进行赋值学生对象初始化完毕，把对象地址赋值给s变量。 面向对象练习1.定义一个类Demo，其中定义一个求两个数据和的方法，定义一个测试Test，进行测试。2.定义一个长方形类，定义求周长和面积的方法，然后定义一个测试类Test，进行测试。3.定义一个员工类，自己分析出几个成员，然后给出成员变量，构造方法，getXxx()/setXxx()方法，以及一个显示所有成员信息的方法，并测试。4.定义一个类MyMath,实现加减乘除功能。 九、static关键字1.前提：我们创建对象总会碰到多个对象有共同的属性值（例如：邓丽君、杨幂、凤姐都是中国的），Java提供了一个关键字static(静态)来时多个对象共享一个属性值，减少内存空间，提高程序效率。static修饰的变量被赋值后，所有对象的该属性对应的值都是被赋值的这个数据，因为它们共享同一个属性值，可以理解成它们同时共享这个属性。 2.static的特点（1）随着类的加载而加载（想想main方法）（2）优先于对象存在（3）被类的所有对象共享（饮水机可以用静态修饰，水杯不能用静态修饰）（4）可以通过类名调用（也可以和非静态一样，通过对象名调用，推荐用类名调用，静态修饰的内容我们一般称其为：与类相关的，类成员） 3.static关键字注意事项（1）在静态方法中时没有this关键字的如何理解：静态是随着类的加载而加载，而this是随着对象的创建而存在。静态优先于对象存在。在静态加载到内存时，是没有所谓的this的，因为那时候对象还没创建。（2）静态方法只能访问静态的成员变量和静态的成员方法。静态方法：成员变量：只能访问静态变量成员方法：只能访问成员方法非静态方法：成员变量：可以是静态的，也可以是非静态的。成员方法：可以是静态的成员方法，也可以是非静态的成员方法。简单记：静态只能访问静态的，而非静态的可以访问一切。 4.静态变量和成员变量的区别（1）所属不同静态变量属于类，所以也称为类变量成员变量属于对象，所以也称为实例变量（对象变量）（2）内存中位置不同静态变量存储于方法区的静态区成员变量存储于堆内存（3）内存出现时间不同静态变量随着类的加载而加载，随着类的消失而消失成员变量随着对象的创建而存在，随着对象的消失而消失（4）调用不同静态变量可以通过对象名调用，也可以通过类名调用成员变量只能通过对象名调用]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday06]]></title>
    <url>%2F2019%2F07%2F17%2Fjavaday06%2F</url>
    <content type="text"><![CDATA[一、二维数组1.二维数组概述二维数组就是元素为一维数组的数组。 2.二维数组的定义格式格式1:12345数据类型[][] 变量名 = new 数据类型[m][n];m表示二维数组有m个一维数组n表示一维数组有n个元素举例：int[][] arr = new int[3][2]; 定义了一个二维数组arr，这个二维数组有3个一维数组，分别是arr[0],arr[1],arr[2];每一个一维数组有2个元素，可以通过arr[m][n]来获取（表示获取第m+1个一维数组的第n+1个元素）注意下列定义的区别：int x,y; //定义一个x变量，一个y变量int[] x,y[]; //定义一个一维数组x，一个二维数组y练习：自己定义一个二维数组并输出二维数组名，一维数组名，部分元素。格式2:1234567数据类型[][] 变量名 = new 数据类型[m][];m表示这个二维数组有m个一维数组这一次没有直接给出一维数组，可以动态的给出int[][] arr = new int[3][];arr[0] = new int[2];arr[1] = new int[3];arr[2] = new int[1]; 格式3:1234数据类型[][] 变量名 = new 数据类型[][] &#123;&#123;元素...&#125;,&#123;元素...&#125;,&#123;元素...&#125;,...&#125;;简化版格式：数据类型[][] 变量名 = &#123;&#123;元素...&#125;,&#123;元素...&#125;,&#123;元素...&#125;,...&#125;;举例：int[][] arr = &#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6&#125;&#125; 练习：1.二维数组遍历12345678910111213141516171819202122232425public class ArrayTest &#123; public static void main(String[] args) &#123; int[][] arr = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;; printArray2(arr); &#125; public static void printArray2(int[][] arr) &#123; System.out.print(&quot;&#123;&quot;); for(int x=0;x&lt;arr.length;x++) &#123; System.out.print(&quot;&#123;&quot;); for(int y=0;y&lt;arr[x].length;y++) &#123; if(y == arr[x].length-1) &#123; if(x == arr.length-1) &#123; System.out.print(arr[x][y]+&quot;&#125;&quot;); &#125;else &#123; System.out.print(arr[x][y]+&quot;&#125;,&quot;); &#125; &#125;else &#123; System.out.print(arr[x][y]+&quot;,&quot;); &#125; &#125; &#125; System.out.println(&quot;&#125;&quot;); &#125;&#125; 2.公司年销售额求和某公司按照季度和月份统计的数据如下：单位（万元）第一季度：22，66，44第二季度：77，33，88第三季度：25，45，65第四季度：11，66，99123456789101112131415161718192021public class Array2Test2 &#123; public static void main(String[] args) &#123; int[][] arr = &#123;&#123;22,66,44&#125;,&#123;77,33,88&#125;,&#123;25,45,65&#125;,&#123;11,66,99&#125;&#125;; int sum = getSum(arr); System.out.println(&quot;sum:&quot;+sum); &#125; //两个明确： //返回值：int //参数列表：int[][] arr public static int getSum(int[][] arr) &#123; int sum=0; for(int x=0;x&lt;arr.length;x++) &#123; for(int y=0;y&lt;arr[x].length;y++) &#123; sum += arr[x][y]; &#125; &#125; return sum; &#125;&#125; 3.打印杨辉三角(行数可以键盘录入)杨辉三角： 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1自己的做法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.util.Scanner;public class Array2Test3 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入需要绘制的杨辉三角的行数：&quot;); int n = sc.nextInt(); printYang(n); &#125; //两个明确： //返回值类型：void //参数列表：int n public static void printYang(int n) &#123; //创建杨辉三角的数组形状 int[][] arr = new int[n][]; for(int x=0;x&lt;n;x++) &#123; arr[x] = new int[x+1]; &#125; //进行数组的赋值 for(int x=0;x&lt;n;x++) &#123; if(x==0 || x==1) &#123; for(int y=0;y&lt;=x;y++) &#123; arr[x][y]=1; &#125; &#125;else &#123; arr[x][0]=1; for(int y=1;y&lt;=x/2;y++) &#123; arr[x][y]=arr[x-1][y-1]+arr[x-1][y]; &#125; for(int start=0,end=arr[x].length-1;start&lt;end;start++,end--) &#123; arr[x][end] = arr[x][start]; &#125; &#125; &#125; //输出赋值后的杨辉三角 for(int x=0;x&lt;n;x++) &#123; for(int y=0;y&lt;=x;y++) &#123; System.out.print(arr[x][y]+&quot;\t&quot;); &#125; System.out.println(); &#125; &#125; &#125; 视频做法(比较简洁)1234567891011121314151617181920212223242526272829303132import java.util.Scanner;public class Array2Test2Agian &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入要输出的杨辉三角的行数：&quot;); int n = sc.nextInt(); printY(n); &#125; public static void printY(int n) &#123; int[][] arr = new int[n][n]; for(int x=0;x&lt;n;x++) &#123; arr[x][0] = 1; arr[x][x] = 1; &#125; for(int x=2;x&lt;n;x++) &#123; for(int y=1;y&lt;=x-1;y++) &#123; arr[x][y] = arr[x-1][y-1]+arr[x-1][y]; &#125; &#125; for(int x=0;x&lt;n;x++) &#123; for(int y=0;y&lt;=x;y++) &#123; System.out.print(arr[x][y]+&quot;\t&quot;); &#125; System.out.println(); &#125; &#125;&#125; 二维数组思考题：1.看程序写结果，并总结基本类型和引用类型参数的传递问题123456789101112131415161718192021222324252627282930public class Array2Think &#123; public static void main(String[] args) &#123; int a = 10; int b = 20; System.out.println(&quot;a:&quot;+a+&quot;b:&quot;+b); change(a,b); System.out.println(&quot;a:&quot;+a+&quot;b:&quot;+b);// 10,20 int[] arr = &#123;1,2,3,4,5&#125;; change(arr); System.out.println(arr[1]);//4 &#125; public static void change(int a,int b) &#123; System.out.println(&quot;a:&quot;+a+&quot;b:&quot;+b); a = b; b = a+b; System.out.println(&quot;a:&quot;+a+&quot;b:&quot;+b); &#125; public static void change(int[] arr) &#123; for(int x=0;x&lt;arr.length;x++) &#123; if(arr[x]%2==0) &#123; arr[x]*=2; &#125; &#125; &#125;&#125; Java中的参数传递问题 基本类型：形式参数的改变对实际参数没有影响。 引用类型：形式参数的改变直接影响实际参数。2.数据加密问题(重点！重点！一定要掌握)某个公司采用公用电话传递数据信息，数据是小于8位的整数，为了确保安全，在传递过程中需要加密，加密规则如下：首先将数据倒序，然后将每位数字都加上5，再用和除以10的余数代替该数字，最后将第一位和最后一位数字交换。请任意给定一个小于8位的整数，然后，把加密后的结果在控制台打印出来。该题的重点是如何把数据转换成数组：1234567891011121314151617181920212223242526272829303132333435363738import java.util.Scanner;public class Array2Think2 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入整数(少于八位)：&quot;); int num = sc.nextInt(); change(num); &#125; //两个明确 //返回值类型：void //参数列表:int num public static void change(int num) &#123; //将数据用数组存储 int[] arr = new int[8]; int index = 0; while(num&gt;0) &#123; arr[index] = num%10; index++; num/=10; &#125; //加密规则 for(int x=0;x&lt;index;x++) &#123; arr[x] = (arr[x]+5)%10; &#125; arr[0] = (arr[0]+arr[index-1])-(arr[index-1]=arr[0]); //输出数据 for(int x=0;x&lt;index;x++) &#123; System.out.print(arr[x]); &#125; &#125; &#125; 输入：123456;输出：609871. 二、面向对象1.类与对象的关系类：是一组相关的属性和行为的集合。对象：是该类事物的具体体现。举例：类：学生对象：班长就是学生类的一个对象。 2.类的定义现实世界的事物属性 人的身高、体重等行为 人可以学习、吃饭等Java中用class描述事物也是如此成员变量 就是事物的属性成员方法 就是事物的行为定义类其实就是定义类的成员（成员变量和成员方法）成员变量：和以前变量的定义是一样的格式，但是位置不同，类中方法外。成员方法：和以前的方法定义是一样的格式，但是今天把static去掉。 练习：1.学生类定义属性：姓名 年龄 地址行为：学习 吃饭 睡觉2.手机类定义属性：品牌 价格 颜色行为：打电话 发短信 玩游戏 3.在一个java文件中写两个类：一个基本的类，一个测试类。注意：文件名称和测试类名称一致。如何使用呢？ 创建对象使用如何创建对象？格式： 类名 对象名 = new 类名();如何使用成员变量？对象名.变量名如何使用成员方法？对象名.方法名(…) 练习：1.学生类和手机类的成员变量赋值输出，方法调用练习。2.三个对象的内存图]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday05]]></title>
    <url>%2F2019%2F07%2F14%2Fjavaday05%2F</url>
    <content type="text"><![CDATA[一、方法1.前言：假设有一个游戏要不断发射炮弹（植物大战僵尸），发射炮弹需要100行代码，每次发射都写100行代码的话，会很费劲，代码也会显得臃肿，可读性差。所以把这100行代码放入{}中，然后给这段代码起个名字，这样在每次发射炮弹的地方通过这个名字来调用发射炮弹的代码就ok.上述过程中，所提取出来的代码可以被看作是程序中定义的一个方法，程序在需要发射炮弹时调用该方法即可。简单的说：方法就是完成特定功能的代码块在很多语言里面都有函数的定义，函数在java中被称为方法。 2.格式：修饰符 返回值类型 方法名（参数类型 参数名1，参数类型 参数名2，…） { 方法体语句； return 返回值；}上述格式的详细解释： 修饰符：目前就用public static，后面我们再讲解其他的修饰符。 返回值类型：就是功能结果的数据类型。 方法名：符合命名规则即可。 参数： 实际参数：就是实际参与运算的。 形式参数：就是方法定义上的。用于接收实际参数的。 参数类型：就是参数的数据类型。 参数名：就是变量名。 方法体语句：完成功能的代码。 return：结束方法。 返回值：功能的结果，由return返回给调用者。 3.要想写好一个方法，需要明确两个东西：（1）返回值类型 结果的数据类型（2）参数列表 你要传递几个参数以及它们的数据类型。案例：求两个数据之和。1234567891011public class FunctionDemo &#123; public static void main(String[] args) &#123; int x=10; int y=20; &#125; public static int sum(int a,int b) &#123; return a+b; &#125;&#125; 4.方法的执行特点：不调用，不执行如何调用？（以两个数据求和案例为例）（1）有明确返回值的调用//方式1:单独调用sum(x,y); //一般来说没有意义，所以不推荐。//方式2:输出调用System.out.println(sum(x,y)); ////方式3：赋值调用int result = sum(x,y); //推荐方案System.out.println(result); 5.有明确返回值的方法练习：5.1键盘录入两个数据，返回两个数中的较大值。12345678910111213141516171819import java.util.Scanner;public class FunctionTest &#123; public static void main(String[] args) &#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入要进行比较的第一个数据：&quot;); int x = sc.nextInt(); System.out.println(&quot;请输入要进行比较的第二个数据：&quot;); int y = sc.nextInt(); int result = getMax(x,y); System.out.println(&quot;输入的两个数据中，较大值是：&quot;+result); &#125; public static int getMax(int a,int b) &#123; return a&gt;b?a:b; &#125;&#125; 5.2键盘录入两个数据，比较两个数是否相等。12345678910111213141516171819202122import java.util.Scanner;public class FunctionTest2 &#123; public static void main(String[] args) &#123; //键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入第一个数据：&quot;); int x = sc.nextInt(); System.out.println(&quot;请输入第二个数据：&quot;); int y = sc.nextInt(); boolean result = getEqual(x,y); if(result == true) &#123; System.out.println(&quot;输入的这两个数据相等&quot;); &#125;else &#123; System.out.println(&quot;输入的这两个数据不相等&quot;); &#125; &#125; public static boolean getEqual(int a,int b) &#123; return a==b; &#125;&#125; 5.3键盘录入三个数据，返回三个数中的最大值。1234567891011121314151617181920import java.util.Scanner;public class FunctionTest3 &#123; public static void main(String[] args) &#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入第一个数据：&quot;); int x = sc.nextInt(); System.out.println(&quot;请输入第二个数据：&quot;); int y = sc.nextInt(); System.out.println(&quot;请输入第三个数据：&quot;); int z = sc.nextInt(); int result = getMax(x,y,z); System.out.println(&quot;三个数中的最大值是：&quot;+result); &#125; public static int getMax(int a,int b,int c) &#123; return a&gt;b?(a&gt;c?a:c):(b&gt;c?b:c); &#125;&#125; 6.方法的注意事项(1)方法不调用，不执行。(2)方法与方法是平级关系，不能嵌套定义。(3)方法定义的时候参数之间用逗号隔开。(4)方法调用的时候不用再传递数据类型。(5)如果方法有明确的返回值，一定要有return带回一个值。 7.无明确返回值的调用案例：输出m行n列“*”(方法)1234567891011121314public class FunctionTest4 &#123; public static void main(String[] args) &#123; showStar(7,11); &#125; public static void showStar(int m,int n) &#123; for(int x=0;x&lt;m;x++) &#123; for(int y=0;y&lt;n;y++) &#123; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; &#125;&#125; （1）单独调用 //可以（2）输出调用 //报错（3）赋值调用 //报错只有单独调用是可行的。 练习：1.键盘录入行数和列数，输出对应的星形123456789101112131415161718192021import java.util.Scanner;public class FunctionTest4 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入行数：&quot;); int h = sc.nextInt(); System.out.println(&quot;请输入列数：&quot;); int l = sc.nextInt(); showStar(h,l); &#125; public static void showStar(int m,int n) &#123; for(int x=0;x&lt;m;x++) &#123; for(int y=0;y&lt;n;y++) &#123; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; &#125;&#125; 2.键盘录入一个数据n（1&lt;=n&lt;=9）,输出对应的nn乘法表123456789101112131415161718import java.util.Scanner;public class FunctionTest5 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入数据n:&quot;); int n = sc.nextInt(); printN(n); &#125; public static void printN(int n) &#123; for(int x=1;x&lt;=n;x++) &#123; for(int y=1;y&lt;=x;y++) &#123; System.out.print(x+&quot;*&quot;+y+&quot;=&quot;+x*y+&quot;\t&quot;); &#125; System.out.println(); &#125; &#125;&#125; 7.方法重载前言：需求：我要求数的和1234567891011121314151617181920class FunctionDemo4 &#123; public static void main(String[] args) &#123; &#125; //需求1:求两个数的和 public static int sum(int a,int b) &#123; return a+b; &#125; //需求2:求三个数的和 public static int sum1(int a,int b,int c) &#123; return a+b+c; &#125; //需求3:求四个数的和 public static int sum2(int a,int b,int c,int d) &#123; return a+b+c+d; &#125;&#125; 我们的需求不断的发生改变，我们就对应的提供了多个求和的方法。但是它们的名字是不一样的。而我们又要求方法命名做到：见名知意。但是，很明显，现在还没有做到。那么，怎么办呢？针对这种情况：方法功能相同，参数列表不同的情况。为了见名知意：Java允许它们起一样的名字。如下： 1234567891011121314151617181920class FunctionDemo4 &#123; public static void main(String[] args) &#123; &#125; //需求1:求两个数的和 public static int sum(int a,int b) &#123; return a+b; &#125; //需求2:求三个数的和 public static int sum(int a,int b,int c) &#123; return a+b+c; &#125; //需求3:求四个数的和 public static int sum(int a,int b,int c,int d) &#123; return a+b+c+d; &#125;&#125; 这种情况有一个专业名词：方法重载。方法重载：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。方法重载特点：与返回值无关，只看方法名和参数列表。在调用时，虚拟机通过参数列表的不同来区分同名方法。上面的案例继续：123public static float sum(float a,float b) &#123; return a+b;&#125; 调用:1System.out.println(sum(10.5f,20)); //虽然一个是float类型，一个是int类型，但是调用的是float的sum方法，因为int可以转成float（其实这里我没有理解，先记着吧）。结果输出30.5 若是没有123public static int sum(int a,int b) &#123; return a+b;&#125; 只有123public static float sum(float a ,float b) &#123; return a+b;&#125; 而在main方法里执行语句1System.out.println(sum(10,20)); 不会报错，因为这个语句会调用float类型的sum方法，10，20在方法中转为float类型进行计算。 练习：1.比较两个数据是否相等。参数类型分别为两个byte类型，两个short类型，两个int类型，两个long类型。并在main方法中进行测试。12345678910111213141516171819202122232425262728293031public class ReLoadTest &#123; public static void main(String[] args) &#123; byte b1 = 3; byte b2 = 4; System.out.println(equal(b1,b2)); short s1 = 5; short s2 = 6; System.out.println(equal(s1,s2)); &#125; public static boolean equal(byte a,byte b) &#123; System.out.println(&quot;byte&quot;); return a==b; &#125; public static boolean equal(short a,short b) &#123; System.out.println(&quot;short&quot;); return a==b; &#125; public static boolean equal(int a,int b) &#123; System.out.println(&quot;int&quot;); return a==b; &#125; public static boolean equal(long a,long b) &#123; System.out.println(&quot;long&quot;); return a==b; &#125;&#125; 二、数组1.数组概述需求：现在需要统计某公司员工的工资情况，例如计算平均工资、找到最高工资等等。假设该公司有80名员工，用前面所学的知识，程序需要先声明80个变量来分别记住每个员工的工资，然后在进行操作，这样做会显得很麻烦。为了解决这种问题，Java就提供了数组供我们使用。那么数组到底是什么呢？有什么特点？通过上面的分析，我们可以得到以下结论：（1）数组是存储多个变量（元素）的容器。（2）这多个变量的数据类型要一致。 2.数组概念数组是存储同一数据类型多个元素的集合。也可以看作是一个容器。数组既可以存储基本数据类型（byte,short,int,long,float,double,boolean,char），也可以存储引用数据类型。（引用数据类型包括类，接口，数组） 3.数组的定义格式格式1:数据类型[] 数组名;格式2:数据类型 数组名[];注意：这两种定义做完了，数组中是没有元素值的。如何对元素进行初始化呢？ 4.数组初始化（1）数组初始化概述：Java中的数组是变量，必须进行初始化才能使用。所谓初始化，就是为数组中的数组元素分配内存空间，并为每个数组元素赋值。（2）数组的初始化方式：1、动态初始化：初始化时只指定数组长度，由系统为数组分配初始值。动态初始化格式：数据类型[] 数组名 = new 数据类型[数组长度]; //数组长度就是数组中元素的个数。举例：int[] arr = new int[3]; //定义了一个int类型的数组，这个数组可以存放3个int类型的值。123456789101112131415/* * 动态初始化演示 */public class ArrayDemo &#123; public static void main(String[] args) &#123; //定义一个长度为3的int类型数组a变量 int[] arr = new int[3]; System.out.println(arr); //输出的是地址值, //如果要输出其中的元素，需要配合数组名和编号，格式为arr[0] //通用格式：数组名[元素编号] //元素编号从0开始,最后一个元素编号为数组长度-1。这个编号的专业叫法：索引 System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); &#125;&#125; 总结：如何获取数组中的元素？通过：数组名[索引]，索引就是每个元素的编号，从0开始，最大索引编号为数组长度-1； 5.Java中的内存分配Java程序在运行时，需要在内存中分配空间。为了提高运算效率，就对空间进行不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。分为：栈 存储局部变量堆 存储new出来的东西方法区（面向对象部分详细讲解）本地方法区（和系统有关）寄存器（给cpu使用）局部变量：在方法定义中或者方法声明上的变量都成为局部变量。堆内存的特点：a、每一个new出来的东西都有地址值。b、每个变量都有默认值byte,short,int,long 0float,double 0.0char ‘\u0000’boolean false引用类型c、使用完毕就变成了垃圾，但是并没有立即回收。会在垃圾回收器空闲的时候回收。练习：1.定义一个数组，输出该数组的名称和数组元素值给数组元素赋值，再次输出该数组的名称和数组元素值。2.定义两个数组，输出两个数组的名称和数组元素值然后给每个数组的元素重新赋值，再次分别输出两个数组各自的数组名及元素值。3.定义第一个数组，定义完毕后，给数组元素赋值，赋值完毕后，再输出数组名和元素。定义第二个数组，定义完毕后，给数组元素赋值，赋值完毕后，再输出数组名和元素。定义第三个数组，把第一个数组的地址值赋值给它。（注意类型一致），通过第三个数组的名称去把元素重复赋值。最后，再次输出第一个数组的名称和元素。1234567891011121314151617181920212223242526272829303132333435363738394041public class ArrayDemo4 &#123; public static void main(String[] args) &#123; //定义第一个数组并赋值 int[] arr = new int[3]; arr[0] = 88; arr[1] = 33; arr[2] = 66; System.out.println(arr); System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); System.out.println(&quot;---------&quot;); int[] arr2 = new int[3]; arr2[0] = 22; arr2[1] = 44; arr2[2] = 55; System.out.println(arr2); System.out.println(arr2[0]); System.out.println(arr2[1]); System.out.println(arr2[2]); System.out.println(&quot;------------&quot;); //定义第三个数组并赋值 int[] arr3 = arr; arr3[0] = 100; arr3[1] = 200; System.out.println(arr); System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); System.out.println(arr3); System.out.println(arr3[0]); System.out.println(arr3[1]); System.out.println(arr3[2]); &#125;&#125; 2、静态初始化：初始化时指定每个数组元素的初始值，由系统决定数组长度。格式：数据类型[] 数组名 = new 数据类型[] {元素1,元素2,…};简化版格式：数据类型[] 数组名 = {元素1,元素2,…}举例：int[] arr = new int[] {1,2,3};简化格式：int[] arr = {1,2,3};注意事项：不要同时动态和静态进行初始化。12arr = null;System.out.println(arr[0]); 报错：NullPointerException:空指针异常原因：数组已经不在指向堆内存，而你还用数组名去访问元素。 数组练习1.数组遍历(依次输出数组中的每一个元素)自己的做法123456789public class ArrayTest &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,3,4,5&#125;; System.out.println(arr); for(int x=0;x&lt;arr.length;x++) &#123; System.out.println(arr[x]); &#125; &#125;&#125; 视频做法：123456789101112131415161718192021222324public class ArrayTest &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,3,4,5&#125;; printArray(arr); &#125; //方法改进 /* * 两个明确： * 返回值类型：void * 参数列表：int[] arr */ public static void printArray(int[] arr) &#123; System.out.print(&quot;[&quot;); for(int x=0;x&lt;arr.length;x++) &#123; if(x == arr.length-1) &#123; System.out.println(arr[x]+&quot;]&quot;); &#125;else &#123; System.out.print(arr[x]+&quot;,&quot;); &#125; &#125; &#125;&#125; 2.数组获取最值（获取数组中的最大值最小值）自己的做法123456789101112public class ArrayTest2 &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,3,4,5&#125;; int max = arr[0]; for(int x=0;x&lt;arr.length;x++) &#123; if(max&lt;arr[x]) &#123; max = arr[x]; &#125; &#125; System.out.println(&quot;max:&quot;+max); &#125;&#125; 视频做法：1234567891011121314151617181920212223public class ArrayTest2 &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,3,4,5&#125;; int max = getMax(arr); System.out.println(&quot;max:&quot;+max); &#125; /* * 方法改进 * 两个明确： * 返回值类型：int * 参数列表：int[] arr */ public static int getMax(int[] arr) &#123; int max = arr[0]; for(int x=0;x&lt;arr.length;x++) &#123; if(max&lt;arr[x]) &#123; max = arr[x]; &#125; &#125; return max; &#125;&#125; 3.数组元素逆序（就是把元素对调）自己的做法12345678910111213public class ArrayTest3 &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,3,4,5&#125;; for(int x=0;x&lt;arr.length/2;x++) &#123; arr[x] = (arr[x]+arr[arr.length-1-x])-(arr[arr.length-1-x]=arr[x]); &#125; System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); System.out.println(arr[3]); System.out.println(arr[4]); &#125;&#125; 视频做法1234567891011121314151617181920212223242526272829303132public class ArrayTest3 &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,3,4,5&#125;; reverse(arr); printArray(arr); &#125; /* * 方法改进 * 两个明确： * 返回值类型：void //有人会想到应该返回逆序后的数组，但是没必要，因为这两个数组是同一个数组，引用类型和基本数据类型不一样，调用方法后变量的结果已经产生了变化。 * 参数列表：int[] arr * */ public static void reverse(int[] arr) &#123; for(int x=0;x&lt;arr.length/2;x++) &#123; arr[x] = (arr[x]+arr[arr.length-1-x])-(arr[arr.length-1-x]=arr[x]); &#125; &#125; public static void printArray(int[] arr) &#123; System.out.print(&quot;[&quot;); for(int x=0;x&lt;arr.length;x++) &#123; if(x == arr.length-1) &#123; System.out.println(arr[x]+&quot;]&quot;); &#125;else &#123; System.out.print(arr[x]+&quot;,&quot;); &#125; &#125; &#125;&#125; 视频做法21234567891011121314151617181920212223242526272829303132333435public class ArrayTest3 &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,3,4,5&#125;; printArray(arr); reverse(arr); printArray(arr); &#125; /* * 方法改进 * 两个明确： * 返回值类型：void //有人会想到应该返回逆序后的数组，但是没必要，因为这两个数组是同一个数组，引用类型和基本数据类型不一样，调用方法后变量的结果已经产生了变化。 * 参数列表：int[] arr * */ public static void reverse(int[] arr) &#123; for(int start=0,end=arr.length-1;start&lt;=end;start++,end--) &#123; int temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; &#125; &#125; public static void printArray(int[] arr) &#123; System.out.print(&quot;[&quot;); for(int x=0;x&lt;arr.length;x++) &#123; if(x == arr.length-1) &#123; System.out.println(arr[x]+&quot;]&quot;); &#125;else &#123; System.out.print(arr[x]+&quot;,&quot;); &#125; &#125; &#125;&#125; 4.数组查表法（根据键盘录入索引，查找对应星期）意思是：String[] strArray = {“星期一”,”星期二”,…}自己的做法123456789101112131415161718192021222324import java.util.Scanner;public class ArrayTest4 &#123; public static void main(String[] args) &#123; String[] strArray = &#123;&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;,&quot;星期日&quot;&#125;; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入星期对应的索引(1-7)：&quot;); int index = sc.nextInt(); String str = getWeek(index,strArray); System.out.println(&quot;您输入的索引对应的星期是：&quot;+str); &#125; /* * 方法： * 两个明确： * 返回值类型：String * 参数列表：int index,String[] strArray */ public static String getWeek(int index,String[] strArray) &#123; return strArray[index-1]; &#125;&#125; 视频做法12345678910111213import java.util.Scanner;public class ArrayTest4 &#123; public static void main(String[] args) &#123; String[] strArray = &#123;&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;,&quot;星期日&quot;&#125;; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入星期对应的索引(0-6)：&quot;); int index = sc.nextInt(); System.out.println(&quot;你要查找的日期是:&quot;+strArray[index]); &#125; &#125; 5.数组元素查找（查找指定元素第一次在数组中出现的索引）自己的做法12345678910111213141516import java.util.Scanner;public class ArrayTest5 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入要查找的元素（1-5）：&quot;); int num = sc.nextInt(); int[] arr = &#123;5,4,3,2,1,1,3,5,2,4&#125;; for(int x=0;x&lt;arr.length;x++) &#123; if(num == arr[x]) &#123; System.out.println(num+&quot;元素在数组中第一次出现的索引是&quot;+x); break; &#125; &#125; &#125;&#125; 终极版(注意方法的返回值问题！！！)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.Scanner;public class ArrayTest5 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入要查找的元素（1-5）：&quot;); int num = sc.nextInt(); int[] arr = &#123;5,4,3,2,1,1,3,5,2,4&#125;; int result = getIndex(num,arr); if(result&gt;0 &amp;&amp; result&lt;6) &#123; System.out.println(&quot;你输入的数据在数组中出现的第一次索引是：&quot;+result); &#125;else &#123; System.out.println(&quot;你输入的数据在数组中并不存在&quot;); &#125; &#125; /* * 方法 * 两个明确： * 返回值类型：int * 参数列表：int num,int[] arr */ public static int getIndex(int num,int[] arr) &#123; for(int x=0;x&lt;arr.length;x++) &#123; if(num == arr[x]) &#123; return x; &#125; &#125; return -1; &#125; //目前的代码有一个小问题 //就是假如我要查找的数据在数组中不存在，那就找不到，找不到的话，你有对应的返回吗？ //所以报错。 //只要是判断，就可能是false，所以大家要细心。 //如果找不到数据，我们一般返回一个负数即可，而且习惯是返回-1； //getIndex方法改进 /* * public static int getIndex(int num,int[] arr) &#123; int index = -1; for(int x=0;x&lt;arr.length;x++) &#123; if(num == arr[x]) &#123; index = x; &#125; &#125; return index; &#125; */&#125; 6.数组排序和二分查找（后面在数组高级部分讲解）]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday04]]></title>
    <url>%2F2019%2F07%2F08%2Fjavaday04%2F</url>
    <content type="text"><![CDATA[一、switch语句1.switch语句格式：123456789101112switch(表达式) &#123; //表达式的取值可以是byte,short,int,char。jdk5之后可以是枚举,jdk7之后可以是String。 case 值1: 语句体1； break; case 值2: 语句体2； break; ... default: 语句体n+1; break; //这个break可以省略&#125; 面试题：1.byte可以作为switch的表达式吗？可以。long可以作为switch的表达式吗？不可以。String可以作为switch的表达式吗？jdk7以后可以。 练习题：1.键盘录入一个数据，根据这个数据，输出对应的星期。 如果选择结构是与几个固定的值比较，建议使用switch。 switch语句的注意事项：1.case后面只能是常量，且不能重复2.default可以省略，但是不建议省略。除非是类似单选题这种情况。3.break可以省略，但是省略可能与预期的结果不一样，建议不省略。（注意！switch语句执行过程中并不是按顺序与case值逐一比较，而是寻找与表达式相同的值，然后从该值的位置开始执行语句。如果该值后续的语句体没有break，可能会继续执行下一个case的语句体，直到出现break为止。配合如下案例进行理解。上述现象也叫做case穿透）案例：1234567891011121314int x = 2;switch(x) &#123; case 1: System.out.println(1); break; case 2: System.out.println(2); case 3: System.out.println(3); break; default: System.out.println(&quot;输入有误&quot;)&#125; 输出结果为：1223 因为case 2后面的语句体并没有break，所以会继续执行case 3的语句，case 3有break，所以停止。4.default可以在任意位置，但一般放最后。5.switch语句执行时，遇到break或运行至最后才结束。 switch语句练习：1.看程序写结果123456789101112int x = 2;int y = 3;switch(x) &#123; default: y++; break; case 3: y++; case 4: y++;&#125;System.out.println(&quot;y=&quot;+y); 结果：y=41234567891011int a = 2;int b = 3;switch(a) &#123; default: b++; case 3: b++; case 4: b++;&#125;System.out.println(&quot;b=&quot;+b); 结果：b=62.模拟做单项选择题，根据你的选择，给出对应的答案。（表达式是字符的情况）123456789101112131415161718192021222324252627282930313233343536import java.util.Scanner;public class SwitchTest2 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;下面的几个人你最爱谁？&quot;); System.out.println(&quot;65 林青霞&quot;); System.out.println(&quot;66 张曼玉&quot;); System.out.println(&quot;67 刘德华&quot;); System.out.println(&quot;68 王力宏&quot;); System.out.println(&quot;请输入你的选择:&quot;); int choiceNumber = sc.nextInt(); //强制转换为字符类型 char choice = (char) (choiceNumber); switch(choice) &#123; case &apos;A&apos;: System.out.println(&quot;恭喜你，答对了&quot;); break; case &apos;B&apos;: System.out.println(&quot;很遗憾，你答错了&quot;); break; case &apos;C&apos;: System.out.println(&quot;很遗憾，你答错了&quot;); break; case &apos;D&apos;: System.out.println(&quot;很遗憾，你答错了&quot;); break; default: System.out.println(&quot;你输入的不是有效数字&quot;); break; &#125; &#125;&#125; 3.键盘录入字符串，根据给定的字符串，来输出你选择的字符串是什么？（表达式是字符串的情况）1234567891011121314151617181920212223242526import java.util.Scanner;public class SwitchTest3 &#123; public static void main(String[] args) &#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); //录入数据 System.out.println(&quot;请输入字符串：&quot;); String s = sc.nextLine(); switch(s) &#123; case &quot;hello&quot;: System.out.println(&quot;你输入的是hello&quot;); break; case &quot;world&quot;: System.out.println(&quot;你输入的是world&quot;); break; case &quot;java&quot;: System.out.println(&quot;你输入的是java&quot;); break; default: System.out.println(&quot;没有找到你输入的数据&quot;); break; &#125; &#125;&#125; 4.用switch语句实现键盘录入月份，输出对应的季节。12345678910111213141516171819202122232425262728293031323334353637import java.util.Scanner;public class SwitchTest4 &#123; public static void main(String[] args) &#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); //录入数据 System.out.println(&quot;请输入数据（1-12）:&quot;); int month = sc.nextInt(); switch(month) &#123; case 1: case 2: case 12: System.out.println(&quot;冬季&quot;); break; case 3: case 4: case 5: System.out.println(&quot;春季&quot;); break; case 6: case 7: case 8: System.out.println(&quot;夏季&quot;); break; case 9: case 10: case 11: System.out.println(&quot;秋季&quot;); break; default: System.out.println(&quot;你输入的数据有误&quot;); break; &#125; &#125;&#125; if语句和switch语句的区别？使用场景：if语句：（1）针对结果是boolean类型的判断（2）针对一个范围的判断。（3）针对几个常量的判断。switch语句：（1）针对几个常量的判断。 二、循环结构for语句1.前提：循环语句的组成：（1）初始化语句（2）判断条件语句（3）循环体语句（4）控制条件语句循环语句的分类：（1）for循环（2）while循环（3）do…while循环 2.for循环语句格式for(初始化语句;判断条件语句;控制条件语句) { 循环体语句;}执行流程：（1）执行初始化语句（2）执行判断条件语句，看其结果是true还是false。如果是true，继续执行；如果是false，循环结束。（3）执行循环体语句（4）执行控制条件语句（5）回到（2）继续。 3.for语句注意事项：（1）如果循环体语句只有一条语句，大括号可省略，建议永远不要省略。（2）有分号没有左大括号，有左大括号就没有分号。 for循环练习：1.请在控制台输出数据1-102.请在控制台输出数据10-13.求出1-10之间数据之和4.求出1-100之间偶数和5.求出1-100之间奇数和6.求5的阶乘7.在控制台输出所有“水仙花数”12345什么叫“水仙花数”？水仙花数是指一个三位数，其各位数字的立方和等于该数本身。举例：153就是一个水仙花数153 = 1*1*1+5*5*5+3*3*3 1234567891011121314自己想的方法：public class ForDemo &#123; public static void main(String[] args) &#123; for(int num=100;num&lt;=999;num++) &#123; int x = num/100; int y = (num-x*100)/10; int z = (num-x*100-y*10); if(num == (x*x*x+y*y*y+z*z*z)) &#123; System.out.println(num+&quot;是一个水仙花数&quot;); &#125; &#125; &#125;&#125; 12345678910111213141516视频中的方法：public class ForDemo &#123; public static void main(String[] args) &#123; int count = 0; for(int num=100;num&lt;=999;num++) &#123; int x = num%10; int y = num/10%10; int z = num/100%10; if(num == (x*x*x+y*y*y+z*z*z)) &#123; System.out.println(num+&quot;是一个水仙花数&quot;); count++; &#125; &#125; System.out.println(&quot;水仙花数一共有&quot;+count+&quot;个&quot;); &#125;&#125; 8.统计“水仙花数”共有多少个？9.请在控制台输出满足如下条件的五位数个位等于万位十位等于千位个位+十位+千位+万位=百位1234567891011121314151617public class ForDemo &#123; public static void main(String[] args) &#123; int count = 0; for(int num=10000;num&lt;=99999;num++) &#123; int ge = num%10; int shi = num/10%10; int bai = num/100%10; int qian = num/1000%10; int wan = num/10000%10; if((ge==wan)&amp;&amp;(shi==qian)&amp;&amp;(ge+shi+qian+wan == bai)) &#123; System.out.println(num+&quot;满足要求&quot;); count++; &#125; &#125; System.out.println(&quot;满足要求的数据一共有&quot;+count+&quot;个&quot;); &#125;&#125; 10.请统计1-1000之间同时满足如下条件的数据有多少个？对3整除余2对5整除余3对7整除余2123456789101112public class ForDemo &#123; public static void main(String[] args) &#123; int count = 0; for(int num=1;num&lt;=1000;num++) &#123; if((num%3 == 2)&amp;&amp;(num%5 == 3)&amp;&amp;(num%7 == 2)) &#123; System.out.println(num+&quot;满足要求&quot;); count++; &#125; &#125; System.out.println(&quot;满足要求的数据一共有&quot;+count+&quot;个&quot;); &#125;&#125; 三、while循环1.while循环语句格式：（1）基本格式：while(判断条件语句) { 循环体语句;}(2)扩展格式:初始化语句;while(判断条件语句) { 循环体语句; 控制条件语句;} 2.练习：把for循环的练习全部用while循环语句写一遍 3.for循环与while循环的区别：（1）控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问了，而while循环结束还可以继续使用，如果你想继续使用，就用while，否则推荐使用for。原因是for循环结束，该变量就从内存消失，能够提高内存的使用效率。（2）for 循环适合针对一个范围判断进行操作。while循环适合判断次数不明确操作。 四、do…while循环1.do…while循环语句格式：（1）基本格式：do { 循环语句体;}while(判断条件语句);(2)扩展格式：初始化语句do { 循环语句体； 控制条件语句；}while(判断条件语句)； 2.do..while比较少用，但效果与前两种循环语句相同。执行流程是先执行一次循环体语句，然后再判断。3.三种循环语句的区别（1）do…while至少执行一次循环体。（2）for，while循环必须先判断条件是否成立，然后决定是否执行循环体语句。案例：1234567891011121314151617public class DoWhileDemo2 &#123; public static void main(String[] args) &#123; for(int x=3;x&lt;3;x++) &#123; System.out.println(&quot;javafor&quot;); &#125; int y = 3; while(y&lt;3) &#123; System.out.println(&quot;javawhile&quot;); &#125; int z = 3; do &#123; System.out.println(&quot;javadowhile&quot;); &#125;while(z&lt;3); &#125;&#125; 4.注意死循环（1）注意控制条件语句控制的那个变量的问题（2）两种最简单的死循环格式： while(true) {…} for(;;) {…} 五、循环嵌套练习题： 请输出一个4行5列的星星(*)图案1234567891011public class ForForDemo &#123; public static void main(String[] args) &#123; for(int x=0;x&lt;4;x++) &#123; for(int y=0;y&lt;5;y++) &#123; System.out.print(&quot; *&quot;); &#125; System.out.println(); &#125; &#125;&#125; 2.输出如下图形*** 自己的想法1234567891011public class ForForDemo &#123; public static void main(String[] args) &#123; for(int x=0;x&lt;5;x++) &#123; for(int y=0;y&lt;x+1;y++) &#123; System.out.print(&quot; *&quot;); &#125; System.out.println(); &#125; &#125;&#125; 视频做法1234567891011public class ForForDemo &#123; public static void main(String[] args) &#123; for(int x=0;x&lt;5;x++) &#123; for(int y=0;y&lt;=x;y++) &#123; System.out.print(&quot; *&quot;); &#125; System.out.println(); &#125; &#125;&#125; 3.在控制台输出九九乘法表自己的想法1234567891011public class ForForDemo &#123; public static void main(String[] args) &#123; for(int x=0;x&lt;9;x++) &#123; for(int y=0;y&lt;x+1;y++) &#123; System.out.print(&quot; &quot;+(x+1)+&quot;*&quot;+(y+1)+&quot;=&quot;+((x+1)*(y+1))); &#125; System.out.println(); &#125; &#125;&#125; 视频做法1234567891011public class ForForDemo &#123; public static void main(String[] args) &#123; for(int x=1;x&lt;=9;x++) &#123; for(int y=1;y&lt;=x;y++) &#123; System.out.print(x+&quot;*&quot;+y+&quot;=&quot;+x*y+&quot;\t&quot;); &#125; System.out.println(); &#125; &#125;&#125; 注意：‘\x’ x表示任意，这种做法叫转义字符‘\t’ tab键‘\r’ 回车‘\n’ 换行在输出语句中使用单引号，双引号都可以。 六、跳转控制语句1.前言：Java中的goto是保留字，目前不能使用。虽然没有goto语句可以增强程序的安全性，但是也带来很多不便，比如说，我想在某个循环知道到某一步的时候就结束，现在就做不了这个事情。为了弥补这个缺陷，Java就提供了break,continue和return来实现控制语句的跳转和中断。break 中断continue 继续return 返回 2.跳转控制语句break(1)break的使用场景 在选择结构switch语句中 在循环语句中 离开使用场景的存在是没有意义的(2)如何使用a.跳出单层循环1234567891011public class BreakDemo &#123; public static void main(String[] args) &#123; //跳出单层循环 for(int x=0;x&lt;10;x++) &#123; if(x == 3) &#123; break; &#125; System.out.println(&quot;hello world&quot;); &#125; &#125;&#125; b.跳出多层循环要想实现这个效果，就必须知道一个东西，带标签的语句。格式： 标签名:语句 1234567891011121314public class BreakDemo &#123; public static void main(String[] args) &#123; //跳出多层循环 wc:for(int x=0;x&lt;3;x++) &#123; nc:for(int y=0;y&lt;4;y++) &#123; if(y == 2) &#123; break wc; &#125; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; &#125;&#125; 3.跳转控制语句continue（1）使用场景a.在循环语句中b.离开使用场景的存在是没有意义的（2）continue的作用a.单层循环对比break，两个的区别是：break 退出当前循环continue 退出本次循环 练习：123456for(int x=1;x&lt;=10;x++) &#123; if(x%3==0) &#123; //此处填写代码 &#125; System.out.println(&quot;Java基础班&quot;);&#125; 我想在控制台输出2次：“Java基础班”1break; 我想在控制台输出7次：“Java基础班”1continue; 我想在控制台输出13次：“Java基础班”1System.out.println(&quot;Java基础班&quot;); 也可以带标签的使用：1234567891011121314public class BreakDemo &#123; public static void main(String[] args) &#123; //跳出多层循环 wc:for(int x=0;x&lt;3;x++) &#123; nc:for(int y=0;y&lt;4;y++) &#123; if(y == 2) &#123; continue wc; &#125; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; &#125;&#125; 结果：**分析：1continue表示退出本次循环，所以continue wc;表示的是退出wc的本次（x=0）的循环，并不是退出整个wc的循环，接下来会进行下次(x=1)循环，所以结果为**（x=0）**(x=1)**(x=2) 4.跳转控制语句return return的功能就是结束一个方法，跳转到上一层的方法中，这个在方法的使用中会详细讲解。案例:123456789101112131415public class BreakDemo &#123; public static void main(String[] args) &#123; for(int x=0;x&lt;10;x++) &#123; if(x == 2) &#123; System.out.println(&quot;退出&quot;); 填写代码处 //break; //continue; //return; &#125; System.out.println(x); &#125; System.out.println(&quot;over&quot;); &#125;&#125; 填写break：123401退出over 填写continue:123456789101101退出3456789over 填写return:12301退出 练习：小芳的妈妈每天给她2.5元，她都会存起来，但是，每当这一天是存钱的第5天或者是5的倍数的话，她都会花去6元，请问经过多少天，小芳才能存够100元？无break；做法12345678910111213141516public class WhileBreakTest &#123; public static void main(String[] args) &#123; int day = 0; double sum = 0; while(sum&lt;100.0) &#123; day++; sum+=2.5; if(day%5 == 0) &#123; System.out.println(&quot;小芳在第&quot;+day+&quot;天花了6元&quot;); sum-=6; &#125; System.out.println(&quot;经过&quot;+day+&quot;天，存有&quot;+sum+&quot;元&quot;); &#125; System.out.println(&quot;经过&quot;+day+&quot;天，小芳能存够100元&quot;); &#125;&#125; 使用break;做法12345678910111213141516171819public class WhileBreakTest &#123; public static void main(String[] args) &#123; int day = 0; double sum = 0; while(true) &#123; day++; sum+=2.5; if(day%5 == 0) &#123; System.out.println(&quot;小芳在第&quot;+day+&quot;天花了6元&quot;); sum-=6; &#125; System.out.println(&quot;经过&quot;+day+&quot;天，存有&quot;+sum+&quot;元&quot;); if(sum&gt;=100) &#123; break; &#125; &#125; System.out.println(&quot;经过&quot;+day+&quot;天，小芳能存够100元&quot;); &#125;&#125;]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday03]]></title>
    <url>%2F2019%2F07%2F06%2Fjavaday03%2F</url>
    <content type="text"><![CDATA[一、运算符1.运算符就是对常量和变量进行操作的符号。2.分类（1）算术运算符+、-、*、/、%、++、–(自增和自减只能用于变量)++、–单独使用时，放在操作数的前面和后面效果一样。（常见用法）参与运算使用，放在操作数前面，先自增或自减，再参与运算；放在操作数后面，先参与运算，再自增或自减。 ++、–的练习题第一题：int a = 10；int b = 10;int c = 10; a = b++;c = --a;b = ++a;a = c--;请分别计算出a,b,c的值。1234a = b++; //a=10 b=11 c=10c = --a; //a=9 b=11 c=9b = ++a; //a=10 b=10 c=9a = c--; //a=9 b=10 c=8 第二题：int x = 4；int y = (x++)+(++x)+(x*10);请分别计算出x,y的值12345(x++) //x=5 (x++)=4(++x) //x=6 (++x)=6(x*10) //x=6 (x*10)=60y=4+6+60=70所以x=6,y=70 （2）赋值运算符=、+=、-=、*=、/=、%= += 把左边和右边做加法，然后赋值给左边。*=/=%= 面试题：short s = 1, s = s+1;short s = 1, s+=1;上面两个代码有没有问题，如果有，哪里有问题？12345short s = 1,s = s+1;有问题s是short类型，进行计算时先转为int类型后参与计算，所以+1后结果是int类型，赋值给short类型的s可能损失精度。short s = 1,s+=1;没问题因为扩展的赋值运算符隐含了一个强制类型转换。s+=1;等价于s = (s的数据类型)（s+1）; （3）比较运算符(关系运算符)==、！=、&gt;、&gt;=、&lt;、&lt;= （4）逻辑运算符&amp;、|、^、!、&amp;&amp;、||特点：逻辑运算符一般用于连接boolean类型的表达式或值.结论：&amp;：有false则false|：有true则true^：相同为false，不同为true!：非false则true，非true则false。偶数个!不改变结果（!!true=true）&amp;&amp;：结果与&amp;相同。不同在于&amp;&amp;左边是false的话，右边不执行。看以下案例。123456789101112int x = 3;int y = 4;boolean b1 = (++x == 3 &amp; y++ == 4);System.out.println(&quot;x:&quot;+x+&quot;y:&quot;+y);System.out.println(b1);int x = 3;int x = 4;boolean b2 = (++x == 3 &amp;&amp; y++ == 4);System.out.println(&quot;x:&quot;+x+&quot;y:&quot;+y);System.out.println(b1); ||：结果与|相同。不同在于||左边是true的话，右边不执行。（5）位运算符注意：要做位运算，首先要把数据转换为二进制，并且是补码。&amp;、|、^、~（两边是boolean类型，做逻辑运算；两边是数据时，做位运算。3 &amp; 4做位运算）案例：System.out.println(3 &amp; 4);System.out.println(3 | 4);System.out.println(3 ^ 4);System.out.println(~3);123456789101112131415161718192021222324252627282930分析过程：3的二进制：11常量3的存储结构：00000000 00000000 00000000 000000114的二进制：100常量4的存储结构：00000000 00000000 00000000 00000100&amp;位运算：有0则000000000 00000000 00000000 00000011&amp;00000000 00000000 00000000 00000100-----------------------------------00000000 00000000 00000000 00000000结果：0|位运算：有1则100000000 00000000 00000000 00000011|00000000 00000000 00000000 00000100-----------------------------------00000000 00000000 00000000 00000111结果：7^位运算：相同则0.不同则100000000 00000000 00000000 00000011^00000000 00000000 00000000 00000100-----------------------------------00000000 00000000 00000000 00000111结果：7~运算符：0变1，1变0~00000000 00000000 00000000 00000011-----------------------------------11111111 11111111 11111111 11111100(补)11111111 11111111 11111111 11111011(反)10000000 00000000 00000000 00000100(原)结果：-4 一个数据位异或(^)两次，该数本身不变。 面试题：1.请自己实现两个整数变量的交换。1234567891011121314151617181920212223int a = 10;int b = 20;System.out.prinyln(&quot;a:&quot;+a+&quot;,b:&quot;+b);//方式1:使用第三方变量（开发中用的）int c = a;a = b;b = c;System.out.prinyln(&quot;a:&quot;+a+&quot;,b:&quot;+b);//方式2:用位异或实现//左边：a,b,a//右边：a ^ ba = a ^ b;b = a ^ b;a = a ^ b;System.out.prinyln(&quot;a:&quot;+a+&quot;,b:&quot;+b);//方式3:用变量相加的方法a = a + b;b = a - b;a = a - b;System.out.prinyln(&quot;a:&quot;+a+&quot;,b:&quot;+b);//方式4:一句话搞定b = (a+b)-(a=b);System.out.prinyln(&quot;a:&quot;+a+&quot;,b:&quot;+b); &lt;&lt;(左移)、&gt;&gt;(右移)、&gt;&gt;&gt;(无符号右移)&lt;&lt;：左边最高位丢弃，右边补齐0. 把&lt;&lt;左边的数据*2的移动次幂 ：最高位是0，左边补0；最高位是1，左边补齐1 ：无论最高位是0或1，左边都是补齐0案例：System.out.println(3 &lt;&lt; 2);1234计算3的二进制：1100000000 00000000 00000000 00000011&lt;&lt;00000000 00000000 00000000 00001100结果：12 System.out.prinyln(24 &gt;&gt; 2); //6System.out.prinyln(24 &gt;&gt;&gt; 2); //6System.out.prinyln(-24 &gt;&gt; 2); //-6System.out.prinyln(-24 &gt;&gt;&gt; 2); //1073741818123456计算-24的二进制：1100010000000 00000000 00000000 00011000（原）11111111 11111111 11111111 11100111（反）11111111 11111111 11111111 11101000（补）&gt;&gt;&gt;00111111 11111111 11111111 11111010 (原、反、补)结果：1073741818 面试题：请用最有效率的方式写出计算2乘8的结果？12 &lt;&lt; 3 //2*2^3=16 （6）三目运算符(条件运算符)格式：表达式？表达式1:表达式2;举例：int x = 100;int y = 200;int z = x &lt; y?x:y;System.out.println(“z:”+z);练习：1.获取两个整数中的最大值。1234int x = 100;int y = 200;int max = (x&gt;y? x:y);System.out.println(&quot;max:&quot;+max); 2.获取三个整数中的最大值.12345int a = 10;int b = 30;int c = 20;int max = (a&gt;b?a:b)&gt;c?(a&gt;b?a:b):c;System.out.println(&quot;max:&quot;+max); 3.比较两个整数是否相同1234int m = 100;int n = 200;boolean flag = (m==n)?true:flase;System.out.println(boolean); 二、键盘录入1.如何实现键盘录入？（1）导包格式：import java.util.Scanner;位置：在class上面（2）创建键盘录入对象格式：Scanner sc = new Scanner(System.in);（3）通过对象获取数据格式：int x =sc.nextInt(); 练习：1.键盘录入两个数据，并对这两个数据求和，输出其结果。2.键盘录入两个数据，获取这两个数据的最大值。3.键盘录入三个数据，获取这三个数据的最大值。4.键盘录入两个数据，比较这两个数据是否相等。 三、if语句1.前言：在一个程序执行的过程中，各条语句的执行顺序对程序的结果有直接影响。所以，我们必须清楚每条语句的执行流程。而且，很多时候我们要通过控制语句的执行顺序来实现我们要完成的功能。流程控制语句分类：顺序结构，选择结构，循环结构。java语言提供了两种选择结构语句：if语句和switch语句if 语句有三种格式：if 语句的第一种格式：if（关系表达式）{语句体；}if语句的第二种格式：if(关系表达式) {语句体1；} else {语句体2；}格式2练习：1.获取两个数据中较大的值2.判断一个数是奇数还是偶数if语句第二种格式和三元运算符的区别？(根据案例解释)三元运算符实现的，都可以采用if语句实现。反之不成立。结果是输出语句无法用三元运算符实现。123456789101112131415//获取两个数据中的较大值int a = 10;int b = 20;//if语句实现int max1;if(a&gt;b) &#123;max1 = a;&#125;else &#123;max1 = b;&#125;System.out.println(&quot;max1:&quot;+max1);//三目运算符实现int max2 = (a&gt;b)?a:b;System.out.println(&quot;max2:&quot;+max2); 12345678910//判断一个数据是奇数还是偶数，并输出是奇数还是偶数int x = 100;//if语句实现if(x%2 == 0) &#123;System.out.println(&quot;100是一个偶数&quot;)&#125;else &#123;System.out.println(&quot;100是一个奇数&quot;)&#125;//三目运算符实现实现不了 if语句的第三种格式：if(关系表达式1) {语句体1；}else if(关系表达式2) {语句体2；}…else {语句体n+1;}案例：键盘录入一个成绩，判断并输出成绩的等级。（注意考虑正常数据，错误数据，边界数据。比如分数有0，100，但是没有-100） if语句练习：1.键盘录入x的值，计算出y的值并输出，y满足：x&gt;=3 y=2x+1;x-1 y=2x;x&lt;=-1 y=2x-1;2.键盘录入月份的值，输出对应的季节。3.获取三个数据中的最大值（讲解if语句的嵌套）]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday02]]></title>
    <url>%2F2019%2F07%2F05%2Fjavaday02%2F</url>
    <content type="text"><![CDATA[一、关键字1.被java语言赋于特殊含义的单词。 二、标识符1.给类、接口、方法、变量起名字的字符序列。2.组成规则：（1）数字（2）英文大小写字母（3）$和_ 3.注意事项：（1）不能以数字开头（2）区分大小写（3）不能是关键字 4.常见的命名规则（1）包：单级包：小写 //cn多级包：小写，使用点连接 //cn.itcast（2）类和接口：1个单词：首字母大写 //Student多个单词：每个单词的首字母大写 //StudentClass（3）方法和变量1个单词：小写 //main多个单词：从第2个单词开始，首字母大写 //getNumber（4）常量：1个单词：全部大写 //PI多个单词：大写，用下划线_隔开 //FIRE_TEACHER 三、注释1.对程序进行解释说明的文字2.分类：（1）单行注释//（2）多行注释/ \/（3）文档注释/* \/ 四、常量1.在程序执行过程中其值不发生改变的量。2.分类：（1）字面值常量（2）自定义常量 3.字面值常量（1）整数常量 12（2）小数常量 12.34（3）字符串常量 “hello”（3）字符常量 ‘a’（5）布尔常量 true,flase（6）空常量null 4.java中针对整数常量提供了四种表现形式：二进制、八进制、十进制、十六进制。（整数默认十进制）五、进制转换1.其他进制到十进制系数：就是每一位上的数值基数：X进制的基数就是X。权：对每一位上的数据进行编号，从右，并且从0开始编号，对应的编号就是该数据的权。结果：系数*基数^权次幂之和。 2.十进制到其他进制除基取余，直到商为零，余数反转。 3.进制转换的快速转换法（1）十进制与二进制之间的转换8421码（2）二进制到八进制、十六进制的转换 4.小数部分二进制与十进制转换（1）十进制转二进制小数部分乘2，取结果的整数部分，之后将结果的小数部分乘2，取结果的的整数部分，以此类推，直到结果为0或一直循环为止。（2）二进制转十进制小数部分从左往右，依次乘1/2，1/4，1/8…，求和。 六、变量1.在程序的执行过程中，其值在某个范围内可以发生改变的量。2.变量的定义格式：（1）变量的定义格式：A：数据类型 变量名 = 初始化值；B：数据类型 变量名；变量名 = 初始化值； 七、数据类型1.java是一种强类型语言，针对每种数据都提供了对应的数据类型。2.分类：（1）基本数据类型：4类8种（2）引用数据类型：类，接口，数组 3.基本数据类型：（1）整数 占用字节数byte 1short 2int 4long 8（2）浮点数float 4double 8（3）布尔char 1（4）字符boolean 2注意： 整数默认int类型，浮点数默认double类型。 长整数要加l或L，单精度的浮点数要加F或f。 八、数据类型转换1.默认转换从小到大byte，short，char-int-long-float-doublebyte，short，char之间不相互转换，直接转成int类型参与计算。 2.强制转换从大到小可能会有精度损失，一般不建议这样使用。格式：目标数据类型 变量名 = （目标数据类型）（被转换的数据）； 3.布尔类型不参与转换4.思考题和面试题（1）下面两种方式有区别吗？float f1 = 12.345f；float f2 = （float）12.345；//f1是通过double转换过来的，f2本身就是float类型。（2）面试题：1.byte b1=3,b2=4,b;b=b1+b2;b=3+4;哪句是编译失败的呢？为什么呢？12345b=b1+b2编译失败。b1是byte类型，b2是byte类型。两个byte类型相加，先转换成int类型再相加，所以结果是int类型。b是byte类型，把int类型的结果赋值给byte类型的b，可能损失精度，所以报错。变量计算时，会先考虑数据类型再进行计算。 12b=3+4编译成功。因为3、4是常量，常量计算时，先把结果计算出来，然后看是否是在赋值的数据类型（byte）的范围内，如果在就不报错。 2.byte b = 130;有没有问题？如果我想让赋值正确，可以怎么做？结果是多少呢？12345678910111213有问题，可能损失精度。因为byte的范围是-128～127。130不在此范围内，所以报错。如果想让赋值正确（不报错），可以使用强制转换byte b = (byte) (130);结果是-126分析过程：获取130这个数据的二进制。130是整数常量，整数常量默认为int类型，占用4个字节。00000000 00000000 00000000 10000010这是130的原码，也是反码，还是补码。因为强制转换成byte类型（1个字节），所以对130的补码进行截取操作，从左边开始：补：10000010反：10000001原：11111110此原码对应的数值是-126. 练习：byte b = 300;12345678910111213有问题，可能损失精度。因为byte的范围是-128～127，300不在这个范围内，所以报错。如果想让赋值正确（不报错），可以使用强制转换byte b = （byte）(300);结果是分析过程：获取300的二进制。整数常量默认为int类型，占用4个字节。00000000 00000000 00000001 00101100这是300的原码，反码，补码因为强制转换成byte类型（1个字节），所以进行截取操作，从左边开始：补：00101100反：00101100原：00101100此原码对应的数值是44。正数的原反补都相同！！！！ 3.看程序写结果：System.out.println(‘a’);1a System.out.println(‘a’+1);123498&apos;a&apos; 97&apos;A&apos; 65&apos;0&apos; 48 System.out.println(“hello”+’a’+1);12helloa1字符串数据和其他数据做+，结果是字符串类型。 System.out.println(‘a’+1+”hello”);198hello System.out.println(“5+5=”+5+5);15+5=55 System.out.println(5+5+”=5+5”);110=5+5 4.17.625在float类型中是如何存储的？写出过程。（1）整数部分转为二进制（2）小数部分转为二进制（3）移动小数点找到底数和指数，指数加上127底数：因为小数点前必为1，所以IEEE规定只记录小数点后的就好，所以，此时的底数为0001101.指数：实际为4，必须加上127，所以为131，也就是10000011.（4）在float4个字节中的存储顺序为：符号部分+指数部分+底数部分+后面补0结果：01000001 10001101 00000000 000000005.Java语言中的字符char可以存储一个中文汉字吗？为什么？可以。因为Java语言中的字符占用两个字节。 PS：Java语言采用的是Unicode编码。]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年6月考核]]></title>
    <url>%2F2019%2F05%2F28%2F2019%E5%B9%B46%E6%9C%88%E8%80%83%E6%A0%B8%2F</url>
    <content type="text"><![CDATA[第一周（0527-0602）0527 周一 科研 工作 回顾统计学基础； 环境 实验室拍照；贫困认定； 其它 每日饮食完成； 状态 正常饮食，不聚餐第1天；一次只养成一个习惯，现在先养成正常饮食不聚餐的习惯； 0528 周二 科研 简单看了两篇论文； 工作 回顾了一点点统计学基础； 环境 贫困认定完成；宿舍分配完成；值班安排大部分搞定，明天小修改一下； 其它 每日饮食完成50%，晚上学工组加班，饮食不太妥当，但是没有腐败聚会，所以还好； 状态 感觉自己确实不聪明，复习一点点统计学基础就花了一下午，所以还是要踏踏实实多花时间去学习； 0529 周三 科研 看论文&lt;1； 工作 环境 端午节值班表； 其它 无效率休息半天；校篮球赛工程vs机电，机电7号和0号不错，虽然最后还是工程赢了； 状态 效率低。 0530 周四 科研 组会； 工作 环境 三全育人研讨会；第十三次学工组例会记录； 其它 状态 今天比较充实，但全是环境的事情。还是要抓紧时间做自己的事，加油； 0531 周五 科研 工作 环境 开会；排版 其它 状态 0601 周六 科研 不到半篇英文文献； 工作 环境 排版 其它 南门烧烤； 状态 0602 周日 科研 开题报告（除现状与技术路线） 工作 环境 就业信息统计； 其它 安装好虚拟机；帮天予也装了虚拟机；ted（我们所做的一切是为了什么）（负面情绪是心智在提醒我们它渴望成熟） 状态 本周总结： 优点：没闲着；逐渐变得理性；看TED； 缺点：科研与工作内容少；作息饮食不规律； 最开心的事：猛龙总决赛第1场赢了； 第二周（0603-0609）0603 周一 科研 技术路线；研究现状； 工作 环境 其它 状态 没什么问题，就是做的事太少，时间浪费太多； 0604 周二 科研 技术路线；研究现状； 工作 环境 值班；通讯稿； 其它 状态 被恋爱冲昏头脑，需要冷静一下； 0605 周三 科研 工作 环境 毕业照；排查；党支部风采大赛；整理照片 其它 状态 不可避免的效率低；尽快把这些事都做好吧； 0606 周四 科研 工作 环境 教职工大会； 其它 和sjx吃饭； 状态 开心 0607 周五 科研 找老师看开题报告； 工作 环境 其它 老友记； 状态 0608 周六 科研 工作 环境 其它 老友记； 状态 0609 周日 科研 工作 环境 其它 王老菊视频； 状态 本周总结： 优点： 缺点： 最开心的事： 第三周（0610-0616）0610 周一 科研 工作 环境 其它 状态 0611 周二 科研 工作 环境 其它 状态 0612 周三 科研 工作 环境 其它 状态 0613 周四 科研 工作 环境 其它 状态 0614 周五 科研 工作 环境 其它 状态 0615 周六 科研 工作 环境 其它 状态 0616 周日 科研 工作 环境 其它 状态 本周总结： 优点： 缺点： 最开心的事： 第四周（0617-0623）0617 周一 科研 工作 环境 其它 状态 0618 周二 科研 工作 环境 其它 状态 0619 周三 科研 工作 环境 其它 状态 0620 周四 科研 工作 环境 其它 状态 0621 周五 科研 开题ppt； 工作 环境 核对金额； 其它 买了泰拉瑞亚； 状态 这两周有点堕落，要开始改正！ 0622 周六 科研 工作 环境 其它 状态 0623 周日 科研 工作 环境 其它 状态 本周总结： 优点： 缺点： 最开心的事： 第五周（0624-0630）0624 周一 科研 工作 环境 其它 状态 0625 周二 科研 工作 环境 其它 状态 0626 周三 科研 工作 环境 其它 状态 0627 周四 科研 工作 环境 其它 状态 0628 周五 科研 工作 环境 其它 状态 0629 周六 科研 工作 环境 其它 状态 0630 周日 科研 工作 环境 其它 状态 本周总结： 优点： 缺点： 最开心的事： 六月总结：]]></content>
      <categories>
        <category>自律即自由</category>
      </categories>
      <tags>
        <tag>2019</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据的统计学基础第5周笔记]]></title>
    <url>%2F2019%2F05%2F11%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%AC%AC5%E5%91%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[0190511:]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>统计学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据的统计学基础第4周笔记]]></title>
    <url>%2F2019%2F05%2F11%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%AC%AC4%E5%91%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[0190511:]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>统计学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据的统计学基础第3周笔记]]></title>
    <url>%2F2019%2F05%2F10%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%AC%AC3%E5%91%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[0190510:]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>统计学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据的统计学基础第2周笔记]]></title>
    <url>%2F2019%2F05%2F10%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%AC%AC2%E5%91%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[20190510:]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>统计学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据的统计学基础第1周笔记]]></title>
    <url>%2F2019%2F05%2F08%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%AC%AC1%E5%91%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[20190508:]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>统计学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git基础教程]]></title>
    <url>%2F2019%2F05%2F05%2FGit%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Git 简易实用教程 for Mac1.git安装git官网下载后傻瓜式安装，安装完毕后打开终端输入“git”，回车，输出一大段介绍并且没有报错，说明安装成功 2.建立第一个版本库Repository打开终端， cd ~/desktop/jetzilch #jetzilch文件夹应当已经存在。 git config -global user.name”jetzilch” #设置用户名 git config -global user.email”**@qq.com” #设置用户email git init #在jetzlich文件夹中生成.git隐藏文件夹，在文件夹中使用“command+shift+.”显示隐藏文件夹 ls -a #在终端中输入此命令显示所在文件夹中的所有文件（包括隐藏文件） touch 1.py #新建1.py文件 git status #显示“untracked files”，此时的1.py文件没有被放入版本库（unstaged） git add 1.py #git add . ##把所有内容放入版本库 git status #显示“changes to be committed”,此时1.py已经放入版本库（staged） git commit -m “create 1.py” #commit表示提交这一次“修改”，提交的是修改而不是文件。 3.记录修改log&amp;diffgit log #显示之前所有commit的修改信息 我们对1.py文件进行修改： ··· a = 1 ··· git status #显示“modified”，此时修改的内容还没有被add和commit git add 1.py git commit -m “change 1” git log 我们对1.py文件进行修改： ··· a = 2 b = 1 ··· git diff #查看修改完后但未add的内容与上次commit后的内容的对比（查看staged） git diff —cached #修改完后add完成与上次commit后的内容的对比（查看unstaged） git diff HEAD #查看staged与unstaged git add . git commit -m “change 2” 4.回到从前reset4.1 修改已commit的版本 刚刚我们已经提交了一个commit（change 2），现在我们要添加另一个文件2.py，讲这个修改也commit进change 2 touch 2.py #这里只是新建了2.py文件，为了下面步骤的进行，需手动把1.py内的内容复制到2.py中，此处不再赘述 git add 2.py git commit —amend —no-edit #”—no-edit”:不编辑，直接合并到上一个commit git log —oneline #”—oneline”:每个commit内容显示在一行 4.2 reset到add之前 对1.py进行修改： ··· d = 3 ··· #add到staged再返回到add之前 git add 1.py git status -s #”-s”:缩写status的显示内容 git rest 1.py git status -s 4.3 reset到commit之前 git reset —hard HEAD #不管我们之前有没有做了一些add工作，这一步都会让我们回到最近的commit，在这个案例里是change 2 git log —oneline #回到change 1（两种方法） #方法1 git reset —hard HEAD^ #方法2 git reset —hard 9881585(change 1的id) git log —oneline #上述方式会导致change 2消失，想要恢复消失的change 2，可以使用reflog git reflog #显示最近HEAD的所有改动 #重复reset步骤就能回到change 2 git reset —hard 3faa921 5.回到从前（checkout针对单个文件）git log —oneline git checkout 9881585 — 1.py #将1.py文件恢复到change 1的状态（9881585为change 1的id） #此时的1.py里只有change 1的内容（a = 1），我们在1.py加上一行内容“# I went back to change 1”，然后add，commit 1.py git add 1.py git commit -m “back to change 1 and add commit for 1.py” git log —oneline 6.分支（branch）6.1 使用branch创建dev分支 git log —oneline —graph #观看分支，即log的最左边会显示*路线 git branch dev #创建dev分支 git branch #查看当前分支，*显示的是当前所在的分支 git checkout dev #切换到dev分支 git branch 创建和切换到新建的分支可以合成一步：git checkout -b dev git branch -d dev #删除dev分支 6.2 将dev的修改推送到master git commit -am “change 3 in dev” #”-am”:add所有改变并直接commit git checkout master #切换到master分支 git merge dev #将dev merge到master git log —oneline —graph 上述merge方式在log中不会有分支图案，可以采取—no-f保留 git merge —no-f -m”keep merge info” dev #保留merge信息 git log —oneline —graph 7.分支冲突merge在不同分支进行编辑，然后mege，系统会提示冲突，并在文件中把冲突的地方标示出来，在文件中修改后，再提交保存就行。 8.分支冲突rebase按照莫烦git里的讲解，有空再补充。 9.临时修改stash有空补充 10.github在线代码管理有空补充]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年5月考核]]></title>
    <url>%2F2019%2F05%2F04%2F2019%E5%B9%B45%E6%9C%88%E8%80%83%E6%A0%B8%2F</url>
    <content type="text"><![CDATA[第一周（0429-0505）0429 周一 科研 读博 环境 其它 和P同学聊到快两点。 状态 0430 周二 科研 读博 环境 其它 状态 0501 周三 科研 读博 环境 其它 状态 0502 周四 科研 读博 环境 其它 状态 0503 周五 科研 读博 环境 其它 状态 0504 周六 科研 修改论文； 读博 图书馆8:00～9:30 环境 其它 晚餐（牛排、西红柿、黄瓜、面包、黄桃罐头）；午睡；和奶奶、妈妈视频； 状态 相对充实的一天，晚上改论文时确实受到影响了，以后尽量去图书馆学习。 0505 周日 科研 看了一点点粗糙度相关论文； 工作 tensorflow的简单示例（梯度下降法训练出一条直线）； 环境 五四100周年学习体会收集；篮球赛； 其它 帮勇哥解决论文发表图的问题；外国人拿一包鸡精找我问哪有“猪精”？有点迷 三餐 地瓜粥、鸡蛋；牛排、西红柿、黄瓜、面包；火腿、西红柿、黄瓜、面包 状态 状态不错（睡眠、饮食做得好），但是事情多，特别是琐事…… 本周总结： 优点：饮食、睡眠调整效果初见成效；图书馆学习时间增加； 缺点：效率低下；注意力与时间分散于太多现阶段无关紧要的部分； 最开心的事：和P同学聊到快两点。 第二周（0506-0512）0506 周一 科研 确定渗流实验变量、实验结果量、中间量；确定JRC值的计算步骤 工作 理解hypothesis function（假设函数h），parameters（模型参数theta），cost function（代价函数），linear regression（线性回归）； 环境 整理中加秘书招聘报名表；篮球赛； 其它 帮Luo看论文；帮勇哥画图； 状态 开心 理解了cost function。 0507 周二 科研 工作 尝试讲解univariate linear regression;学习multivariate linear regression; 环境 例会；会议记录；邀请函； 其它 安装matlab for mac； 状态 在图书馆效率还不错，明天继续保持； 开心 被大家需要； 0508 周三 科研 实验方案撰写； 工作 大数据的统计学基础第1周，整理至Hexo； 环境 中加秘书招聘信息整理进行中； 其它 俭朴菜37；找完简历模版；学会origin合并两图的方法；玩台球游戏被涛子打得头皮发麻； 状态 0509 周四 科研 工作 环境 中加秘书招聘信息整理进行中；五四100周年讲话学习拍摄；篮球赛；学工组聚餐 其它 状态 很充实，忙与开心并存，希望接下来每天也能和今天一样。 开心 今天环境篮球赛赢了，很开心。 0510 周五 科研 裂隙特征实验方案撰写完毕； 工作 大数据的统计学基础第2周，整理至Hexo；大数据的统计学基础第3周，整理至Hexo； 环境 中加秘书信息整理完毕；五四讲话照片整理完毕； 其它 0.5h乒乓球； 状态 今天效率还不错，明天继续努力； 0511 周六 科研 找岩石类期刊； 工作 大数据的统计学基础第4周，整理至Hexo;大数据的统计学第5周进行中；实习生双选会； 环境 其它 和奶奶视频；给妈妈买礼物（妈妈自己挑的礼物，难得） 状态 今天学习状态不错，后程又开始囫囵吞枣，切忌；睡前洗漱习惯接近养成，证明仍具有一定可塑性，要保持自信，争取在其他领域也养成好习惯。 0512 周日 科研 工作 环境 其它 161聚餐； 状态 荒废了一天，并没有得到有效的休息；玩游戏还是会上瘾，不能玩； 开心 161聚餐； 本周总结： 优点：重点回到工作上；洗漱习惯接近养成； 缺点：学习稍有囫囵吞枣之嫌；科研方面仍需加强；玩游戏会上瘾，还是少玩的好。饮食不太健康。 最开心的事：环境篮球赛取得胜利； 第三周（0513-0519）0513 周一 科研 实验方案修改； 工作 理解什么叫随机变量 环境 找北交大附近住处；上传通讯稿；工作小组通知； 其它 涛子生日快乐； 状态 今天发生了件比较影响三观的事，以后还是做个众人，把我想表现的那一面展现在行动上。 0514 周二 科研 实验方案修改； 工作 概率论浙大四版习题； 环境 中加秘书发邮件；工作领导小组通知； 其它 状态 最近台球游戏玩得有点多，得控制一下； 0515 周三 科研 工作 环境 其它 状态 0516 周四 科研 工作 环境 其它 状态 0517 周五 科研 工作 环境 其它 状态 0518 周六 科研 看师兄答辩；修改试验方案； 工作 环境 其它 超哥请吃老四川； 状态 无所事事的一天，不太好。要记住：我们创造习惯，习惯反过来成就我们。 0519 周日 科研 开题报告修改； 工作 环境 德育会议； 其它 海底捞；师兄请小惰； 状态 师兄毕业很开心，今天小惰超哥有点抢镜啊，哈哈哈哈 本周总结： 优点：科研有所保持； 缺点：玩得太多，正经事做得有点少，重心依旧优点趋向于环境； 最开心的事：师兄毕业； 第四周（0520-0526）0520 周一 科研 工作 环境 其它 状态 0521 周二 科研 工作 环境 其它 状态 0522 周三 科研 工作 环境 其它 状态 0523 周四 科研 工作 环境 其它 状态 0524 周五 科研 工作 环境 其它 状态 0525 周六 科研 工作 环境 其它 状态 0526 周日 科研 明确毕业论文三部分内容：粗糙度，渗流传热，神经网络参数敏感性分析； 工作 环境 其它 鸡胸肉切细片，料酒腌一下，下油炒一下，少许盐，还挺和我胃口的； 状态 感觉毕业有难度，工作方面进展也慢，有点小压力； 本周总结： 优点： 缺点：各方面好像都没做好； 最开心的事：刘总给师兄的送别宴 五月总结： 整个五月有14天没有记录，刚好是一半。有点颓废，不过今天开始恢复了，晚饭自己做了，晚上也没有去聚餐；毕业和工作的压力有点大，要扛住这个压力，然后顺利完成这两个工作。]]></content>
      <categories>
        <category>自律即自由</category>
      </categories>
      <tags>
        <tag>2019</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫烦Matplotlib笔记]]></title>
    <url>%2F2019%2F04%2F21%2F%E8%8E%AB%E7%83%A6Matplotlib%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、基本用法12345678import matplotlib.pyplot as pltimport numpyx = np.linspace(-1,1,50) #linespace:将-1到1区间均分成50个数，返回这个数组y = 2*x+1plt.plot(x,y)plt.show() 二、figure使用123456789101112131415import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-3,3,50)y1 = 2*x+1y2 = x**2plt.figure(num=5,figsize=(8,3))plt.plot(x,y1)plt.figure()plt.plot(x,y2)plt.plot(x,y1,color=&apos;red&apos;,linewidth=10.0,linestyle= &apos;--&apos;)plt.show() 三、坐标轴设置123456789101112131415161718192021222324import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-2,2,50)y1 = x+1y2 = x**2plt.figure()plt.plot(x,y1)plt.plot(x,y2)plt.xlim((-1,3))plt.ylim((0,5))plt.xlabel(&quot;cycle&quot;)plt.ylabel(&quot;UCS&quot;)new_ticks = np.linspace(-1,2,5)print(new_ticks)plt.xticks(new_ticks)plt.yticks([4,3,2,1],[&apos;$really\ good$&apos;,&apos;$good$&apos;,&apos;$normal$&apos;,r&apos;$\alpha$&apos;])plt.show() 四、坐标轴设置212345678910111213141516171819202122232425262728293031import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-1,5,60)y1 = x**2-xy2 = x**2plt.figure()plt.plot(x,y1,color=&apos;red&apos;,linewidth=2.0,linestyle=&apos;--&apos;)plt.plot(x,y2,color=&apos;blue&apos;,linewidth=2.0,linestyle=&apos;-.&apos;)plt.xlim((-1,5))plt.ylim((-1,25))plt.xlabel(&apos;iamx&apos;)plt.ylabel(&apos;iamy&apos;)new_ticks = np.linspace(-1,5,7)plt.xticks(new_ticks)# gca = &apos;get current axis&apos;ax = plt.gca()ax.spines[&apos;right&apos;].set_color(&apos;none&apos;)ax.spines[&apos;top&apos;].set_color(&apos;none&apos;)ax.xaxis.set_ticks_position(&apos;bottom&apos;)ax.yaxis.set_ticks_position(&apos;left&apos;)ax.spines[&apos;bottom&apos;].set_position((&apos;data&apos;,0))ax.spines[&apos;left&apos;].set_position((&apos;data&apos;,0))plt.show() 五、legend 图例1234567891011121314151617181920212223242526# 导入需要用到的程序包import matplotlib.pyplot as pltimport numpy as np# 获得x，y函数值x = np.linspace(-80,80,100)y = x/16# 设定图片大小，画出图像、图例plt.figure(num=1,figsize=(7,5))l, = plt.plot(x,y,color=&apos;blue&apos;,linewidth=2.0,linestyle=&apos;-.&apos;,label=&apos;CJ&apos;)plt.legend(handles=[l,],labels=[&apos;aaa&apos;],loc=&apos;best&apos;)# x,y坐标轴刻度、轴名设置,还有刻度划分plt.xlim((-80,80))plt.ylim((-5,5))plt.xlabel(&apos;position&apos;)plt.ylabel(&apos;surface height&apos;)plt.xticks(np.linspace(-80,80,9))plt.yticks(np.linspace(-5,5,6))# 设定修改坐标轴位置ax = plt.gca()ax.spines[&apos;right&apos;].set_color(&apos;none&apos;)ax.spines[&apos;top&apos;].set_color(&apos;none&apos;)ax.xaxis.set_ticks_position(&apos;bottom&apos;)ax.yaxis.set_ticks_position(&apos;left&apos;)ax.spines[&apos;bottom&apos;].set_position((&apos;data&apos;,0))ax.spines[&apos;left&apos;].set_position((&apos;data&apos;,0))plt.show() 六、Annotation 注解12]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>Matplotlib</tag>
        <tag>python</tag>
        <tag>莫烦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知乎回答总结]]></title>
    <url>%2F2019%2F04%2F16%2F%E7%9F%A5%E4%B9%8E%E5%9B%9E%E7%AD%94%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[问题一：你有哪些给男孩子在谈恋爱中的忠告（侵删）谈恋爱必须具备的两项能力：（1）体会他人需求的能力：如何循序渐进的表达自己的好感和喜欢，而不只是单方面地只顾着自己的感情宣泄，以致于冒犯到他人而不自知。（2）克制自己欲望的能力：如何避免在对方不那么喜欢自己，又或者完全无感的情况下，太早喜欢上一个人，乃至于到了不可控的地步，从而引起不可避免的情感宣泄，给自己压力不说，同时也会给身边的人带来莫大的困扰。 前者体会他人需求的能力，是一种换位思考的能力，是情商的一种表现形式。后者，克制自己欲的能力是内心安全感的体现形式，内心圆满的人，有独立灵魂的人，自我圆融为一体的人，爱情对于他们而言，从来是都不是必须品。没有爱情，他们自己一个人也可以活得很好，所以他们不会轻易地爱上一个人，更不会为了一个人而寻死觅活，也由此他们的感情生活，相对于大多数缺乏安全感的人而言更为理性，不会有过多的幻想，欲望自然也不需要太用力地去克制。可是啊，对于大多数那些没有安全感的人而言，欲望地克制却是他们恋爱过程中最重要的必修课了？ 一、为什么要学会克制欲望呢？总结：因为喜欢一个人是藏不住的，对方若是在没有任何付出的情况下俘获了你的心，他就会去寻找下一座山峰。 虽然说“欲擒故纵”，是一种俘获爱情的策略，有用，但你也要知道，那仅限于你爱得不那么深的时候。心里没有期待，自然也就没什么负担，撒点小慌，对方自然看不出什么。可当我们深深地爱上一个人的时候，那就不一样了，信息语言传达信息，肢体语言传达态度。你可以口是心非，若无其事地说，没有啊，我哪里喜欢她呀，我们只是普通朋友啊！可是，你知道吗，当你说这些话的时候，你的神情很慌乱，你的眼神飘忽不定，你的肢体语言无不都在传达着：你在说谎这个事实！ 不得不承认：当我们深深地爱上一个人的时候，不管你愿不愿意，也不管你的演技再好，你都无法做得到，跟个没事的人一样。相反，你的一脸痴相无时不刻都在出卖着你，也许对方只是稍微给你露个笑脸，使个眼神，你就以为人家有意于你，开始投怀送抱了。更甚者，人家不需要做任何的什么，只是顶着一个拉风的造型，摆着一张全世界都欠他二万五的臭脸，从你身边走过，你就已经：哦，啊，好帅……这辈子就TA了！ 你的一举一动，无不向对方传达着一个信息：我愿意！人家对你还完全无动于衷呢，你愿意什么呀？也许你天真地以为，你傻傻蠢蠢的样子很可爱很招人喜欢，可事实上对方只会觉得你的爱很廉价，毕竟使个眼色就能得来的“爱”，谁又会去珍惜呢？很轻易地，毫不费力地在没有投资任何时间、感情、精力的情况下，他俘获了你的“芳心”，你满足了他的“征服欲”、他“虚荣心”，他需要的是下一座山峰，再下一座山峰，而不是你这个人！也许你可能反过来安慰自己说，“有些人不属于自己，那怕遇见，其实也挺好，”又或者你依然不死心，你打着“朋友”的名议，试图曲线救国……可是你知道吗，欲望一旦打开了，那是不可能收得回来的，得不到回应的怨气不自觉地撒到对方身上，不可避免地会给对方造成诸多困扰，什么“朋友”，什么“曲线救国”，都只不过是你单方面的一厢情愿！ 二、如何克制自己的欲望呢？总结：如何克制自己的欲望？不要太早喜欢上一个人如何不太早喜欢上一个人？树立正确恋爱观正确的恋爱观：（1）不要把好感当喜欢，不要把占有欲当作爱。（2）不要幻想，不要寻找对方喜欢自己的证据。（3）学会分析一个人对你的真实情感，不要过分去揣测一个人的心思。（4）我们接近一个人，我们社交的目的不应该是为了恋爱，而是为了让自己身边充斥着美好的肉体有趣的灵魂，再从众多美好的肉体有趣的灵魂当中挑选一个自己喜欢的，同时也是喜欢自己的人。（5）试着给彼此一个恋爱实习期。 如果想要在爱情中做到顺其自然，不给自己压力，不给对方造成太多的困扰，同时打高成功率，那最好的办法就是克制自己的欲望，不要太早喜欢上一个人，更不要太早爱上一个人。可如何做到不要太早爱上呢，这就要求你树立正确的恋爱观了，同时丰富自己好自己的生活，克制自己不要过份地沉湎于不着边际的幻想，不要去寻找对对方同样也是喜欢自己的事实！可现实是，总有很多人内心戏十足，对方给自己露了个笑脸，抛了个媚眼，就对为对方有意于自己；对方一个小时不回自己的消息，他整个人就哭天抢地，悲伤得不能自己，玻璃心又事儿妈，小心翼翼地终日惶恐怕恐…… 树立正确恋爱观： 1、不要把好感当喜欢，不要把占有欲当成爱；要了解一这点，你就必须得明白，什么是好感，什么是喜欢，什么又是爱？ 所谓的好感： 是一种流动性的，一对多的浅层次的情感，是冲动，是荷尔蒙，是性激素，是好奇……今天你可以对一个人有好感，觉得对方是一个有魅力的人，也许后天你却又发现对方不是你想象中的那样，似乎也不那么值得去“爱”，于是呼，你换了个对象，你“喜欢”上了其他的人，也许你还会自作多情地有一种“不忠”的感觉。 所谓的喜欢： 是双方在好感得以长期维持的情况下，随着时间的递进，双方之间加深了了解，什么样的性格，什么样的职业，有什么优缺点，有什么样的理想，是什么样的人，并在此基础之上产生一定程度的情感依赖，是一对多； 因为这份喜欢，你会不自觉地进入对方的空间，翻看对方的朋友圈，想更深层次地了解对方； 如果你长时间没有看到对方，或多或少你会有一种失落感和惆怅……当然这只是一种轻微地失落和惆怅，过了一段时间后，你又能恢复如初……没有对方，你会有一些小失落，但你的世界依然在转！ 相对于好感，有依赖的成份，但依然是一对多！ 所谓的爱情： 是一种长期且稳定的深层次情感，是喜欢的基础之上产生的强烈情感依赖，见过了彼此最不堪的一面，彼此暴露出最真实的自我，我知你、我懂你，离开对方，自己的生活或多或少会产生一定程度的不适，由此产生了互相占有对方的想法，随之也就有了排它的属性，是一对一。这个时候彼此之间的情感才能谈得上爱情。 不得不承认，人与人之间，你不坦诚相见个十次八次，你永远不知道对方是一个怎样的人，到底适不适合自己……面都没见过几次，饭也没吃过次，没有足够多的时间去了解彼此，不知道对方是谁，不知道也不想知道对方的过去，不了解也不想了解对方将来要过怎样的生活，只是见人家衣服穿的少了点、胸大了点，就花痴地认为自己遇到爱情了，更甚者认为对方是自己此世今生的唯一，轻易地将自己的未来和对方的未来捆绑在一起，这不是爱，是冲动，是占有欲，是好奇。 没有足够的时间去了解彼此，却轻易地将自己的未来和对方的未来捆绑在一起，这不是爱，是冲动，是占有欲，是好奇。 “爱情”从来都是一件很严肃的事情，没有个三五年，谁无都无法判断是好感还是激情，是新鲜感还是寂寞，一见钟情，钟的往往不是情，而是一副美好的皮囊。 2、不要幻想，不要寻找对方喜欢自己的证据；我曾经不止一次强调过：不要去思考一个人到底喜不喜欢你，也不要去幻想那些不着边际的未来！ 究其缘由在于，当你思考一个人到底喜不喜欢你的时候，当你幻想那些不切实际的未来的时候，那是你不断下坠的过程。为了找到他是喜欢你的证据，你会不断地，反复地思考你与他相处时的一言一行，一举一动……他多看了我一眼，他是不是喜欢我呢？上车的时候，他走过来，先帮我开车门，他是不是对我有好感呢？看见没有，他对我笑了，笑得多阳光呀，这个微笑是属于我的，不属于任何人……可是啊，为什么我发消息给他的时候，他总不能做到及时回复呢，他应该是喜欢我的呀。为什么有时候晚上聊天的时候，聊着聊着，他怎么就睡着了呢，他到底有多喜欢我，我们是不是只能是朋友了？ 唉，今天又是情人节了，室友们都出去约会去了，可是呀，你这个呆瓜木头人，为什么对我还是无动于衷……快来约我呀，来约我，约我，约我呀！ 反正呐，此世今生就是他了，唯她不娶，非他不嫁，我相信只要凭着我的努力，我就一定能获得我想要的幸福。在不远的将来，我要把TA介绍给我身边的朋友，我要带TA去看三月的樱花，六月的雨，八月的向日葵，十月的晚风，我要带她去见我的父母亲朋与好友，我们在市中心最豪华的地方买房，领证结婚，再生好多好多个孩子！可现实是，八字还没一撇呢，想多了吧？ 本来呀，你对她喜的度，爱的量，不增不减，当你放纵自己去思考：他到底喜欢还是不喜欢你时，去寻找他喜欢你的证据时，你对他的痴心却在不断地放大，乃至于不可自拔，你不断地坠落，不断地下沉，你变得不可自拔。猛然一惊: 天啊，我已经深深地坠入爱河，这辈子我再也离不开他！ 3、学会分析一个人对你的真实情感，不要过份地去揣测一个人的心思；爱情本身就是一件非常主观的事情，我爱或者不爱你，本就就是一种主观喜欢！既然是主观，那大部分分析，都基本上是偏离客观的，也就是不准确！所以人家又说了，爱情中的人，基本上都是智商等于零！ 人的行为，主要受两个因素所支配：1、情绪；2、情感； 情绪是很不稳定的，他今天可以对你很好，明天可能又做会出一些看起来讨厌你的举动，背后的因素不可考究，也许是她大姨妈来了，也有可能是她跟朋友吵架了，总之不可能是因为你的因素，同时越是不成熟的人，情绪波动也就越大，所以情绪所产生的行为几乎没有任何可参考的意义！ 真要分析一个人对你的情感，必须综合五个行为左右，而且五个行为时间必须是20天，乃至一个月不等，为何这样子呢？因为一个人的情感周期是，可以说是女生大姨妈的周期！假如一个月内10个行为举止中有三到四个，都指向抗拒你、反感你，不想跟你说话，那你就应该警醒了，你们之间的感情确实存在着危机，或者她也不是那么喜欢你啦！ 4、我们接近一个人，我们社交的目的不应该是为了恋爱，而是为了让自己身边充斥着美好的肉体有趣的灵魂，再从众多美好的肉体有趣的魂中挑选一个自己自己喜欢的，同时也是喜欢自己的人！这个世界没有那么多不负如来不负卿的感情，有些人不属于自己，那怕遇见，其实也挺好！ 不要为了“得到”的目的去接近一个人，而要抱着多认识一个人，多交一个朋友的目的去了解一个人！时常反问自己：如果你为对方付出了许多，如果对方最后并没有选择你而选择了其他的人，你还会继续对她好吗，还会把她当成朋友看待吗，还是删除对方的联系方式，老死不相往来，更甚者从中搞点小破坏，所谓的“我得不到的，别人也别想得到”！ 最开始的时候，你就不抱着太多的期待，做不了恋人，那做朋友其实也挺好的态度，期望的阈值降低了，你自然就能很好的克制自己的欲望。相应的，在两个人的相处中，你会从容许多，你也能够真心为对方乃至是无所求的真诚付出，相应的，你会从容许多，更能享受过程，成功率自然也会高出许多。 想想逝去的青春，那么多年，你删过多少优秀的值得你去爱的人呢？耐何优秀的值得你去爱的人本来就少，见一个喜欢一个，不懂得克制自己的欲望追一个，失败了再删一个……急功近利，不留余地，删删删……把这些你删过的异性集合起来，是不是能组一个足球队呢？ 现在让你组织一场聚会，你又约得出几个异性出来呢？其实她今天不适应你，不代表明天不答应你，十年后她依然不答应你啊。当然啦，要注意哦，这里的她是很多个”她“，我可从来不建议一个人在一颗树上吊死的！ 以上，是广撒网多捕鱼的策略，是克制自己欲望的过程！之所以在这个过程中你感觉到累了，那只一个原因，你期望得太多，在女生对你无感的情况下，你已经投入得太多，所以痛苦是一个必然。还是那句话，如果一个女生没给我十分明确的承诺，我会把她当朋友，是友情，但这份友情，有点那方面的意思仅此而以！ 5、试着给彼此一个恋爱实习期；如果你们聊了一些深层次的话题，你们之间建立了足够的舒适感和案例感；如果你的主动，在她那儿都能得到了良好的回应，不仅如此，时不时地她也会主动地找你聊天，你们走在路上，不管你们双肩靠得有多近，他都不感到有任何的不适，那你可以试着传达在一起的意图了，你可以试着用行为去撩一下她，拉拉她的小手，甚至是一个突袭地吻…… 如果你们做以上的这些，她都不感到尴尬，那么你们进入了一个新的阶段：试恋爱阶段！ 试恋爱阶段，顾名思义：两个人试着处一处。之所以提出这个概念是因为，爱情不是沉重和捆绑，爱情是两个青年男女轻松自然的相处出来的。如果你希望享受爱情，如果你想提高成功率，在爱情中做到顺其自然，那同样的也还是不要抱着太多的期待，也不要过早地要求彼此给对方太多的承诺，纵是我喜欢你，你也同样有意于我，也不要急着谈什么海誓山盟，应该试着给彼此一个恋爱实习期！ 以下是我跟我女友的初告白哦，希望能够给大家一个启发： 我喜欢你，我相信你同样有意于我，我也知道你对我也有那么点小心思，不过，话又说回来，你与我之间谈爱又还太早，没有真正的相处过，你我都不知道，我们到底合不合适，要求对方给自己过多的承诺也太不理性。我们先给彼此一个恋爱实习期呗，先试着处上两个月。在接下来的两个月里，我们先不公开这份关系，过程中如果你发现我有什么不足，或者做得不到位的地方，你要告诉我，我试着去改……甚至，你也可以试着拿我跟其他的男生进行比较，如果两个月结束后，你觉得我们不合适，选择了其他人，那么，我也会有些我也表示尊重和理解！ 因为没有拉升的机会，无法从普通朋友上升为好朋友；也有可能因为，你在表达好感的过程中，给了对方太多压力，使得对方远离你；也有可能是因为你应该拉升关系的时候没有拉升，从而错过了为数不多的窗口期；也有可能是你们对于将来的规划不一……太多的原因，太多的不得以，但不管怎么说，我还是希望你们：做不成恋人，还是可以做朋友！ 不要事事问个结果，不要想着自己可以走到哪一步，喜欢就去表达好感，表达倾慕之心。不要那么多结果导向，不要事事都问一个意义。任何事情，如果一定要强调什么意义，到最后你会发现哪有那么多的意义……或者说，人生本来就是没有意义的。我们活着应该更多的是为了做自己，表达自己，——信仰。这就是超越成败背后的意义！不要把人生理解为一场战斗，那太苦逼，永远记住：我们活着只是为了实现自我，这样子在这个世间没有任何人能够打败你，你就是你自己！ 行文至此，送上我最爱的经典： 有一天，你不再寻找爱情，只是去爱；你不再是渴望成功，只是去做；你不再追求成长，只是去修。那么，一切才真正开始！爱得美，做得成，修得好！灵魂是走在回家的路上，这种美妙殊胜的感觉远远超越你想要的爱情、成功、成长。——纪伯伦]]></content>
      <categories>
        <category>评</category>
      </categories>
      <tags>
        <tag>知乎</tag>
        <tag>恋爱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[句子]]></title>
    <url>%2F2019%2F04%2F13%2F%E5%8F%A5%E5%AD%90%2F</url>
    <content type="text"><![CDATA[听失败者讲话（得到失败的经验以及他失败的原因），看成功人做事。 一个好女人，能让一个男人成为好男人；而一个坏女人，能让一个男人成为哲学家。—-苏格拉底（学生是柏拉图，学生的学生：亚里士多德） 小时候父亲告诉我，女人的眼泪是脑子里进的水，当她眼泪流干的时候，就不好对付了。 如果你想急着做完一件事，说明你的心已经不在这件事上了。 我们造成习惯，习惯反过来成就我们； 我们需要艺术，以免因真相而死亡—-尼采 一个人要有多悲观，才能每天过得开开心心。 这些年，她在我心目中的形象有时万分可恶，有时又重新变得纯洁无暇，无可比拟。我对她，其实爱早就消失了，变成怀念、痛苦、嫉妒、同情、欲望，不断循环。可是没有一秒钟，我对她的感情归于平淡。没有一秒钟。 康德说他最早时瞧不起没有知识涵养的人，后来读了卢梭的书，他认识到人和人之间不应该用头脑来区分，而应该以道德来分辨。读书多肯定看世界的眼光会不一样，但那并没有什么了不起的。从社会学的角度来讲，你之所以有眼前的书，那是整个社会通力合作的结果，那些你看不起的人中，有人替你造纸，有人替你印刷，有人替你排版，更别说你身上的衣服，吃的东西，都是现代社会协作生产的结果，都是“不聪明”的大多数人制造的。没有他们，你只是一只聪明的猴子而已。换句话说，那些少看书的人未必就不聪明，只是他们也许没有你的条件，没有你的环境，仅此而已。总之，知识阶层骄傲是应该的，但是他们之所以骄傲，不应该是他们拥有知识，而应该是他们有能力承担更多的责任。]]></content>
      <categories>
        <category>评</category>
      </categories>
      <tags>
        <tag>句子</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[素描练习记录]]></title>
    <url>%2F2019%2F04%2F10%2F%E7%B4%A0%E6%8F%8F%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[20190407:20190410：]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>素描</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《人生的智慧》读书笔记]]></title>
    <url>%2F2019%2F04%2F09%2F%E3%80%8A%E4%BA%BA%E7%94%9F%E7%9A%84%E6%99%BA%E6%85%A7%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[译者序第一段：叔本华一生并不得志，后来时来运转也只是大众肤浅地追捧，经过流行的巅峰后，就重新归于相对的沉寂。因为他的哲学与大多数人的乐观世界观不相符。虽然第二次世界大战完美地打碎了令人陶醉的乐观主义，但在和平时期，人的眼睛仍旧是短视的，思想仍旧是懈怠的，所以叔本华的哲学只能在少数思想深远的人的头脑中扎根。PS：“天地不仁，以万物为刍狗”（上天并不仁慈，视万物如祭祀用的草扎的狗一般。说明上天对待万物是公平的，并不会特殊对待某人） 第二段：叔本华从来不怀疑自己的天赋使命，他笔耕不辍；不在乎外人的嘲笑。另外他是位语言大师，不仅语言精准，而且简朴。他蔑视空洞抽象，花哨虚假，不为虚名写作。PS：“上士闻道，躬而行之；中士闻道，若存若亡；下士闻道，大笑之，不笑不足以为道”（有智慧的人听了大道理后，会躬身力行；普通人听了大道理后，好像理解又好像没有理解；庸俗的人听了大道理后，对它嗤之以鼻，大声嘲笑，如果不被庸俗的人嘲笑，那么大道理也不能被称之为“道”了） 第三段：叔本华早在30岁就奠定了自己的哲学大厦，完成了叔本华哲学的核心著作《作为意欲和表象的世界》，之后的工作只是对他的哲学观点进行发挥和补充。然后这本著作首发时几乎无人问津。 第四段：叔本华接连写下许多著作，仍无人问津。 第五段：“真理可以耐心等待，因为真理是永存的”，叔本华在出版最后一本著作《附录与补遗》时，终于一夜成名。 第六段：《人生的智慧》取自《附录与补遗》，这本书尽量从世俗、实用的角度考虑问题，因此更适合大众阅读。 第七段：对“意欲”一次作简单的解释。根据叔本华的理论，意欲是这个世界的本原。（1）它超越于时间、空间和因果律以外，既没有原因，也没有目的；（2）它盲目、不顾一切地争取客体化。（我们这个存在于时间、空间，遵循着因果律的复杂多样的现象世界就是意欲的产物和表现，是意欲在时空中的客体化）由于意欲在客体化中遵循着个体化原理（就是说存在于现象世界中的具体、单个组成部分的意欲各自为战，为生存、发展而努力；（在现象世界中表现为在低一级的形态向着高一级的形态的争取、斗争）所以，意欲客体化的过程是一场永恒的、无目的的斗争和发展；它与痛苦和灾难不可分割地联系在一起。 引言 幸福不是一件容易的事：她很难求之于自身，但要想在别处得到则不可能。—–尚福尔（法国作家） 第一段：人生的智慧，其实就是如何称心、愉快地度过这一生的艺术，哲学上可称为“幸福论”，因此，这本书教导人们如何才能享有幸福的生存。但作者对于人生能否与如此定义的“幸福生存”相吻合给予了否定的答案，所以要完成幸福论的著作，作者的议论从平常的角度、实用的角度出发。 第一章、基本的划分第一段：决定凡人命运的根本内容在于三个方面：（1）人的自身。（最广泛意义上属于人个性的东西，包括健康、力量、外貌、气质、道德品格、精神智力及其潜在发展）（2）人所拥有的身外之物。（财产和其他占有物）（3）人向其他人所显示的样子。（他人的看法：名誉、地位、名声） 第二段：相比于身外之物和他人的看法，自身对造成人幸福或不幸福会产生更加根本和彻底的影响。为什么？（1）人的内心快乐或痛苦首先是人的感情、意欲和思想的产物。而自身之外的所有事物对于人的幸福只产生间接的影响。（因此同一样外在的事物和同一样的境遇，对于每个人的影响不尽相同，因为与一个人相关的是这个人对事物的看法、他的感情以及他的意欲活动。外在事物只有在刺激起他的上述东西时才发挥作用。）每个人到底生活于何样的世界，首先取决于这个人对这个世界的理解。现实生活中经历的每时每刻，都由两部分组成：主体和客体。面对完全一样的客体时，不同的主体意味着所构成的现实完全不同。PS： 大众，不分贵贱，都总是承认：众生能够得到的最大幸运，只有自身的个性。”—-歌德 第三段：对于人的快乐而言，主体远远来得比客体重要。而人的健康远远压倒一切外在的好处。为什么？一副健康、良好的体魄和由此带来的宁静和愉快的脾性，以及活跃、清晰、深刻、能够正确无误地把我事物的理解力，还有温和、节制有度的意欲以及由此产生的清白良心—-以上这些好处都是财富、地位所不能代替的。 第四段：对我们的生活幸福而言，我们的自身个性才是最重要和最关键的为什么？（1）我们的个性持久不变，它在任何情况下都发挥着作用。（2）第二、三项好处的保存只能听天由命，而自身个性却不会被剥夺。 第五段：由于自身个性对于生活幸福的重要性，所以我们唯一能做到的就是尽可能充分地利用我们既定的个性，循着符合我们个性的方向，努力争取适合个性的发展，除此之外则一概避免。（就是要选择与我们个性相匹配的地位、职业和生活方式） 第六段：虽然注重身体健康和发挥个人自身才能比全力投入获得财富更为明智，但不要错误理解为我们应该忽略获得我们的生活必需品（适当的财富）。不过，真正的财富（一般指多数的财富）对我们幸福的帮助并不大。 第七段：人的内在拥有对于人的幸福才是最关键的。而大多数不必与生活匮乏作斗争的人，在内在空虚、意识呆滞、思想贫乏的驱使下投入到社交娱乐当中。 第八段：另外两项（财富和他人看法）的重要性不需要强调，第二项是公认的。第三项分为名誉、名望、地位。每个人都可以争取得到名誉；社会地位只有服务国家政府的人才能染指；显赫的名望只有极少数人才会得到。另一方面，只有傻瓜才会把社会地位放置在财产之前。财产、名誉、声望是相互影响的关系。 第二章、人的自身第一段：自身的主要构成：健康的体魄、愉快的心情、良好的智力、高贵的品格。 第二段：人自身中最能带来幸福的是愉快的心情，而愉快心情就是从健康的身体里长出的花朵。保持身体健康的手段无非就是避免一切纵欲放荡的行为、令人不快和剧烈的情绪动荡，以及长时间紧张的精神劳累。最大的愚蠢就是为了金钱、晋升、学问、名声，甚至为了肉欲和其它片刻的欢娱而献出自己的健康。 第三段：愉快的心情不完全取决于健康的体魄，即使是有健康的体魄也会生成忧郁的心情。因为他们的感觉能力与新陈代谢的能力的比例不正常，天才常常忧郁正是因为有着超常的感觉能力。 第四段：出现不同情绪是因人有着不同的感受愉快或不愉快的能力，“郁闷”型的人虽然比“愉快”型的人少感受很多快乐，却规避了很多真实的不幸和苦难（因为他们遇事总考虑最不好的结果） 第五段：健康与美貌有着部分关联，良好的长相是一纸摊开的推荐书，它从一开始就为我们赢得了他人的心。 第六段：痛苦和无聊是人类幸福的两个死敌，我们的生活就是在这两者当中或强或弱的摇摆。这是因为痛苦和无聊存在双重的对立关系：一重是外在（客体）：生活的艰辛和匮乏产生的痛苦，丰裕和安定产生的无聊。另一重是内在（主体）：精神丰富的痛苦，精神迟钝的无聊。 第七段：人们辛苦挣来的闲暇，就是为了让人能够自由地享受意识和个性所带来的乐趣。而当闲暇来临时，凡夫俗子只关心如何去打发时间，而略具才华的人却考虑如何利用时间。为了应付无聊，人们就为意欲找出一些琐碎、微小、随意和暂时的动因，以图刺激意欲，并以此激活智力—-因为智力的任务本来就是理解、把握动因。但这些动因，较之于那些真正、自然的动因，犹如纸币比之于银元，因为前者的价值是带有随意性的；大部分游戏（纸牌）就属于前一类动因。没有游戏，他们便会摆弄手头的物品来帮助自己打发时间，雪茄就是这样的一件代替思考的物品。 第八段：如果一个人内在充足，丰富，不需要从自身之外寻求娱乐，那么，这个人就是一个最幸运的人。 无论身在何处，我们只能在我们自身寻找或者获得幸福。–《旅行者》 第九段：人的幸福全在于无拘束地施展人的突出才能。 第十段：人三种能力的发挥和活动构成了人的三人快乐的源泉： 吃喝、消化、休息和睡觉。（机体新陈代谢能力所带来的乐趣） 运动。（发挥肌肉力量所带来的乐趣） 观察、思考、感觉、阅读、默想、写作、学习、发明、演奏音乐和思考哲学（施展感觉能力方面的乐趣）感觉能力能带来的快乐远大于另外两种基本生理力量。 第十一段： 能够不受阻碍地培养、发挥一个人的突出才能，不管这种才能是什么，是为真正的幸福。 谁要是生来就具备、生来就注定要发挥某种才能，那他就会在发挥这种才能中找到最美好的人生。 PS：《叔本华论道德与自由》：叔本华认为，我们的任何行为都可以归结为一个动机。我们因为这个动机，从而做出了一个相应的行为。当我们做一件事的时候，我们意识到它符合我们的动机，从而领会到一种自由感，但我们的动机却只取决于某一意志，而这意志却不是我们所能把握的，也就是说我们可以体会到一种虚假的自由，却无法得到真正的自由。 第三章、人所拥有的财产第一段：伊比鸠鲁把人的需要分为三类： 第一类属于人的天然的和迫切的需要（食品、衣物） 第二类需要同样是天然的，但不是迫切的（性欲） 既不是天然的，也不是迫切的。（奢侈、排场、铺张和辉煌的追求） 第二段：一个人在拥有财产方面能否得到满足，由一个人所期待得到的财产和自己已经实际拥有的财产之间的关系决定。在我们心目范围之内的具体之物一旦出现，而我们又确信能够得到它，那我们就会感到幸福。但是如果得到这具体之物存在重重困难，他根本就没有得到它的希望和可能，那他就会感觉不幸和痛苦。财富犹如海水：一个人海水喝得越多，他就越感到口渴。这一道理同样适用于名声。我们在失去财富和安逸的处境以后，当我们挺住了最初的阵痛，我们惯常的心境与当初相比较，并没有发生很大的改变。这是因为当命运减少了我们的财富以后，我们自己也就相应降低了我们的要求。反过来，如果交到好运，我们的期望的压缩机就会把期望膨胀起来，我们在这过程中就感到快乐。但是，这一快乐并不会维持多久。当整个剁成全部完成以后，那扩大了的要求范围已经被我们习以为常了；并且，与新的要求相比较，我们就会对目前的拥有不以为然了。 第三段：我们之所以感到不满，原因就在于我们不断试图提高我们的要求，但同时，其它妨碍我们成功的条件因素却保持不变。 第四段：任何其它物品只能满足一个需要，而金钱能满足抽象中的普遍的多种需要。 第五段：我们应把现有的财富视为能够抵御众多可能发生的不幸和灾祸的城墙，而并不是一纸由我们寻欢作乐的许可证。以艺术为职业的人，应把应用天赋才能赚来的钱的大部分当作本金而不是利息，因为他们的才能总有枯竭的时候。以手工技术为职业的人，技术能使用的时间比较长，因此他们赚来的钱比较稳定。而商人则是使用钱来挣钱的人，他们会更好或者更精通如何使用钱。 第六段：以贫穷为现状的人，一旦获得巨额财富，会视之为身外之物，将财富享受和挥霍。 乞丐一旦跨上了坐骑，就非得把马跑死为止。—-《亨利五世》 第七段：上述的人如果是靠能力获得财富的，他对自己的运气和能力抱有过分的自信，而这个自信是在心里，而不是在脑子里。 一个习惯于处理钱财的有钱女人，会小心翼翼地花钱。但一个在结婚以后才首次获得支配金钱权力的女人，会在用钱的时候大胆妄为，她简直就是大肆挥霍。—-《约翰逊的一生》 第四章、人所展现的表象第一段：我们总是过分看重自己存在于他人心目中的样子，但他人的看法就其本身来说，对我们的幸福而言并非至关重要。太过重视他人的看法，就像把一个人的荣誉感建立在“被人夸奖就开心，被人轻视就痛苦”这种特殊的人性上，它会代替道德促使人做出良好的行为。但是对于人自身的幸福，这种荣誉感更多地产生扰乱和不良的作用。所以，从增进幸福的角度出发，我们应该抑制这一人性弱点。应该细致考虑和恰如其分地评估它的真正价值，尽量减低我们对待别人意见的敏感程度，不能称为他人看法和意见的奴隶。 使一个渴求赞语的人闷闷不乐或者兴高采烈的话语，却是多么的无足轻重！ “人的自身、人所拥有的财产”都在我们的头脑意识里发挥作用；而别人对我们的看法旨在别人的头脑意识中产生效果，它是附带种种概念性的东西呈现在别人头脑中的表象。了解这些之后，就可以逐渐对他人的评论泰然处之了。 第二段：这种把非直接为我们所存在的东西作为直接的存在来加以看重的愚蠢做法，人们称之为虚荣，以表示这种渴望、努力所具有的虚幻和空洞的本质。 第三段：隐居生活之所以对于我们的心绪宁静有一种特别良好的影响，其主要原因就在于我们不用生活在别人的视线里。 第四段：虚荣与骄傲的区别在于：骄傲就是确信自己拥有某一方面的突出价值，但虚荣则尽力让别人确信自己拥有某一方面的突出价值。骄傲是发自内在的、直接的自我敬重；而虚荣则是从外在、因而是间接地努力试图获得这一自我敬重。 第五段：如果我们善意地忽略自己的优点，在与他人的交往时也与他人一道错误地视自己与他人是一个样，那么他人就会公开坦白地把我们认定为就是这个样子。 “跟奴隶开玩笑，奴隶就会对你不屑” “你必须强迫自己接受应有的骄傲” 第六段：最廉价的骄傲就是民族的自豪感。 第七段：他人的看法可分为名誉、地位、名声。 第八段：地位、头衔的作用是要得到别人虚假的尊敬，对于增进个人幸福而言，用处不大。 第九段：客观上，名誉是他人对我们的价值的看法；主观上，则是我们对于他人看法的顾忌。 第十段：名誉感和羞耻感的来源：单独的人能够做的事寥寥可数，只有当他生活在与其他人所组成的群体里，他才能有所作为。人的意识得到了发展以后，才会认识到自己这种处境。一旦这样，他就会产生愿望，希望别人视他为人类社会中的一个有用成员，一个有能力履行自己的男人角色的人，并由此能有资格去分享社会所带来的好处。要成为这样的人，他必须首先做好每一个人都需要做好的事情；其次，他需要完成处于他那独特位置上人们所要求他和期望他做好的事。但同样，他很快就认识到问题的关键并不在于他认为自己是一个有用的人，而在于别人是否也这样认为。他要获取别人对自己良好看法的热切愿望，以及他对别人的看法的无比珍视，也就由此而来。这两者都源自人的这种内在感觉—-人们名之为“名誉感”，或者“羞耻感”，这根据情况而定。 未完待续… 第五章、建议和格言第一部分 泛论第一节第一段：理性的人追求的不是快乐，而是没有痛苦。（所有的快乐，其本质都是否定的，而痛苦的本质却是肯定的。）举例解释：1.身体只要有一处疼痛，人就会只关注疼痛的那一处，而不关心其它健康的部分。2.如果有一件事违反了我们的意愿，我们就会总惦记这件事，而不去关心其它如我们所愿发生了的事。从上述情况我们可以看到，意欲的满足总是否定的。意欲得到的满足并不直接被我们感受到，它顶多只以反省、回顾的方式进入我们的意识。但是，意欲受到的抑制却是肯定的。每一快感的产生其实就是意欲所受到的抑制得到了消除，意欲获得了解放。所以，每一种快感都持续相当短暂的时间。 快乐只不过是一场幻梦，但痛苦却是真实存在的。—-伏尔泰 生活并不是让我们享受的，我们必须忍受它和克服它。我们不应该以痛苦为代价去购买快乐，甚至只是冒着遭受痛苦的风险去这样做也不行，否则，我们就会为了那些否定、因而是虚幻的东西而付出了肯定和实在的东西。 第二部分 我们对待自己的态度第四节第一段：认识自己的第一步：了解清楚自己的首要和真正的意愿。应该大致明白自己应该从事何种职业、需要扮演何种角色以及自己与这一世界的关系。 第五节第一段：人生智慧的重要一点就是在关注现在和计划将来这两者之间达到恰到好处的平衡，这样，现在与将来才不至于互相干扰。现在才是唯一真实确切的。将来的发展几乎总是与我们设想的不同，甚至过去也与我们对过去的回想有所出入。 第二段：只能为肯定会发生的灾祸忧心，但这一类灾祸少之又少，因为将来的灾祸充其量是极可能发生或者肯定发生，但发生的事件是全然不确定的。为了保证我们的生活安宁不受影响，我们必须养成习惯，把并不肯定发生的灾祸视为永远不会发生，而并不肯定在某一时间发生的灾祸则肯定不会在很短时间内发生。 第三段：我们忘记了每一天的日子都是生命中不可缺少而又无法代替的，不要总觉得今天又将在明天重现。要珍惜每一刻可以忍受的现在，包括最平凡无奇、我们无动于衷地听任其逝去，甚至迫不及待地要打发掉的日子。 第六节第一段：所有的局限和节制都有助于增进我们的幸福。原因在于意欲受到的刺激越少，我们的痛苦也就越少。限制我们的活动范围就能消除刺激我们意欲的外在动因，而精神上的限制则可以消除内在的动因。但是精神上的制约会产生无聊，所以尽可能的外在限制能增进人们的幸福。（如果无法保证足够丰富的精神以对抗无聊的话） 第七节第一段：忙于外在生活会夺走精神生活所需要的宁静和专注，同样，持续从事精神活动会或多或少地削弱我们应付嘈杂、繁忙的现实生活的能力。所以，每过一段时间，当我们需要着力操持实际生活的首，暂时完全中断精神活动会有好处。 第八节第一段：要从生活经验中汲取一切有益的教训，我们就必须勤于反省，经常回顾做过的事情和曾经有过的感觉和体验；此外还要把我们以前对是事情的判断和现在的看法，以及订下的计划及追求和最终得到的结果及满足相互比较。一个人的生活犹如书的正文，对生活经历的咀嚼和认识则是对正文做出的解释。当时发生的事情，过后可能会忘记并难以回想起来，所以对于值得回忆的时刻，要小心保存。（比如日记） 第九节第一段：幸福属于那些容易感到满足的人，原因如下：（1）人除了依靠自身以外，无法有把握地依靠别人。（2）社会给人所带来的困难和不便、烦恼和危险难以盛数、无法避免。 第二段：获取幸福的错误方法莫过于追求花天酒地的生活，原因如下：（1）我们企图把悲惨的人生变成接连不断的快感、欢乐和享受。这样，幻灭感就会接踵而至。 第三段：社会一旦变得人多势众，平庸就会把持统治地位。 第十七段：学会在人群中保持一定程度的孤独。 第十节第一段：嫉妒是破坏幸福的敌人，我们应该多想想那些处境比我们更为恶劣的人，因为那些生活得比我们好的人只是看上去比我们更好而已。 第十一节第一段：实施某一计划前，要对其深思熟虑，但是一旦开始执行，就静待结果，不要不断回头考虑已经在做的事和的担忧可能遇到的危险。 第十二节第一段：对于已经发生、不可更改的不幸时，要看开。 第十四节第一段：相比于感慨没得到想要的东西，可以多想想已有的东西失去后，我们将会怎样看待那失去之物。 第十五节第一段：做事要一件一件做。 第十七节第一段：生命在于运动。（找一样符合自己个性的才能，然后不断学习） 第十八节第一段：我们行动和努力的指南不可以是想象中的图像，而应该是考虑清楚的概念。（不能为了想象中的东西而行动，而应该考虑实际状况所呈现出来的概念）教育就是让我们只信赖概念，而进行教育时的图像只是起到辅助性的作用。 第十九节第一段：补充第十八节内容，我们应该时刻驾驭我们对眼前现实的印象和直观认识。如果我们无法纯粹通过思想消除某一印象影响的时候，最好的办法就是运用相反的印象以中和它的作用。（忘不了不喜欢你的女生的话，可以想想其他可爱的女生，哈哈哈） 第三部分 我们对他人应该采取的态度第二十一节第一段：在这世界上生存，具备一定的预见能力和宽恕能力合乎我们争取幸福的目的：前者帮助我们避免受到伤害和损失、后者则为我们免除了人事纷争和吵闹。 第二段：“生活，也让别人生活”别人拂逆我们的心意，妨碍我们的行动，但他们这样做完全是出于一种严格的、发自他们本性的必然性，这与物体活动所根据的必然性一般无异。对待许多人，我们最聪明的想法就是：我不准备改变他们，我要利用他们。 第二十二节第一段：]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>人生的智慧</tag>
        <tag>叔本华</tag>
        <tag>哲学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[粗糙度研究现状]]></title>
    <url>%2F2019%2F04%2F06%2F%E7%B2%97%E7%B3%99%E5%BA%A6%E7%A0%94%E7%A9%B6%E7%8E%B0%E7%8A%B6%2F</url>
    <content type="text"><![CDATA[一、起源Patton（1966）用模型试验证实了规则突起岩体符合某个强度准则。 由于实际结构面大多数凹凸不平，起伏角变化较大，而且研究表明Patton起伏角在不同正应力下力学效应不同，于是 Barton提出了新的不规则岩体结构面抗剪强度经验公式，公式中JRC的量测比较困难和复杂。 二、现有确定JRC的方法 Barton标准剖面法 优点：ISRM采用，简单省时不用计算 缺点：精度不高误差大，近年已很少使用 直接测量法（结构面起伏角可通过比较七剖面的全迹长和直线迹长得到） 优点：较Barton法精度有所提高 缺点：真实的全迹长确定较为困难，即使是同一剖面每次量测结果亦均不相同。选择剖面较多，工作量大，并要动用复杂仪器。 表面粗糙参数法 优点：量测过程精度高 缺点：对仪器要求严格，工作量大，若非自动连续记录仪器量测则可导致较大误差，使精度下降。 伸长率法 优点：精度较高 缺点：物理意义不明确，精度和可靠性还有待理论上论证和时间经验积累 幅度法 优点：简单省时 缺点：仅考虑结构面最大起伏幅度是相对结构面长度而言的，没有考虑较小突起体对JRC的贡献，因此精度变化较大。 分形维数法 优点：有良好的理论基础和较高的精度，目前较为完善的方法之一。 三、粗糙度分形维数法进展早期由于设备限制，主要集中于 3.1 节理轮廓线的分形描述，主要获取方法有 针状轮廓尺法，简易纵剖面仪法，RSP-I型智能岩石表面形貌仪法，接触打孔器法，阴影轮廓线法。 近年来，随着设备推陈出新，结构面三维形貌数据较容易获得，主要获取设备有 3D型便携式岩石三位表面形貌仪，三维激光扫描岩石表面仪。 3.2 结构面的分形描述3.2.1 间接描述采用节理轮廓线分维数加1或计算结构面上一条或多条节理轮廓线的自仿射分形的Hurst指数H，然后根据D=3-H获得结构面分形维数。3.2.2 直接量测三角形棱柱表面积法投影覆盖法立方体覆盖法 四、结构面的多重分形描述五、粗糙度表征方案备选石林-3D岩体结构面粗糙度表征方法优点：1.测量便捷，能快速获取现场结构面的形态特征，且计算出的粗糙度具有精确度和可靠度；2.是一种3D角度的评价方法，更全面地考虑结构面的特征，综合反映结构面形态；3.能够反映结构面粗糙度的各向异性、尺寸效应和间距效应这三个影响因素。4.没有复杂的计算过程，具有操作简单便于推广的优点。缺点：尚未建立面积拓展率S和结构面起伏度Rs与岩体结构面抗剪强度的关系。 方法的由来：伸长率：1.伸长率法既考虑了节理相对长度，也考虑了节理剖面起伏变化的因素，而幅度法只考虑了最大的起伏幅度，没有考虑较小的起伏幅度对抗剪强度的影响。2.用伸长率确定节理粗糙度系数的精度主要取决于测量仪器的精度（现在有三维激光扫描仪能保证精度） 直边法和修正直边法：1.岩体结构面表面形态具有各质异性、各向异性和非均一性，定向统计测量方法是保证JRC测量精度的基本方法。2.直边法具有明确的物理意义，有精度保证、测速快、操作简便等优点。修正直边法是Barton直边法的扩充，具有比直边法更强的普适性。3.修正直边法的数学表达式包容了JRC的尺寸效应规律，配合计算机使用，适用于岩体结构面JRC的统计测量。#各质异性：成因、类型和规模相同的同一组结构面，由于所处岩石性质不同，结构面的表面形态和JRC存在明显差异。各向异性：成因、类型和规模相同的同一组结构面，即使处于同一岩石中，结构面的表面形态和粗糙度系数JRC也会因为岩石介质的各向异性，结构面形成时应力环境的各项异性而呈现各项异性。非均一性：处于同一岩石中的同一组结构面，即使沿同一方向进行量测时，各测量段的表面形态和粗糙度系数JRC也存在差异。 上述方法的缺点：伸长率法虽全面考虑了结构面剖面轮廓曲线的结构特征，但是没有区分大小起伏度在影响抗剪效果时的主次权重；而直边法（修正直边法）仅考虑了大的结构起伏对结构面抗剪强度的影响，忽略了小结构起伏对抗剪强度的影响作用。因此，单独使用这2种方法不能确保JRC取值的精确度和可靠度. 李化等将伸长率R和轮廓曲线的相对起伏度Ra两个指标结合起来，让2种方法得到互补，提出了更精确的计算方法. 该方法不仅考虑了结构面大的结构起伏对结构面抗剪强度的影响，同时也考虑了较小结构起伏对抗剪强度的影响，并区分了两者的影响权重，具有较高的精确性和可靠性。 对某一确定的结构面来说，面积扩展率S是一个定值，该参数可以反映结构面粗糙度的尺寸效应和间距效应，但不能反映各向异性。而相对起伏度Ra则可以很好地反映出各向异性，在沿不同剪切方向上具有不同的剖面轮廓曲线，因此该参数可以作为体现结构面粗糙度具有各向异性的指标。从描述结构面粗糙度的特征上来说，相对起伏度Ra弥补了面积扩展率S的不足，这2个参数结合描述结构面的粗糙程度具有可行性. 六、粗糙度问题 劈裂和直剪试试验得到的裂缝粗糙度差别大概在6~12之间，粗糙度正常范围在0~20值得注意的是，在目前的试验研究中，绝大多数采用劈裂或直剪方式形成岩样试验裂缝，以模拟张性裂缝或剪切裂缝。然而，对于同一岩性的岩石而言，劈裂或直剪所得到的裂隙的起伏粗糙程度差别不大，难以得到各种粗糙度的裂隙。郑少河等[9]所制试件的JRC=6～12。由于现场采取的裂隙和人工劈裂或直剪得到的裂隙仅能反映某种或某几种特定粗糙度的裂隙，这些试验结果因而难以完全反映实际裂隙的水力特性，在实际工程的应用中存在一定的局限性。（不同节理粗糙度系数单裂隙渗流特性试验研究） 七、论文依据收集 单一裂隙是构成网络裂隙的基本单元，裂隙的隙宽、粗糙起伏程度等几何参数是影响裂隙内流体流动的主要因素。（岩体裂隙面粗糙度对其渗流特性的影响研究） 粗糙裂隙渗流的数值模拟方法（岩体裂隙面粗糙度对其渗流特性的影响研究_王志良） 微观解释粗糙度。（单裂隙砂岩渗流特性实验研究_王来贵） 结构面的起伏形态对结构面的抗剪强度有直接的影响，张开度对岩体的渗流性质影响很大，所以，在结构面表征中应该对结构面的起伏形态和张开度进行研究，它对结构面的力学特性有直接的关系。（节理岩体结构面空间表征及其模型优化） 结构面的表面形态是结构面表面空间展布的几何属性，结构面的表面形态可按规模大小分为起伏度和粗糙度，起伏度表征大规模的起伏，粗糙度表征小规模的不规则凹凸点，天然结构面的表面形态是起伏度和粗糙度的不同组合。（节理岩体结构面空间表征及其模型优化） 八、裂隙面构造方法3D打印不同粗糙度的裂隙板，结合PVC管组成浇筑磨具。 九、IDEA JRC配合微观图像表征粗糙度]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>粗糙度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" $ hexo new ‘My New Post’ More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[2019聚餐]]></title>
    <url>%2F2019%2F04%2F03%2F2019%E8%81%9A%E9%A4%90%2F</url>
    <content type="text"><![CDATA[0131 去姐夫家和姐夫吃夜宵喝酒 0217 去李锡鹏家吃饭 0219 阿冰哥和姐夫请我吃赣湘楼 0219 和妈妈吃烤海鲜 0222 XP、罗新食尚 0224 返校6人聚餐（鸡公煲） 0226 9人新食尚聚餐 0304 勇哥来我这做菜（腊肠）不要再喝牛栏山了 0309 去华科大西路吃烧烤，肉串的味道比小堕好点。 0320 北阶一家还不错的菜馆，有卖烤鱼，喝了啤酒，感觉并不好喝。 0322 学工组聚餐，口味堂，有点贵啊，今天主要吃的菜，口味鱼头200+接近300，菠菜面，红豆紫薯汁、牛蛙（平锅小美蛙）、饼（包紫薯还是什么来着）、口味粉蒸排骨、三峡石烤馍、虾仁水蒸蛋（因为没有公勺，所以我尽量挖边边的部分）千层扣肉（挺好吃的，一点都不辣，感觉不像是湖南菜啊，听老师们的说话好像这是湖南菜的餐厅） 0325 罗带腊肉来我这做，外加XP、勇哥的四个人小聚（感谢罗带的肉，碗还是罗洗的，优秀） 0325 中午和博、XP在教育食堂吃的，千张肉丝，香焖土鸡，干煸四季豆，家常豆腐都挺好吃的，天予推荐的，不错不错 0331 和孙技星一起吃老街烧烤。 0401 南门天天烧烤（XP请的） 0402 教育食堂（博请的，天予） 0403 教育食堂（我请的，XP） 0407 161聚餐（猪脚，花甲，大盘鸡，鱼块，黄瓜，藕菜，花生） 0410 鸡公煲（我，XP，罗） 0413 鸡公煲（我、XP、罗、勇哥） 0417 南门烧烤（我、XP、罗、勇哥、涛子） 0420 俭朴菜品酒会（我、XP、康成、康成同学、精酒门老板） 0421 新食尚（助管） 0421 回家湘（XP、Luo） 0427 鸡公煲（Luo、XP、涛子） 0503 随便炸炸（天予、博） 0503 新食尚（XP,Luo） 0508 俭朴菜（xp，luo，勇） 0509 回家湘（学工组） 0512 161火锅（灿、超、勇、xp、luo、博、涛子、天予） 0513 涛子生日（四月初九） 0518 老四川（超哥请客，我、越奇、涛子、博、xp、天予） 0525 回家湘（刘总给师兄送行） 0525 小惰（回家湘后转场） 0528 尊宝披萨（学工组加班，感谢王主任） 0531 随便炸炸（天予，博） 0601 南门烧烤（涛子，xp,luo） 0602 鸡公煲（自己） 0606 奇味虾（sjx） 0607 161（xp,勇哥，luo，博，天予）]]></content>
      <categories>
        <category>自律即自由</category>
      </categories>
      <tags>
        <tag>聚餐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年4月考核]]></title>
    <url>%2F2019%2F04%2F03%2F2019%E5%B9%B44%E6%9C%88%E8%80%83%E6%A0%B8%2F</url>
    <content type="text"><![CDATA[第一周（0401-0407）0401 周一 科研 晚上看了粗糙度的文献，没什么收获 读博 今天做了写高数题 环境 其它 0402 周二 科研 读博 莫烦Python基础完成；莫烦Numpy和Pandas开始 环境 其它 爱，死亡与机器人看完，只留下喜欢的几集，zima blue挺有共鸣。 0403 周三 科研 读博 莫烦python看到numpy的基本运算2 环境 其它 《快速使用Hexo搭建个人博客》学到11集（markdown基本语法）；看完crash course:study skills并在Hexo做了笔记。 0404 周四 科研 读博 莫烦python看到numpy的合并 环境 参加张国旗清明纪念仪式；张老师指导拍摄技巧 其它 Hexo搭建博客学习完毕； 0405 周五 科研 读博 莫烦numpy和Pandas数据处理完毕 环境 其它 0406 周六 科研 大致了解粗糙度研究现状，并做了一定整理，发布在博客上 读博 环境 其它 开始学素描，卡在色阶和正方体的明暗上，估计是笔的原因 0407 周日 科研 读博 环境 其它 161聚餐；素描（画方体） 04月第一周考核工作：1.Python、Numpy、Pandas的基础操作(还不熟练，需要多加练习)2.粗糙度研究现状的整理(只有框架，没有深入探究)3.Hexo博客搭建完毕并开始使用（之后慢慢完善）4.学习crash course:study skills（慢慢会应用上）5.开始学素描（之后会把学习的结果发到博客）6.做了少量高数题7.环境工作：参加张国旗清明纪念仪式；张老师指导拍摄技巧 娱乐:1.看完《爱、死亡与机器人》（最喜欢zima blue，大部分也都挺好看）2.161聚餐 总结：优点：工作内容较多，娱乐时间控制较好。缺点：工作中的知识掌握得不够；工作内容没有符合现阶段的重点；缺少与家人的交流； 第二周（0408-0414）0408 周一 科研 晚上看了粗糙度的文献（有眉目，但还是乱） 读博 环境 听十佳标兵试汇报；整理部分发展报告 其它 0409 周二 科研 晚上看了粗糙度的文献，整理了一下，但是没什么思路 读博 环境 发展报告除了奖学金分布，其它都过了一遍，剩下的等周四助管整理完再继续。 其它 重新开始看《人生的智慧》，对“意欲”这个词有了更清晰的认识；重看了木鱼水心解说的红楼梦P5，慢慢觉得《红楼梦》蛮有意思的，有时间可以看看原著。 状态 中午加班了一会，下午回办公室后继续看文献，快晚上时脑袋思维有点停滞了，中午估计还是要休息会，不能一直持续工作。 0410 周三 科研 读博 环境 例会；发展报告整理；互联网+申报数量通知 其它 看了陈果的《爱情课》（大多数还是蛮认同的） 状态 下午本想好好睡一觉，结果还是因为环境的事被叫过去了，所以有点小烦，再加上被陈果的《爱情课》吸引，今天都没做太多事。 0411 周四 科研 读博 环境 助管的统计已经完毕； 其它 看了木鱼的《权力的游戏》第七季微剧场；看了《人生的智慧》 状态 最近正事越拖越多，到现在有点小心烦，明天还是要赶紧把该做的事都做完；和妈妈视频。 0412 周五 科研 修改了一会循环论文； 读博 环境 例会记录整理完；参加新疆克州招聘活动； 其它 整理《人生的智慧》人的自身、人的财富部分，并出图上传至Hexo； 状态 今天整体状态不错，心态挺好，情绪也挺愉快，就是正事干得有点少，明天要继续加油。 0413 周六 科研 修改了一会循环论文； 读博 环境 发展报告完成； 其它 看《人生的智慧》他人的看法部分；看了《调音师》 状态 心情不错，效率优点低，有点不务正业。 0414 周日 科研 修改循环论文； 读博 环境 其它 鸡公煲；回顾木鱼水心《权力的游戏》；看《人生的智慧》；和奶奶视频 04月第二周考核工作：1.整理粗糙度研究现状（依旧不是很有头绪）2.修改循环论文（几乎没改）3.环境工作：整理发展报告；例会记录；开会×24.重新读《人生的智慧》5.看了陈果的《爱情课》（朴实但还蛮有价值） 娱乐:1.回顾《权力的游戏》2.看《调音师》3.鸡公煲4.和家人视频 总结：优点：给了自己很多闲暇的时间，happiness~缺点：工作内容没有符合现阶段的重点；重心有点偏向环境工作； 下周工作内容：1.循环论文修改2.科报会3.开题报告 第三周（0415-0421）0415 周一 科研 循环论文修改了引言和应力-应变曲线部分 读博 环境 查寝（一直被以为是学生。。。）；发展报告最终版； 其它 状态 今天有点务正业了，娱乐也控制的挺好，就是效率比较低，继续保持，之后会慢慢提高的。 0416 周二 科研 循环论文力学性质部分修改； 读博 环境 其它 状态 今天有点务正业了，娱乐也控制的挺好，就是效率比较低，继续保持，之后会慢慢提高的。 0417 周三 科研 循环论文细观部分修改； 读博 环境 国家安全教育日活动；互联网+活动；例会；查寝 其它 状态 忙得有点心烦，。 0418 周四 科研 读博 环境 国家安全教育日通讯稿；互联网+通讯稿； 其它 见了妹妹； 状态 今天比较充实，不过正业还是没有做。 0419 周五 科研 修改论文； 读博 环境 发书；环境的事今天有点多，没办法一一写明了； 其它 回顾了木鱼水心的《权力的游戏》1，2，3 状态 今天一天蛮充实的，就是有点累，晚上也没干多少活，零食还吃得挺多，哈哈哈，真的累。 0420 周六 科研 修改论文； 读博 环境 其它 和XP参加品酒会，蛮开心的，吃得好，喝得好； 状态 今天主要就是改论文，改完发给师兄了；然后晚上吃了一顿开心的晚餐，一天还是蛮充实的，很幸福。 0421 周日 科研 读博 环境 其它 和助管们一起吃饭；和XP、luo去回家湘吃饭； 状态 今天有点“挥霍”，四月份就不要再整些其它的了。 04月第三周考核工作：1.循环论文改完2.环境若干工作 娱乐:1.回顾《权力的游戏》2.新食尚（助管）3.回家湘（XP、Luo）4.俭朴菜（品酒会） 总结：优点：完成了一项正经工作。缺点：重心依然在环境那边；花钱有点多。 下周工作内容：1.开题报告2.读博相关 第四周（0422-0428）0422 周一 科研 读博 环境 环科节相关活动；上传通讯稿；发毕业通知（被挖坑了）； 其它 剪头发 状态 事情多的话，到了晚上确实很累，不过还是要把重心放学习上； 0423 周二 科研 tensorflow学习（没有什么进展）； 读博 环境 其它 琐事； 状态 花了大量时间却没有收获，有点蓝瘦。 0424 周三 科研 读博 环境 修改通讯稿照片； 其它 英语语法；看了复联4 状态 0425 周四 科研 读博 环境 观看篮球队比赛；琐事 其它 状态 0426 周五 科研 读博 环境 其它 改卷； 状态 今天发生了一件很重要的事，一辈子都要记住； 0427 周六 科研 读博 环境 其它 改卷；鸡公煲 状态 0428 周日 科研 读博 环境 其它 和高中同学聊天到半夜两点，基本上都是我在说… 状态 最近感受到新的事物，需要些时间调整一下。 4月总结： 优点：过得挺充实的，科研、环境、个人、娱乐都有包含，而且整体还是处于幸福的状态。 缺点：分配给正事的时间不够，而且做正事效率低；自制力还没有达到预期，在学习、省钱方面还是要加强。 最开心的事：有人跟我表白了。 最不开心的事：同一个女生约了三次都被拒绝了。（还是同一个理由，不知道是真有事还是只是不想跟我出去，感觉是后者，哈哈哈）]]></content>
      <categories>
        <category>自律即自由</category>
      </categories>
      <tags>
        <tag>2019</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B站Hexo博客搭建的个人博客]]></title>
    <url>%2F2019%2F04%2F03%2FB%E7%AB%99Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一、主题安装Git安装然后更改_config.yml中的theme。 二、主题语言修改更改_config.yml中language(zh-CN) 三、增加标签页和分类页next主题文件夹中的_config.yml（与上述不是同一个文件）中搜索menu，找到#categories、#tags，去掉前面的#号，保存，更新。 四、正确打开标签页和分类页12$ hexo n page tags //创建标签页$ hexo n page categories //创建分类页 五、主题样式更改next文件夹中_config.yml中搜索scheme,增删#进行更改 六、更改头像next文件夹中_config.yml中搜索avatar中url:/images/avatar.gif，改成想要的图片(图片要提前存入相应的文件夹) 七、更改标题、作者以及链接在_config.yml中搜索author，对title、author、url进行修改。 八、启用侧边栏社交链接next中的_config.yml搜索social进行修改 九、启用友情链接next中的_config.yml搜索links，找到links： Title:…进行更改 十、新建一篇文章tags: - 标签名1 - 标签名2 categories: 分类名 十一、Markdown基本语法见博客中《markdown基本语法》 十二、开启打赏功能next–_fonfig.yml–搜”reward” 十三、开启订阅公众号next–_config.yml–搜”sub” 十四、设置头像为圆形可旋转视频 十五、首页文章设置阅读全文next–_config.yml–搜“auto”/&lt; !– more – &gt; 十六、添加动态背景next–_config.yml–搜”Canvas” 十七、给博客添加fork Github百度“Github corners”找到喜欢的复制，然后在next/layout/_layout.swig中的1&lt;dir class=&quot;headband&quot;&gt;&lt;/dir&gt;dir&gt; 后另起一行，粘贴，并修改1&lt;a = href=&quot;...&quot;&gt; // &quot;...&quot;为你的github网址 十九、修改文章底部带#的标签next/layout/_macro/post.swig找到….rel = “tags”&gt; # … #改成1&lt;i class = &quot;...&quot; &gt;&lt;/i&gt; 二十、增加搜索功能next/_config.yml 二十三、增加搜索功能官方文档–第三方服务–搜索–local search 二十四、增加不蒜子统计功能next/_config.yml搜“busuanzi” 二十五、增加分享内容（没找到对应内容）二十八、隐藏底部的强力驱动next/layout/_partias/footer.swig 三十、hexo博客部署到远端的githubgithub先创建仓库 – git init（博客文件夹）– npm install hexo-deployer-git – –save – hexo d PS:部分视频没有看，有需要再去看。]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown基本语法]]></title>
    <url>%2F2019%2F04%2F03%2Fmarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一级标题二级标题三级标题四级标题五级标题六级标题 列表1 列表2 子列表2.1 子列表2.2 列表3 Jetzilch的Github 斜线字体字体加粗 单行代码块 12多行代码块1多行代码块2 这部分内容是引用的，主要以原作者的内容为主。 加一条横线（视频演示的是虚的，但是这里显示的就是实的了。。。）加一条横虚线]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Crash Course:Study Skills]]></title>
    <url>%2F2019%2F04%2F03%2FCrash-Course-Study-Skills%2F</url>
    <content type="text"><![CDATA[一、笔记载体和笔记方法的选择1.1 笔记载体：Paper√/Computer原因：Paper虽然记录速度慢，但不容易分心，且能提供更多的思考空间。1.2 笔记方法：大纲法/康奈尔法/思维导图 根据实际情况选择1.3 如何记笔记：如何划重点? 摩斯电码法（觉得是重点在段落旁边画·，之后有对这个重点解释证明阐述的，在段落旁边画-） 二、阅读方法（1）现有的研究证明速读是不可能的，或者说是没有效果的。（2）不要抑制默读，抑制默读影响思考。（3）阅读顺序：浏览-问题-阅读-复述/做题/总结（4）最好的阅读法：SCAR（Stop Complaining And Reading） 三、记忆（1）记忆需要间隔。（2）适度难度原则：回忆起越难想起的记忆，记忆的效果越好，但是如果刻意延长回忆时间可能造成无法回忆起记忆而导致记忆丢失。可以使用莱特纳系统进行复习，即找到5个盒子，分别为隔1，3，5，7，考试前五个时间，学习的知识依照时间长短放入各个盒子，然后根据盒子的天数进行复习。类似的手机软件有Anki。（3）要多使用主动记忆（回忆：未见到知识而回忆起知识）而避免被动记忆（再认：见到笔记后再回想起知识）。被动记忆更适合用于设置小测验（根据笔记出题检测自己） 四、计划与整理要形成一个系统：（1）任务管理器：Evernote（2）如何整理笔记。之前的笔记可能比较散乱，要找出时间进行整理，关于知识的整理可以像这样发布在Hexo上。（3）保证笔记都有物理存储方式（每天的笔记很散乱，最好有一个物理载体能把它们归类到一起，比如一个文件盒，我暂时想到的是买散页纸的包装带，或者找文件夹）（4）开发方案，也就是制定计划（我的理解是每天和每周都做总结，就像兼辅考核表一样） 五、注意力与集中（1）注意力随时间递减（2）一般工作25~30分钟，要休息几分钟，但不要做分散注意力的事。（3）注意力与健康有关，养成好习惯（睡眠7hours，每天锻炼）（4）注意力与环境有关，尽量给自己找一个不受干扰的好环境。 六、文章与写作（对应视频第9集）（1）先进行“前写作”（针对已有的结果进行粗糙的写作）（2）带着上一版的问题定向找资源，并记录资源的量，够用就行。（3）开始写作，但不要带有完美主义。（4）修改论文时先看框架，再看语句。改完后可以大声朗读/打印出来进行修改，效果比较好。]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫烦Numpy和Pandas数据处理教程]]></title>
    <url>%2F2019%2F04%2F02%2F%E8%8E%AB%E7%83%A6Numpy%E5%92%8CPandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Numpy一、Numpy的属性12345678import numpy as nparray = np.array([[1,2,3],[2,3,4]])print(array)print(&apos;number of dim:&apos;,array.ndim) #维度print(&apos;shape:&apos;,array.shape) #几行几列print(&apos;size:&apos;,array.size) #几个元素 二、Numpy创建Array五、Numpy的索引1234import numpy as npA = np.arange(3,15)print(A) #[3 4 5 6 7 8 9 10 11 12 13 14]print(A[3]) #6 矩阵换成二维的1234567891011121314151617181920212223import numpy as npA = np.arange(3,15).reshape((3,4))print(A) #[[3 4 5 6] [7 8 9 10] [11 12 13 14]]print(A[2]) #[11 12 13 14]print(A[1][1]) #8 print(A[1,1]) #8 与上述效果一样print(A[:,1]) #第2列的所有数print(A[1,:]) #第2行的所有数print(A[1,1:2]) #[8]print(A[1,1:3]) #[8,9]for row in A: print(row) #按行输出for column in A.T: print(column) #按列输出print(A.flatten()) #把矩阵变成一维for item in A.flat: print(item) #flat和flatten()功能一样，返回值不一样。返回一维矩阵用flatten(),flat是迭代器，返回的是一串类似地址值的值 三、Numpy的Array合并合并12345678910import numpy as npA = np.array([1,1,1])B = np.array([2,2,2])print(np.vstack(A,B)) #vertical stack 上下合并# [1,1,1] [2,2,2]print(np.hstack(A,B)) #horizontal stack 左右合并# [1,1,1,2,2,2] 增加维度123456print(A[:,np.newaxis]) #增加列维度# [[1] [1] [1]]print(A[np.newaxis,:]) #增加行维度# [[1,1,1]] 例子：123456789A = np.array([1,1,1])[:,np.newaxis]B = np.array([2,2,2])[:,np.newaxis]C = np.hstack(A,B)print(C)# [1,2] [1,2] [1,2]print(A.shape,C.shape)# (3,1) (3,2) 多个Array合并123456789101112131415161718C = np.concatenate((A,B,B,A)，axis=0) # vstack和hstack都可以进行多个Array合并，# concatenate的不同在于可以在后面指定合并的方向。# 0为上下合并，1为水平合并print(C)#[[1] [1] [1] [2] [2] [2] [2] [2] [2] [1] [1] [1]] 四、Numpy的分割先生成一个array：12345678910111213141516171819import numpy as npA = np.arange(12).reshape((3,4))print(A)# [[0,1,2][3,4,5][6,7,8][9,10,11]]print(np.split(A,2,axis=1))#1是上下分开，0是左右分开# [array([[0,1], [4,5], [8,9]]), array([[2,3], [6,7], [10,11]])] split只能进行相同分割，进行不相等分割要使用array_split123456789101112print(np.array_split(A,3,axis=1))#[array([[0,1], [4,5], [8,9]]), array([[2], [6], [10]]) array([[3], [7], [11]])] 相对于合并，分割也有vsplit和hsplit123456789101112print(np.vsplit(A,3))#[array([[0,1,2,3]])],[array([[4,5,6,7]])],[array([[8,9,10,11]])]print(np.hsplit(A,2))#[array([[0,1], [4,5], [8,9]]), array([[2,3], [6,7], [10,11]])] 五、Numpy的copy和deep copy12345678910111213141516import numpy as npa = np.arange(4)b = ac = ad = ba[0] = 11 #默认格式是整数# 此时a,b,c,d都会改变，因为python中这种赋值方式下a,b,c,d是完全一样的d[1:3] = [22,33]# 此时a,b.c,d也会全部发生改变b = a.copy() #deep copya[3] = 44#a = [11,22,33,44]b = [11,22,33,3]deep copy后,a变化不会使b变化 Pandas一、Pandas的基本介绍Series123456789101112import pandas as pdimport numpy as nps = pd.Series([1,3,6,np.nan,44,1])print(s)#0 1.01 3.02 6.03 NaN4 44.05 1.0dtype: float64 DataFrame1234567891011121314151617dates = pd.date_range(&apos;20160101&apos;,periods=6)print(dates)# 先生成一个索引DatetimeIndex([&apos;2016-01-01&apos;, &apos;2016-01-02&apos;, &apos;2016-01-03&apos;, &apos;2016-01-04&apos;, &apos;2016-01-05&apos;, &apos;2016-01-06&apos;], dtype=&apos;datetime64[ns]&apos;, freq=&apos;D&apos;)df = pd.DataFrame(np.random.randn(6,4),index=dates,columns=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])print(df)# 生成DataFrame a b c d2016-01-01 0.545643 2.021614 1.210559 0.4678342016-01-02 0.666108 0.419161 -1.943871 -0.9532632016-01-03 -0.759923 -0.337458 -1.865560 0.3280372016-01-04 0.198904 0.880258 -1.369046 0.8859452016-01-05 -0.828801 -0.602095 -0.897741 0.1682772016-01-06 0.937178 -0.593869 0.043363 -0.273371 没有索引生成DataFrame1234567df1 = pd.DataFrame(np.random.randn(3,4))print(df1)# 0 1 2 30 0.378297 -0.354029 0.407989 -0.0678381 -1.210963 2.706774 0.875143 0.3606812 -0.964372 0.919133 0.768482 0.221687 按索引排序123456789df1 = pd.DataFrame(np.arange(12).reshape((3,4)))print(df1)print(df1.sort_index(axis=0,ascending=False)) # 0 1 2 32 8 9 10 111 4 5 6 70 0 1 2 3 按值排序123456print(df1.sort_values(by=2))# 0 1 2 30 0 1 2 31 4 5 6 72 8 9 10 11 二、选择数据先生成一个DataFrame1234567891011121314151617181920212223242526272829303132333435363738394041424344import pandas as pdimport numpy as npdates = pd.date_range(&apos;20130101&apos;,periods=6)df = pd.DataFrame(np.arange(24).reshape((6,4)),index=dates,columns=[&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;])print(df)print(df[&apos;A&apos;])print(df.A)# A B C D2013-01-01 0 1 2 32013-01-02 4 5 6 72013-01-03 8 9 10 112013-01-04 12 13 14 152013-01-05 16 17 18 192013-01-06 20 21 22 232013-01-01 02013-01-02 42013-01-03 82013-01-04 122013-01-05 162013-01-06 20Freq: D, Name: A, dtype: int322013-01-01 02013-01-02 42013-01-03 82013-01-04 122013-01-05 162013-01-06 20Freq: D, Name: A, dtype: int32print(df[0:3])print(df[&apos;20130102&apos;:&apos;20130104&apos;])# A B C D2013-01-01 0 1 2 32013-01-02 4 5 6 72013-01-03 8 9 10 11 A B C D2013-01-02 4 5 6 72013-01-03 8 9 10 112013-01-04 12 13 14 15 从标签来选择1234567print(df.loc[&apos;20130102&apos;])#A 4B 5C 6D 7Name: 2013-01-02 00:00:00, dtype: int32 从列标签中选择，并输出所有行结果1234567891011121314151617print(df.loc[:,[&apos;A&apos;,&apos;B&apos;]])# A B2013-01-01 0 12013-01-02 4 52013-01-03 8 92013-01-04 12 132013-01-05 16 172013-01-06 20 21print(df.loc[&apos;20130102&apos;:,[&apos;A&apos;,&apos;B&apos;]]) A B2013-01-02 4 52013-01-03 8 92013-01-04 12 132013-01-05 16 172013-01-06 20 21 从位置选择123456789101112131415161718192021222324print(df.iloc[3]) #第4行的数据#A 12B 13C 14D 15Name: 2013-01-04 00:00:00, dtype: int32print(df.iloc[3，1]) #第4行第2个数据#13print(df.iloc[3:5，1:3]) #第4行到第6行，第2位到第4位# B C2013-01-04 13 142013-01-05 17 18print(df.iloc[[1,3,5],1:3]) #第2，4，6行...# B C2013-01-02 5 62013-01-04 13 142013-01-06 21 22 混合选择123456print(df.ix[:3,[&apos;A&apos;,&apos;C&apos;]])# A C2013-01-01 0 22013-01-02 4 62013-01-03 8 10 其它1234567891011121314print(df)print(df[df.A&gt;8])# A B C D2013-01-01 0 1 2 32013-01-02 4 5 6 72013-01-03 8 9 10 112013-01-04 12 13 14 152013-01-05 16 17 18 192013-01-06 20 21 22 23 A B C D2013-01-04 12 13 14 152013-01-05 16 17 18 192013-01-06 20 21 22 23 三、Pandas设置值先生成一个DataFrame123456789101112131415161718192021222324252627282930313233343536373839dates = pd.date_range(&apos;20130101&apos;,periods=6)df = pd.DataFrame(np.arange(24).reshape((6,4)),index=dates,columns=[&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;])# A B C D2013-01-01 0 1 2 32013-01-02 4 5 6 72013-01-03 8 9 10 112013-01-04 12 13 14 152013-01-05 16 17 18 192013-01-06 20 21 22 23df.iloc[2,2] = 1111print(df)# A B C D2013-01-01 0 1 2 32013-01-02 4 5 6 72013-01-03 8 9 10 112013-01-04 12 13 14 152013-01-05 16 17 18 192013-01-06 20 21 22 23 A B C D2013-01-01 0 1 2 32013-01-02 4 5 6 72013-01-03 8 9 1111 112013-01-04 12 13 14 152013-01-05 16 17 18 192013-01-06 20 21 22 23df.loc[&apos;20130101&apos;,&apos;A&apos;] = 2222print(df)# A B C D2013-01-01 2222 1 2 32013-01-02 4 5 6 72013-01-03 8 9 1111 112013-01-04 12 13 14 152013-01-05 16 17 18 192013-01-06 20 21 22 23 另一种设置值的方法123456789101112131415161718192021df[df.A&gt;4] = 0print(df)# A B C D2013-01-01 0 1 2 32013-01-02 4 5 6 72013-01-03 0 0 0 02013-01-04 0 0 0 02013-01-05 0 0 0 02013-01-06 0 0 0 0df.A[df.A&gt;4] = 0print(df)# A B C D2013-01-01 0 1 2 32013-01-02 4 5 6 72013-01-03 0 9 10 112013-01-04 0 13 14 152013-01-05 0 17 18 192013-01-06 0 21 22 23 加一列123456789101112131415161718192021df[&apos;F&apos;] = np.nanprint(df)# A B C D F2013-01-01 0 1 2 3 NaN2013-01-02 4 5 6 7 NaN2013-01-03 8 9 10 11 NaN2013-01-04 12 13 14 15 NaN2013-01-05 16 17 18 19 NaN2013-01-06 20 21 22 23 NaNdf[&apos;E&apos;] = pd.Series([1,2,3,4,5,6],index=pd.date_range(&apos;20130101&apos;,periods=6))print(df)# A B C D E2013-01-01 0 1 2 3 12013-01-02 4 5 6 7 22013-01-03 8 9 10 11 32013-01-04 12 13 14 15 42013-01-05 16 17 18 19 52013-01-06 20 21 22 23 6 四、Pandas处理异常数据生成一个带有Nan的DataFrame12345678910111213141516171819202122232425import pandas as pdimport numpy as npdates = pd.date_range(&apos;20130101&apos;,periods=6)df = pd.DataFrame(np.arange(24).reshape((6,4)),index=dates,columns=[&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;])df.iloc[0,1] = np.nandf.iloc[1,2] = np.nanprint(df)# A B C D2013-01-01 0 NaN 2.0 32013-01-02 4 5.0 NaN 72013-01-03 8 9.0 10.0 112013-01-04 12 13.0 14.0 152013-01-05 16 17.0 18.0 192013-01-06 20 21.0 22.0 23print(df.dropna(axis=0,how=&apos;any&apos;))# A B C D2013-01-03 8 9.0 10.0 112013-01-04 12 13.0 14.0 152013-01-05 16 17.0 18.0 192013-01-06 20 21.0 22.0 23 丢掉带有数据的行或列12345678910111213141516171819print(df.dropna(axis=0,how=&apos;any&apos;)) #丢掉行# A B C D2013-01-03 8 9.0 10.0 112013-01-04 12 13.0 14.0 152013-01-05 16 17.0 18.0 192013-01-06 20 21.0 22.0 23print(df.dropna(axis=1,how=&apos;any&apos;)) #丢掉列# A D2013-01-01 0 32013-01-02 4 72013-01-03 8 112013-01-04 12 152013-01-05 16 192013-01-06 20 23print(df.dropna(axis=0,how=&apos;all&apos;)) #行或列全是Nan才删除 将没有填的空，填上数据123456789print(df.fillna(value=0))# A B C D2013-01-01 0 0.0 2.0 32013-01-02 4 5.0 0.0 72013-01-03 8 9.0 10.0 112013-01-04 12 13.0 14.0 152013-01-05 16 17.0 18.0 192013-01-06 20 21.0 22.0 23 判断整个表格中数据是否存在123456789print(df.isnull())# A B C D2013-01-01 False True False False2013-01-02 False False True False2013-01-03 False False False False2013-01-04 False False False False2013-01-05 False False False False2013-01-06 False False False False 数据太多，没办法每行每列找，可以用下列方法123print(np.any(pd.isnull()) == True)#True 五、Pandas导入导出导入表格12345678910111213141516import pandas as pdimport numpy as npdata = pd.read_csv(&apos;C:/Users/zz/Desktop/Python training/1.csv&apos;)print(data)# Student ID Name Gender Language0 1 A male C1 2 B female E2 3 C male A3 4 D female C4 5 E male E5 6 F male A6 7 G female A7 8 H female E8 9 I female C 导出表格1data.to_pickle(&apos;2.pickle&apos;) 六、Pandas合并 concate生成三个DataFrame12345678910111213141516171819202122import pandas as pdimport numpy as npdf1 =pd.DataFrame(np.ones((3,4))*0,columns=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])df2 =pd.DataFrame(np.ones((3,4))*1,columns=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])df3 =pd.DataFrame(np.ones((3,4))*2,columns=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])print(df1)print(df2)print(df3)# a b c d0 0.0 0.0 0.0 0.01 0.0 0.0 0.0 0.02 0.0 0.0 0.0 0.0 a b c d0 1.0 1.0 1.0 1.01 1.0 1.0 1.0 1.02 1.0 1.0 1.0 1.0 a b c d0 2.0 2.0 2.0 2.01 2.0 2.0 2.0 2.02 2.0 2.0 2.0 2.0 第一种合并123456789101112131415161718192021res = pd.concat([df1,df2,df3],axis=0)print(res)# a b c d0 0.0 0.0 0.0 0.01 0.0 0.0 0.0 0.02 0.0 0.0 0.0 0.00 1.0 1.0 1.0 1.01 1.0 1.0 1.0 1.02 1.0 1.0 1.0 1.00 2.0 2.0 2.0 2.01 2.0 2.0 2.0 2.02 2.0 2.0 2.0 2.0res = pd.concat([df1,df2,df3],axis=1)print(res)# a b c d a b c d a b c d0 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0 2.0 2.0 2.0 2.01 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0 2.0 2.0 2.0 2.02 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0 2.0 2.0 2.0 2.0 重新赋予左边的索引12345678910111213res = pd.concat([df1,df2,df3],axis=0，ignore_index=True)print(res)# a b c d0 0.0 0.0 0.0 0.01 0.0 0.0 0.0 0.02 0.0 0.0 0.0 0.03 1.0 1.0 1.0 1.04 1.0 1.0 1.0 1.05 1.0 1.0 1.0 1.06 2.0 2.0 2.0 2.07 2.0 2.0 2.0 2.08 2.0 2.0 2.0 2.0 另一种合并(‘outer’,’inner’)先生成两个DataFrame12345678910111213df1 = pd.DataFrame(np.ones((3,4))*0,index=[1,2,3],columns=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])df2 = pd.DataFrame(np.ones((3,4))*1,index=[2,3,4],columns=[&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;])print(df1)print(df2)# a b c d1 0.0 0.0 0.0 0.02 0.0 0.0 0.0 0.03 0.0 0.0 0.0 0.0 b c d e2 1.0 1.0 1.0 1.03 1.0 1.0 1.0 1.04 1.0 1.0 1.0 1.0 内外连接（默认为outer）1234567891011121314151617181920212223242526272829303132res = pd.concat([df1,df2],join=&apos;outer&apos;)print(res)# a b c d e1 0.0 0.0 0.0 0.0 NaN2 0.0 0.0 0.0 0.0 NaN3 0.0 0.0 0.0 0.0 NaN2 NaN 1.0 1.0 1.0 1.03 NaN 1.0 1.0 1.0 1.04 NaN 1.0 1.0 1.0 1.0res = pd.concat([df1,df2],join=&apos;inner&apos;)print(res)# b c d1 0.0 0.0 0.02 0.0 0.0 0.03 0.0 0.0 0.02 1.0 1.0 1.03 1.0 1.0 1.04 1.0 1.0 1.0res = pd.concat([df1,df2],join=&apos;inner&apos;,ignore_index=True)print(res)# b c d0 0.0 0.0 0.01 0.0 0.0 0.02 0.0 0.0 0.03 1.0 1.0 1.04 1.0 1.0 1.05 1.0 1.0 1.0 根据索引连接123456789df1 = pd.DataFrame(np.ones((3,4))*0,index=[1,2,3],columns=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])df2 = pd.DataFrame(np.ones((3,4))*1,index=[2,3,4],columns=[&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;])res = pd.concat([df1,df2],axis=1,join_axes=[df1.index])print(res)# a b c d b c d e1 0.0 0.0 0.0 0.0 NaN NaN NaN NaN2 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.03 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0 append添加123456789101112131415161718192021222324252627df1 =pd.DataFrame(np.ones((3,4))*0,columns=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])df2 =pd.DataFrame(np.ones((3,4))*1,columns=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])df3 =pd.DataFrame(np.ones((3,4))*2,columns=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])res = df1.append(df2,ignore_index=True)print(res)# a b c d0 0.0 0.0 0.0 0.01 0.0 0.0 0.0 0.02 0.0 0.0 0.0 0.03 1.0 1.0 1.0 1.04 1.0 1.0 1.0 1.05 1.0 1.0 1.0 1.0res = df1.append([df2,df3],ignore_index=True)print(res)# a b c d0 0.0 0.0 0.0 0.01 0.0 0.0 0.0 0.02 0.0 0.0 0.0 0.03 1.0 1.0 1.0 1.04 1.0 1.0 1.0 1.05 1.0 1.0 1.0 1.06 2.0 2.0 2.0 2.07 2.0 2.0 2.0 2.08 2.0 2.0 2.0 2.0 七、Pandas合并 merge生成两个DataFrame12345678910111213141516171819202122import pandas as pdimport numpy as npleft = pd.DataFrame(&#123;&apos;key&apos;: [&apos;K0&apos;, &apos;K1&apos;, &apos;K2&apos;, &apos;K3&apos;], &apos;A&apos;: [&apos;A0&apos;, &apos;A1&apos;, &apos;A2&apos;, &apos;A3&apos;], &apos;B&apos;: [&apos;B0&apos;, &apos;B1&apos;, &apos;B2&apos;, &apos;B3&apos;]&#125;)right = pd.DataFrame(&#123;&apos;key&apos;: [&apos;K0&apos;, &apos;K1&apos;, &apos;K2&apos;, &apos;K3&apos;], &apos;C&apos;: [&apos;C0&apos;, &apos;C1&apos;, &apos;C2&apos;, &apos;C3&apos;], &apos;D&apos;: [&apos;D0&apos;, &apos;D1&apos;, &apos;D2&apos;, &apos;D3&apos;]&#125;)print(left)print(right)# key A B0 K0 A0 B01 K1 A1 B12 K2 A2 B23 K3 A3 B3 key C D0 K0 C0 D01 K1 C1 D12 K2 C2 D23 K3 C3 D3 merge12345678res = pd.merge(left,right,on=&apos;key&apos;)print(res)# key A B C D0 K0 A0 B0 C0 D01 K1 A1 B1 C1 D12 K2 A2 B2 C2 D23 K3 A3 B3 C3 D3 两列key1234567891011121314151617181920212223242526left = pd.DataFrame(&#123;&apos;key1&apos;: [&apos;K0&apos;, &apos;K0&apos;, &apos;K1&apos;, &apos;K2&apos;], &apos;key2&apos;: [&apos;K0&apos;, &apos;K1&apos;, &apos;K0&apos;, &apos;K1&apos;], &apos;A&apos;: [&apos;A0&apos;, &apos;A1&apos;, &apos;A2&apos;, &apos;A3&apos;], &apos;B&apos;: [&apos;B0&apos;, &apos;B1&apos;, &apos;B2&apos;, &apos;B3&apos;]&#125;)right = pd.DataFrame(&#123;&apos;key1&apos;: [&apos;K0&apos;, &apos;K1&apos;, &apos;K1&apos;, &apos;K2&apos;], &apos;key2&apos;: [&apos;K0&apos;, &apos;K0&apos;, &apos;K0&apos;, &apos;K0&apos;], &apos;C&apos;: [&apos;C0&apos;, &apos;C1&apos;, &apos;C2&apos;, &apos;C3&apos;], &apos;D&apos;: [&apos;D0&apos;, &apos;D1&apos;, &apos;D2&apos;, &apos;D3&apos;]&#125;)res = pd.merge(left,right,on=[&apos;key1&apos;,&apos;key2&apos;])print(res)# key1 key2 A B C D0 K0 K0 A0 B0 C0 D01 K1 K0 A2 B2 C1 D12 K1 K0 A2 B2 C2 D2res = pd.merge(left,right,on=[&apos;key1&apos;,&apos;key2&apos;],how=&apos;outer&apos;)# how = [&apos;left&apos;,&apos;right&apos;,&apos;outer&apos;,&apos;inner&apos;] print(res)# key1 key2 A B C D0 K0 K0 A0 B0 C0 D01 K0 K1 A1 B1 NaN NaN2 K1 K0 A2 B2 C1 D13 K1 K0 A2 B2 C2 D24 K2 K1 A3 B3 NaN NaN5 K2 K0 NaN NaN C3 D3 indicator生成DataFrame1234df1 = pd.DataFrame(&#123;&apos;col1&apos;:[0,1], &apos;col_left&apos;:[&apos;a&apos;,&apos;b&apos;]&#125;)df2 = pd.DataFrame(&#123;&apos;col1&apos;:[1,2,2],&apos;col_right&apos;:[2,2,2]&#125;)print(df1)print(df2) 使用indicator12345678res = pd.merge(df1, df2, on=&apos;col1&apos;, how=&apos;outer&apos;, indicator=True)print(res)# col1 col_left col_right _merge0 0 a NaN left_only1 1 b 2.0 both2 2 NaN 2.0 right_only3 2 NaN 2.0 right_only index1234567891011121314left = pd.DataFrame(&#123;&apos;A&apos;: [&apos;A0&apos;, &apos;A1&apos;, &apos;A2&apos;], &apos;B&apos;: [&apos;B0&apos;, &apos;B1&apos;, &apos;B2&apos;]&#125;, index=[&apos;K0&apos;, &apos;K1&apos;, &apos;K2&apos;])right = pd.DataFrame(&#123;&apos;C&apos;: [&apos;C0&apos;, &apos;C2&apos;, &apos;C3&apos;], &apos;D&apos;: [&apos;D0&apos;, &apos;D2&apos;, &apos;D3&apos;]&#125;, index=[&apos;K0&apos;, &apos;K2&apos;, &apos;K3&apos;])res = pd.merge(left, right, left_index=True, right_index=True, how=&apos;outer&apos;)print(res)# A B C DK0 A0 B0 C0 D0K1 A1 B1 NaN NaNK2 A2 B2 C2 D2K3 NaN NaN C3 D3 handle overlapping12345678boys = pd.DataFrame(&#123;&apos;k&apos;: [&apos;K0&apos;, &apos;K1&apos;, &apos;K2&apos;], &apos;age&apos;: [1, 2, 3]&#125;)girls = pd.DataFrame(&#123;&apos;k&apos;: [&apos;K0&apos;, &apos;K0&apos;, &apos;K3&apos;], &apos;age&apos;: [4, 5, 6]&#125;)res = pd.merge(boys, girls, on=&apos;k&apos;, suffixes=[&apos;_boy&apos;, &apos;_girl&apos;], how=&apos;inner&apos;)print(res)# k age_boy age_girl0 K0 1 41 K0 1 5 八、Pandas Plot画图生成Series12345678910111213141516import pandas as pdimport numpy as npimport matplotlib.pyplot as pltdata = pd.Series(np.random.randn(1000), index=np.arange(1000))data = data.cumsum()data.plot()plt.show()data = pd.DataFrame(np.random.randn(1000, 4), index=np.arange(1000), columns=list(&quot;ABCD&quot;))data = data.cumsum()ax = data.plot.scatter(x=&apos;A&apos;, y=&apos;B&apos;, color=&apos;DarkBlue&apos;, label=&quot;Class 1&quot;)data.plot.scatter(x=&apos;A&apos;, y=&apos;C&apos;, color=&apos;LightGreen&apos;, label=&apos;Class 2&apos;, ax=ax)plt.show()]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>numpy</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫烦Python基础笔记]]></title>
    <url>%2F2019%2F04%2F01%2F%E8%8E%AB%E7%83%A6Python%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、安装注意配置环境变量和pipe3的环境变量（新版安装时打勾就可以自动配置） 二、基本使用2.1 print功能2.2 基本数学运算&emsp;&emsp;次方用**表示，区别于传统的^.&emsp;&emsp;取余用%2.3 变量variable&emsp;&emsp;命名时多个单词用下划线隔开&emsp;&emsp;多个变量复制：a,b,c = 11,12,13 三、while循环和for循环四、if判断Python中并没有类似三目运算符的命令，但是有替代。如，1234worked = True result = &apos;done&apos; if worked else &apos;not yet&apos;//如果worked是True，则&apos;done&apos;被赋值给result，false则是‘not yet’被赋值给result print(result) 五、定义功能六、变量形式七、模块安装安装Numpy 八、文件读取九、class类十、input输入十一、元组turple、列表List、字典十二、模块import]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
