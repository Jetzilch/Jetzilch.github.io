<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[句子]]></title>
    <url>%2F2019%2F04%2F13%2F%E5%8F%A5%E5%AD%90%2F</url>
    <content type="text"><![CDATA[以颤抖之身追赶，以敬畏之心挑战。—-《明朝那些事儿》1 听失败者讲话（得到失败的经验以及他失败的原因），看成功人做事。 一个好女人，能让一个男人成为好男人；而一个坏女人，能让一个男人成为哲学家。—-苏格拉底（学生是柏拉图，学生的学生：亚里士多德）]]></content>
      <categories>
        <category>评</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>句子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[素描练习记录]]></title>
    <url>%2F2019%2F04%2F10%2F%E7%B4%A0%E6%8F%8F%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[20190407:20190410：]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>素描</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《人生的智慧》读书笔记]]></title>
    <url>%2F2019%2F04%2F09%2F%E3%80%8A%E4%BA%BA%E7%94%9F%E7%9A%84%E6%99%BA%E6%85%A7%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[译者序第一段：叔本华一生并不得志，后来时来运转也只是大众肤浅地追捧，经过流行的巅峰后，就重新归于相对的沉寂。因为他的哲学与大多数人的乐观世界观不相符。虽然第二次世界大战完美地打碎了令人陶醉的乐观主义，但在和平时期，人的眼睛仍旧是短视的，思想仍旧是懈怠的，所以叔本华的哲学只能在少数思想深远的人的头脑中扎根。PS：“天地不仁，以万物为刍狗”（上天并不仁慈，视万物如祭祀用的草扎的狗一般。说明上天对待万物是公平的，并不会特殊对待某人） 第二段：叔本华从来不怀疑自己的天赋使命，他笔耕不辍；不在乎外人的嘲笑。另外他是位语言大师，不仅语言精准，而且简朴。他蔑视空洞抽象，花哨虚假，不为虚名写作。PS：“上士闻道，躬而行之；中士闻道，若存若亡；下士闻道，大笑之，不笑不足以为道”（有智慧的人听了大道理后，会躬身力行；普通人听了大道理后，好像理解又好像没有理解；庸俗的人听了大道理后，对它嗤之以鼻，大声嘲笑，如果不被庸俗的人嘲笑，那么大道理也不能被称之为“道”了） 第三段：叔本华早在30岁就奠定了自己的哲学大厦，完成了叔本华哲学的核心著作《作为意欲和表象的世界》，之后的工作只是对他的哲学观点进行发挥和补充。然后这本著作首发时几乎无人问津。 第四段：叔本华接连写下许多著作，仍无人问津。 第五段：“真理可以耐心等待，因为真理是永存的”，叔本华在出版最后一本著作《附录与补遗》时，终于一夜成名。 第六段：《人生的智慧》取自《附录与补遗》，这本书尽量从世俗、实用的角度考虑问题，因此更适合大众阅读。 第七段：对“意欲”一次作简单的解释。根据叔本华的理论，意欲是这个世界的本原。（1）它超越于时间、空间和因果律以外，既没有原因，也没有目的；（2）它盲目、不顾一切地争取客体化。（我们这个存在于时间、空间，遵循着因果律的复杂多样的现象世界就是意欲的产物和表现，是意欲在时空中的客体化）由于意欲在客体化中遵循着个体化原理（就是说存在于现象世界中的具体、单个组成部分的意欲各自为战，为生存、发展而努力；（在现象世界中表现为在低一级的形态向着高一级的形态的争取、斗争）所以，意欲客体化的过程是一场永恒的、无目的的斗争和发展；它与痛苦和灾难不可分割地联系在一起。 引言 幸福不是一件容易的事：她很难求之于自身，但要想在别处得到则不可能。—–尚福尔（法国作家） 第一段：人生的智慧，其实就是如何称心、愉快地度过这一生的艺术，哲学上可称为“幸福论”，因此，这本书教导人们如何才能享有幸福的生存。但作者对于人生能否与如此定义的“幸福生存”相吻合给予了否定的答案，所以要完成幸福论的著作，作者的议论从平常的角度、实用的角度出发。 第一章、基本的划分第一段：决定凡人命运的根本内容在于三个方面：（1）人的自身。（最广泛意义上属于人个性的东西，包括健康、力量、外貌、气质、道德品格、精神智力及其潜在发展）（2）人所拥有的身外之物。（财产和其他占有物）（3）人向其他人所显示的样子。（他人的看法：名誉、地位、名声） 第二段：相比于身外之物和他人的看法，自身对造成人幸福或不幸福会产生更加根本和彻底的影响。为什么？（1）人的内心快乐或痛苦首先是人的感情、意欲和思想的产物。而自身之外的所有事物对于人的幸福只产生间接的影响。（因此同一样外在的事物和同一样的境遇，对于每个人的影响不尽相同，因为与一个人相关的是这个人对事物的看法、他的感情以及他的意欲活动。外在事物只有在刺激起他的上述东西时才发挥作用。）每个人到底生活于何样的世界，首先取决于这个人对这个世界的理解。现实生活中经历的每时每刻，都由两部分组成：主体和客体。面对完全一样的客体时，不同的主体意味着所构成的现实完全不同。PS： 大众，不分贵贱，都总是承认：众生能够得到的最大幸运，只有自身的个性。”—-歌德 第三段：对于人的快乐而言，主体远远来得比客体重要。而人的健康远远压倒一切外在的好处。为什么？一副健康、良好的体魄和由此带来的宁静和愉快的脾性，以及活跃、清晰、深刻、能够正确无误地把我事物的理解力，还有温和、节制有度的意欲以及由此产生的清白良心—-以上这些好处都是财富、地位所不能代替的。 第四段：对我们的生活幸福而言，我们的自身个性才是最重要和最关键的为什么？（1）我们的个性持久不变，它在任何情况下都发挥着作用。（2）第二、三项好处的保存只能听天由命，而自身个性却不会被剥夺。 第五段：由于自身个性对于生活幸福的重要性，所以我们唯一能做到的就是尽可能充分地利用我们既定的个性，循着符合我们个性的方向，努力争取适合个性的发展，除此之外则一概避免。（就是要选择与我们个性相匹配的地位、职业和生活方式） 第六段：虽然注重身体健康和发挥个人自身才能比全力投入获得财富更为明智，但不要错误理解为我们应该忽略获得我们的生活必需品（适当的财富）。不过，真正的财富（一般指多数的财富）对我们幸福的帮助并不大。 第七段：人的内在拥有对于人的幸福才是最关键的。而大多数不必与生活匮乏作斗争的人，在内在空虚、意识呆滞、思想贫乏的驱使下投入到社交娱乐当中。 第八段：另外两项（财富和他人看法）的重要性不需要强调，第二项是公认的。第三项分为名誉、名望、地位。每个人都可以争取得到名誉；社会地位只有服务国家政府的人才能染指；显赫的名望只有极少数人才会得到。另一方面，只有傻瓜才会把社会地位放置在财产之前。财产、名誉、声望是相互影响的关系。 第二章、人的自身第一段：自身的主要构成：健康的体魄、愉快的心情、良好的智力、高贵的品格。 第二段：人自身中最能带来幸福的是愉快的心情，而愉快心情就是从健康的身体里长出的花朵。保持身体健康的手段无非就是避免一切纵欲放荡的行为、令人不快和剧烈的情绪动荡，以及长时间紧张的精神劳累。最大的愚蠢就是为了金钱、晋升、学问、名声，甚至为了肉欲和其它片刻的欢娱而献出自己的健康。 第三段：愉快的心情不完全取决于健康的体魄，即使是有健康的体魄也会生成忧郁的心情。因为他们的感觉能力与新陈代谢的能力的比例不正常，天才常常忧郁正是因为有着超常的感觉能力。 第四段：出现不同情绪是因人有着不同的感受愉快或不愉快的能力，“郁闷”型的人虽然比“愉快”型的人少感受很多快乐，却规避了很多真实的不幸和苦难（因为他们遇事总考虑最不好的结果） 第五段：健康与美貌有着部分关联，良好的长相是一纸摊开的推荐书，它从一开始就为我们赢得了他人的心。 第六段：痛苦和无聊是人类幸福的两个死敌，我们的生活就是在这两者当中或强或弱的摇摆。这是因为痛苦和无聊存在双重的对立关系：一重是外在（客体）：生活的艰辛和匮乏产生的痛苦，丰裕和安定产生的无聊。另一重是内在（主体）：精神丰富的痛苦，精神迟钝的无聊。 第七段：人们辛苦挣来的闲暇，就是为了让人能够自由地享受意识和个性所带来的乐趣。而当闲暇来临时，凡夫俗子只关心如何去打发时间，而略具才华的人却考虑如何利用时间。为了应付无聊，人们就为意欲找出一些琐碎、微小、随意和暂时的动因，以图刺激意欲，并以此激活智力—-因为智力的任务本来就是理解、把握动因。但这些动因，较之于那些真正、自然的动因，犹如纸币比之于银元，因为前者的价值是带有随意性的；大部分游戏（纸牌）就属于前一类动因。没有游戏，他们便会摆弄手头的物品来帮助自己打发时间，雪茄就是这样的一件代替思考的物品。 第八段：如果一个人内在充足，丰富，不需要从自身之外寻求娱乐，那么，这个人就是一个最幸运的人。 无论身在何处，我们只能在我们自身寻找或者获得幸福。–《旅行者》 第九段：人的幸福全在于无拘束地施展人的突出才能。 第十段：人三种能力的发挥和活动构成了人的三人快乐的源泉： 吃喝、消化、休息和睡觉。（机体新陈代谢能力所带来的乐趣） 运动。（发挥肌肉力量所带来的乐趣） 观察、思考、感觉、阅读、默想、写作、学习、发明、演奏音乐和思考哲学（施展感觉能力方面的乐趣）感觉能力能带来的快乐远大于另外两种基本生理力量。 第十一段： 能够不受阻碍地培养、发挥一个人的突出才能，不管这种才能是什么，是为真正的幸福。 谁要是生来就具备、生来就注定要发挥某种才能，那他就会在发挥这种才能中找到最美好的人生。 PS：《叔本华论道德与自由》：叔本华认为，我们的任何行为都可以归结为一个动机。我们因为这个动机，从而做出了一个相应的行为。当我们做一件事的时候，我们意识到它符合我们的动机，从而领会到一种自由感，但我们的动机却只取决于某一意志，而这意志却不是我们所能把握的，也就是说我们可以体会到一种虚假的自由，却无法得到真正的自由。 第三章、人所拥有的财产第一段：伊比鸠鲁把人的需要分为三类： 第一类属于人的天然的和迫切的需要（食品、衣物） 第二类需要同样是天然的，但不是迫切的（性欲） 既不是天然的，也不是迫切的。（奢侈、排场、铺张和辉煌的追求） 第二段：一个人在拥有财产方面能否得到满足，由一个人所期待得到的财产和自己已经实际拥有的财产之间的关系决定。在我们心目范围之内的具体之物一旦出现，而我们又确信能够得到它，那我们就会感到幸福。但是如果得到这具体之物存在重重困难，他根本就没有得到它的希望和可能，那他就会感觉不幸和痛苦。财富犹如海水：一个人海水喝得越多，他就越感到口渴。这一道理同样适用于名声。我们在失去财富和安逸的处境以后，当我们挺住了最初的阵痛，我们惯常的心境与当初相比较，并没有发生很大的改变。这是因为当命运减少了我们的财富以后，我们自己也就相应降低了我们的要求。反过来，如果交到好运，我们的期望的压缩机就会把期望膨胀起来，我们在这过程中就感到快乐。但是，这一快乐并不会维持多久。当整个剁成全部完成以后，那扩大了的要求范围已经被我们习以为常了；并且，与新的要求相比较，我们就会对目前的拥有不以为然了。 第三段：我们之所以感到不满，原因就在于我们不断试图提高我们的要求，但同时，其它妨碍我们成功的条件因素却保持不变。 第四段：任何其它物品只能满足一个需要，而金钱能满足抽象中的普遍的多种需要。 第五段：我们应把现有的财富视为能够抵御众多可能发生的不幸和灾祸的城墙，而并不是一纸由我们寻欢作乐的许可证。以艺术为职业的人，应把应用天赋才能赚来的钱的大部分当作本金而不是利息，因为他们的才能总有枯竭的时候。以手工技术为职业的人，技术能使用的时间比较长，因此他们赚来的钱比较稳定。而商人则是使用钱来挣钱的人，他们会更好或者更精通如何使用钱。 第六段：以贫穷为现状的人，一旦获得巨额财富，会视之为身外之物，将财富享受和挥霍。 乞丐一旦跨上了坐骑，就非得把马跑死为止。—-《亨利五世》 第七段：上述的人如果是靠能力获得财富的，他对自己的运气和能力抱有过分的自信，而这个自信是在心里，而不是在脑子里。 一个习惯于处理钱财的有钱女人，会小心翼翼地花钱。但一个在结婚以后才首次获得支配金钱权力的女人，会在用钱的时候大胆妄为，她简直就是大肆挥霍。—-《约翰逊的一生》 第四章、人所展现的表象第一段：我们总是过分看重自己存在于他人心目中的样子，但他人的看法就其本身来说，对我们的幸福而言并非至关重要。太过重视他人的看法，就像把一个人的荣誉感建立在“被人夸奖就开心，被人轻视就痛苦”这种特殊的人性上，它会代替道德促使人做出良好的行为。但是对于人自身的幸福，这种荣誉感更多地产生扰乱和不良的作用。所以，从增进幸福的角度出发，我们应该抑制这一人性弱点。应该细致考虑和恰如其分地评估它的真正价值，尽量减低我们对待别人意见的敏感程度，不能称为他人看法和意见的奴隶。 使一个渴求赞语的人闷闷不乐或者兴高采烈的话语，却是多么的无足轻重！ “人的自身、人所拥有的财产”都在我们的头脑意识里发挥作用；而别人对我们的看法旨在别人的头脑意识中产生效果，它是附带种种概念性的东西呈现在别人头脑中的表象。了解这些之后，就可以逐渐对他人的评论泰然处之了。 第二段：这种把非直接为我们所存在的东西作为直接的存在来加以看重的愚蠢做法，人们称之为虚荣，以表示这种渴望、努力所具有的虚幻和空洞的本质。 第三段：隐居生活之所以对于我们的心绪宁静有一种特别良好的影响，其主要原因就在于我们不用生活在别人的视线里。 第四段：虚荣与骄傲的区别在于：骄傲就是确信自己拥有某一方面的突出价值，但虚荣则尽力让别人确信自己拥有某一方面的突出价值。骄傲是发自内在的、直接的自我敬重；而虚荣则是从外在、因而是间接地努力试图获得这一自我敬重。 第五段：如果我们善意地忽略自己的优点，在与他人的交往时也与他人一道错误地视自己与他人是一个样，那么他人就会公开坦白地把我们认定为就是这个样子。 “跟奴隶开玩笑，奴隶就会对你不屑” “你必须强迫自己接受应有的骄傲” 第六段：最廉价的骄傲就是民族的自豪感。 第七段：他人的看法可分为名誉、地位、名声。 第八段：地位、头衔的作用是要得到别人虚假的尊敬，对于增进个人幸福而言，用处不大。 第九段：客观上，名誉是他人对我们的价值的看法；主观上，则是我们对于他人看法的顾忌。 第十段：名誉感和羞耻感的来源：单独的人能够做的事寥寥可数，只有当他生活在与其他人所组成的群体里，他才能有所作为。人的意识得到了发展以后，才会认识到自己这种处境。一旦这样，他就会产生愿望，希望别人视他为人类社会中的一个有用成员，一个有能力履行自己的男人角色的人，并由此能有资格去分享社会所带来的好处。要成为这样的人，他必须首先做好每一个人都需要做好的事情；其次，他需要完成处于他那独特位置上人们所要求他和期望他做好的事。但同样，他很快就认识到问题的关键并不在于他认为自己是一个有用的人，而在于别人是否也这样认为。他要获取别人对自己良好看法的热切愿望，以及他对别人的看法的无比珍视，也就由此而来。这两者都源自人的这种内在感觉—-人们名之为“名誉感”，或者“羞耻感”，这根据情况而定。 未完待续… 第五章、建议和格言第一部分 泛论第一节第一段：理性的人追求的不是快乐，而是没有痛苦。（所有的快乐，其本质都是否定的，而痛苦的本质却是肯定的。）举例解释：1.身体只要有一处疼痛，人就会只关注疼痛的那一处，而不关心其它健康的部分。2.如果有一件事违反了我们的意愿，我们就会总惦记这件事，而不去关心其它如我们所愿发生了的事。从上述情况我们可以看到，意欲的满足总是否定的。意欲得到的满足并不直接被我们感受到，它顶多只以反省、回顾的方式进入我们的意识。但是，意欲受到的抑制却是肯定的。每一快感的产生其实就是意欲所受到的抑制得到了消除，意欲获得了解放。所以，每一种快感都持续相当短暂的时间。 快乐只不过是一场幻梦，但痛苦却是真实存在的。—-伏尔泰 生活并不是让我们享受的，我们必须忍受它和克服它。我们不应该以痛苦为代价去购买快乐，甚至只是冒着遭受痛苦的风险去这样做也不行，否则，我们就会为了那些否定、因而是虚幻的东西而付出了肯定和实在的东西。 第二部分 我们对待自己的态度第四节第一段：认识自己的第一步：了解清楚自己的首要和真正的意愿。应该大致明白自己应该从事何种职业、需要扮演何种角色以及自己与这一世界的关系。 第五节第一段：人生智慧的重要一点就是在关注现在和计划将来这两者之间达到恰到好处的平衡，这样，现在与将来才不至于互相干扰。现在才是唯一真实确切的。将来的发展几乎总是与我们设想的不同，甚至过去也与我们对过去的回想有所出入。 第二段：只能为肯定会发生的灾祸忧心，但这一类灾祸少之又少，因为将来的灾祸充其量是极可能发生或者肯定发生，但发生的事件是全然不确定的。为了保证我们的生活安宁不受影响，我们必须养成习惯，把并不肯定发生的灾祸视为永远不会发生，而并不肯定在某一时间发生的灾祸则肯定不会在很短时间内发生。 第三段：我们忘记了每一天的日子都是生命中不可缺少而又无法代替的，不要总觉得今天又将在明天重现。要珍惜每一刻可以忍受的现在，包括最平凡无奇、我们无动于衷地听任其逝去，甚至迫不及待地要打发掉的日子。 第六节第一段：所有的局限和节制都有助于增进我们的幸福。原因在于意欲受到的刺激越少，我们的痛苦也就越少。限制我们的活动范围就能消除刺激我们意欲的外在动因，而精神上的限制则可以消除内在的动因。但是精神上的制约会产生无聊，所以尽可能的外在限制能增进人们的幸福。（如果无法保证足够丰富的精神以对抗无聊的话） 第七节第一段：忙于外在生活会夺走精神生活所需要的宁静和专注，同样，持续从事精神活动会或多或少地削弱我们应付嘈杂、繁忙的现实生活的能力。所以，每过一段时间，当我们需要着力操持实际生活的首，暂时完全中断精神活动会有好处。 第八节第一段：要从生活经验中汲取一切有益的教训，我们就必须勤于反省，经常回顾做过的事情和曾经有过的感觉和体验；此外还要把我们以前对是事情的判断和现在的看法，以及订下的计划及追求和最终得到的结果及满足相互比较。一个人的生活犹如书的正文，对生活经历的咀嚼和认识则是对正文做出的解释。当时发生的事情，过后可能会忘记并难以回想起来，所以对于值得回忆的时刻，要小心保存。（比如日记） 第九节第一段：幸福属于那些容易感到满足的人，原因如下：（1）人除了依靠自身以外，无法有把握地依靠别人。（2）社会给人所带来的困难和不便、烦恼和危险难以盛数、无法避免。 第二段：获取幸福的错误方法莫过于追求花天酒地的生活，原因如下：（1）我们企图把悲惨的人生变成接连不断的快感、欢乐和享受。这样，幻灭感就会接踵而至。 第三段：社会一旦变得人多势众，平庸就会把持统治地位。 第十七段：学会在人群中保持一定程度的孤独。 第十节第一段：嫉妒是破坏幸福的敌人，我们应该多想想那些处境比我们更为恶劣的人，因为那些生活得比我们好的人只是看上去比我们更好而已。 第十一节第一段：实施某一计划前，要对其深思熟虑，但是一旦开始执行，就静待结果，不要不断回头考虑已经在做的事和的担忧可能遇到的危险。 第十二节第一段：对于已经发生、不可更改的不幸时，要看开。 第十四节第一段：相比于感慨没得到想要的东西，可以多想想已有的东西失去后，我们将会怎样看待那失去之物。 第十五节第一段：做事要一件一件做。 第十七节第一段：生命在于运动。（找一样符合自己个性的才能，然后不断学习） 第十八节第一段：我们行动和努力的指南不可以是想象中的图像，而应该是考虑清楚的概念。（不能为了想象中的东西而行动，而应该考虑实际状况所呈现出来的概念）教育就是让我们只信赖概念，而进行教育时的图像只是起到辅助性的作用。 第十九节第一段：补充第十八节内容，我们应该时刻驾驭我们对眼前现实的印象和直观认识。如果我们无法纯粹通过思想消除某一印象影响的时候，最好的办法就是运用相反的印象以中和它的作用。（忘不了不喜欢你的女生的话，可以想想其他可爱的女生，哈哈哈）]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>人生的智慧</tag>
        <tag>叔本华</tag>
        <tag>哲学</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[粗糙度研究现状]]></title>
    <url>%2F2019%2F04%2F06%2F%E7%B2%97%E7%B3%99%E5%BA%A6%E7%A0%94%E7%A9%B6%E7%8E%B0%E7%8A%B6%2F</url>
    <content type="text"><![CDATA[一、起源Patton（1966）用模型试验证实了规则突起岩体符合某个强度准则。 由于实际结构面大多数凹凸不平，起伏角变化较大，而且研究表明Patton起伏角在不同正应力下力学效应不同，于是 Barton提出了新的不规则岩体结构面抗剪强度经验公式，公式中JRC的量测比较困难和复杂。 二、现有确定JRC的方法 Barton标准剖面法 优点：ISRM采用，简单省时不用计算 缺点：精度不高误差大，近年已很少使用 直接测量法（结构面起伏角可通过比较七剖面的全迹长和直线迹长得到） 优点：较Barton法精度有所提高 缺点：真实的全迹长确定较为困难，即使是同一剖面每次量测结果亦均不相同。选择剖面较多，工作量大，并要动用复杂仪器。 表面粗糙参数法 优点：量测过程精度高 缺点：对仪器要求严格，工作量大，若非自动连续记录仪器量测则可导致较大误差，使精度下降。 伸长率法 优点：精度较高 缺点：物理意义不明确，精度和可靠性还有待理论上论证和时间经验积累 幅度法 优点：简单省时 缺点：仅考虑结构面最大起伏幅度是相对结构面长度而言的，没有考虑较小突起体对JRC的贡献，因此精度变化较大。 分形维数法 优点：有良好的理论基础和较高的精度，目前较为完善的方法之一。 三、粗糙度分形维数法进展早期由于设备限制，主要集中于 3.1 节理轮廓线的分形描述，主要获取方法有 针状轮廓尺法，简易纵剖面仪法，RSP-I型智能岩石表面形貌仪法，接触打孔器法，阴影轮廓线法。 近年来，随着设备推陈出新，结构面三维形貌数据较容易获得，主要获取设备有 3D型便携式岩石三位表面形貌仪，三维激光扫描岩石表面仪。 3.2 结构面的分形描述3.2.1 间接描述采用节理轮廓线分维数加1或计算结构面上一条或多条节理轮廓线的自仿射分形的Hurst指数H，然后根据D=3-H获得结构面分形维数。3.2.2 直接量测三角形棱柱表面积法投影覆盖法立方体覆盖法 四、结构面的多重分形描述五、粗糙度表征方案备选石林-3D岩体结构面粗糙度表征方法优点：1.测量便捷，能快速获取现场结构面的形态特征，且计算出的粗糙度具有精确度和可靠度；2.是一种3D角度的评价方法，更全面地考虑结构面的特征，综合反映结构面形态；3.能够反映结构面粗糙度的各向异性、尺寸效应和间距效应这三个影响因素。4.没有复杂的计算过程，具有操作简单便于推广的优点。缺点：尚未建立面积拓展率S和结构面起伏度Rs与岩体结构面抗剪强度的关系。 方法的由来：伸长率：1.伸长率法既考虑了节理相对长度，也考虑了节理剖面起伏变化的因素，而幅度法只考虑了最大的起伏幅度，没有考虑较小的起伏幅度对抗剪强度的影响。2.用伸长率确定节理粗糙度系数的精度主要取决于测量仪器的精度（现在有三维激光扫描仪能保证精度） 直边法和修正直边法：1.岩体结构面表面形态具有各质异性、各向异性和非均一性，定向统计测量方法是保证JRC测量精度的基本方法。2.直边法具有明确的物理意义，有精度保证、测速快、操作简便等优点。修正直边法是Barton直边法的扩充，具有比直边法更强的普适性。3.修正直边法的数学表达式包容了JRC的尺寸效应规律，配合计算机使用，适用于岩体结构面JRC的统计测量。#各质异性：成因、类型和规模相同的同一组结构面，由于所处岩石性质不同，结构面的表面形态和JRC存在明显差异。各向异性：成因、类型和规模相同的同一组结构面，即使处于同一岩石中，结构面的表面形态和粗糙度系数JRC也会因为岩石介质的各向异性，结构面形成时应力环境的各项异性而呈现各项异性。非均一性：处于同一岩石中的同一组结构面，即使沿同一方向进行量测时，各测量段的表面形态和粗糙度系数JRC也存在差异。 上述方法的缺点：伸长率法虽全面考虑了结构面剖面轮廓曲线的结构特征，但是没有区分大小起伏度在影响抗剪效果时的主次权重；而直边法（修正直边法）仅考虑了大的结构起伏对结构面抗剪强度的影响，忽略了小结构起伏对抗剪强度的影响作用。因此，单独使用这2种方法不能确保JRC取值的精确度和可靠度. 李化等将伸长率R和轮廓曲线的相对起伏度Ra两个指标结合起来，让2种方法得到互补，提出了更精确的计算方法. 该方法不仅考虑了结构面大的结构起伏对结构面抗剪强度的影响，同时也考虑了较小结构起伏对抗剪强度的影响，并区分了两者的影响权重，具有较高的精确性和可靠性。 对某一确定的结构面来说，面积扩展率S是一个定值，该参数可以反映结构面粗糙度的尺寸效应和间距效应，但不能反映各向异性。而相对起伏度Ra则可以很好地反映出各向异性，在沿不同剪切方向上具有不同的剖面轮廓曲线，因此该参数可以作为体现结构面粗糙度具有各向异性的指标。从描述结构面粗糙度的特征上来说，相对起伏度Ra弥补了面积扩展率S的不足，这2个参数结合描述结构面的粗糙程度具有可行性. 六、粗糙度问题 劈裂和直剪试试验得到的裂缝粗糙度差别大概在6~12之间，粗糙度正常范围在0~20值得注意的是，在目前的试验研究中，绝大多数采用劈裂或直剪方式形成岩样试验裂缝，以模拟张性裂缝或剪切裂缝。然而，对于同一岩性的岩石而言，劈裂或直剪所得到的裂隙的起伏粗糙程度差别不大，难以得到各种粗糙度的裂隙。郑少河等[9]所制试件的JRC=6～12。由于现场采取的裂隙和人工劈裂或直剪得到的裂隙仅能反映某种或某几种特定粗糙度的裂隙，这些试验结果因而难以完全反映实际裂隙的水力特性，在实际工程的应用中存在一定的局限性。（不同节理粗糙度系数单裂隙渗流特性试验研究） 七、论文依据收集 单一裂隙是构成网络裂隙的基本单元，裂隙的隙宽、粗糙起伏程度等几何参数是影响裂隙内流体流动的主要因素。（岩体裂隙面粗糙度对其渗流特性的影响研究） 粗糙裂隙渗流的数值模拟方法（岩体裂隙面粗糙度对其渗流特性的影响研究_王志良） 微观解释粗糙度。（单裂隙砂岩渗流特性实验研究_王来贵） 结构面的起伏形态对结构面的抗剪强度有直接的影响，张开度对岩体的渗流性质影响很大，所以，在结构面表征中应该对结构面的起伏形态和张开度进行研究，它对结构面的力学特性有直接的关系。（节理岩体结构面空间表征及其模型优化） 结构面的表面形态是结构面表面空间展布的几何属性，结构面的表面形态可按规模大小分为起伏度和粗糙度，起伏度表征大规模的起伏，粗糙度表征小规模的不规则凹凸点，天然结构面的表面形态是起伏度和粗糙度的不同组合。（节理岩体结构面空间表征及其模型优化） 八、裂隙面构造方法3D打印不同粗糙度的裂隙板，结合PVC管组成浇筑磨具。 九、IDEA JRC配合微观图像表征粗糙度]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>粗糙度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[会议拍摄技巧]]></title>
    <url>%2F2019%2F04%2F04%2F%E4%BC%9A%E8%AE%AE%E6%8B%8D%E6%91%84%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[一、空场景 会议现场大场景：光线明亮，场内无闲杂人等，干净整洁。场景带有会议主题和LOGO 局部场景：签到带礼仪（显得准备充分） 二、会议流程拍摄 舞台大景：左中右三个角度拍摄，需要一张包括所有领导的主席台照片/外加领导发言的特写/再拍一张台下参与者的大场景 观众大景：高角度俯视拍摄观众全景，微俯视角度将每个代表座位拍出来 三、特写 演讲嘉宾45°特写，正面特写以及带LOGO进入画面，拍摄嘉宾要突出，主体占三分之二，虚化占三分之一 观众中景：认真聆听领导讲话，鼓掌点头 合影：顺光]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019聚餐]]></title>
    <url>%2F2019%2F04%2F03%2F2019%E8%81%9A%E9%A4%90%2F</url>
    <content type="text"><![CDATA[0131 去姐夫家和姐夫吃夜宵喝酒 0217 去李锡鹏家吃饭 0219 阿冰哥和姐夫请我吃赣湘楼 0219 和妈妈吃烤海鲜 0222 XP、罗新食尚 0224 返校6人聚餐（鸡公煲） 0226 9人新食尚聚餐 0304 勇哥来我这做菜（腊肠）不要再喝牛栏山了 0309 去华科大西路吃烧烤，肉串的味道比小堕好点。 0320 北阶一家还不错的菜馆，有卖烤鱼，喝了啤酒，感觉并不好喝。 0322 学工组聚餐，口味堂，有点贵啊，今天主要吃的菜，口味鱼头200+接近300，菠菜面，红豆紫薯汁、牛蛙（平锅小美蛙）、饼（包紫薯还是什么来着）、口味粉蒸排骨、三峡石烤馍、虾仁水蒸蛋（因为没有公勺，所以我尽量挖边边的部分）千层扣肉（挺好吃的，一点都不辣，感觉不像是湖南菜啊，听老师们的说话好像这是湖南菜的餐厅） 0325 罗带腊肉来我这做，外加XP、勇哥的四个人小聚（感谢罗带的肉，碗还是罗洗的，优秀） 0325 中午和博、XP在教育食堂吃的，千张肉丝，香焖土鸡，干煸四季豆，家常豆腐都挺好吃的，天予推荐的，不错不错 0331 和孙技星一起吃老街烧烤。 0401 南门天天烧烤（XP请的） 0402 教育食堂（博请的，天予） 0403 教育食堂（我请的，XP） 0407 161聚餐（猪脚，花甲，大盘鸡，鱼块，黄瓜，藕菜，花生） 0410 鸡公煲（我，XP，罗）]]></content>
      <categories>
        <category>自律即自由</category>
      </categories>
      <tags>
        <tag>聚餐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年4月考核]]></title>
    <url>%2F2019%2F04%2F03%2F2019%E5%B9%B44%E6%9C%88%E8%80%83%E6%A0%B8%2F</url>
    <content type="text"><![CDATA[第一周（0401-0407）0401 周一 科研 晚上看了粗糙度的文献，没什么收获 读博 今天做了写高数题 环境 其它 0402 周二 科研 读博 莫烦Python基础完成；莫烦Numpy和Pandas开始 环境 其它 爱，死亡与机器人看完，只留下喜欢的几集，zima blue挺有共鸣。 0403 周三 科研 读博 莫烦python看到numpy的基本运算2 环境 其它 《快速使用Hexo搭建个人博客》学到11集（markdown基本语法）；看完crash course:study skills并在Hexo做了笔记。 0404 周四 科研 读博 莫烦python看到numpy的合并 环境 参加张国旗清明纪念仪式；张老师指导拍摄技巧 其它 Hexo搭建博客学习完毕； 0405 周五 科研 读博 莫烦numpy和Pandas数据处理完毕 环境 其它 0406 周六 科研 大致了解粗糙度研究现状，并做了一定整理，发布在博客上 读博 环境 其它 开始学素描，卡在色阶和正方体的明暗上，估计是笔的原因 0407 周日 科研 素描（画方体） 读博 环境 其它 161聚餐 04月第一周考核工作：1.Python、Numpy、Pandas的基础操作(还不熟练，需要多加练习)2.粗糙度研究现状的整理(只有框架，没有深入探究)3.Hexo博客搭建完毕并开始使用（之后慢慢完善）4.学习crash course:study skills（慢慢会应用上）5.开始学素描（之后会把学习的结果发到博客）6.做了少量高数题7.环境工作：参加张国旗清明纪念仪式；张老师指导拍摄技巧 娱乐:1.看完《爱、死亡与机器人》（最喜欢zima blue，大部分也都挺好看）2.161聚餐 总结：优点：工作内容较多，娱乐时间控制较好。缺点：工作中的知识掌握得不够；工作内容没有符合现阶段的重点；缺少与家人的交流； 第二周（0408-0414）0408 周一 科研 晚上看了粗糙度的文献（有眉目，但还是乱） 读博 环境 听十佳标兵试汇报；整理部分发展报告 其它 0409 周二 科研 晚上看了粗糙度的文献，整理了一下，但是没什么思路 读博 环境 发展报告除了奖学金分布，其它都过了一遍，剩下的等周四助管整理完再继续。 其它 重新开始看《人生的智慧》，对“意欲”这个词有了更清晰的认识；重看了木鱼水心解说的红楼梦P5，慢慢觉得《红楼梦》蛮有意思的，有时间可以看看原著。 状态 中午加班了一会，下午回办公室后继续看文献，快晚上时脑袋思维有点停滞了，中午估计还是要休息会，不能一直持续工作。 0410 周三 科研 读博 环境 例会；发展报告整理；互联网+申报数量通知 其它 看了陈果的《爱情课》（大多数还是蛮认同的） 状态 下午本想好好睡一觉，结果还是因为环境的事被叫过去了，所以有点小烦，再加上被陈果的《爱情课》吸引，今天都没做太多事。 0411 周四 科研 读博 环境 助管的统计已经完毕； 其它 看了木鱼的《权力的游戏》第七季微剧场；看了《人生的智慧》 状态 最近正事越拖越多，到现在有点小心烦，明天还是要赶紧把该做的事都做完。 0412 周五 科研 修改了一会循环论文； 读博 环境 例会记录整理完；参加新疆克州招聘活动； 其它 整理《人生的智慧》人的自身、人的财富部分，并出图上传至Hexo； 状态 今天整体状态不错，心态挺好，情绪也挺愉快，就是正事干得有点少，明天要继续加油。]]></content>
      <categories>
        <category>自律即自由</category>
      </categories>
      <tags>
        <tag>2019</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B站Hexo博客搭建的个人博客]]></title>
    <url>%2F2019%2F04%2F03%2FB%E7%AB%99Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一、主题安装Git安装然后更改_config.yml中的theme。 二、主题语言修改更改_config.yml中language(zh-CN) 三、增加标签页和分类页next主题文件夹中的_config.yml（与上述不是同一个文件）中搜索menu，找到#categories、#tags，去掉前面的#号，保存，更新。 四、正确打开标签页和分类页12$ hexo n page tags //创建标签页$ hexo n page categories //创建分类页 五、主题样式更改next文件夹中_config.yml中搜索scheme,增删#进行更改 六、更改头像next文件夹中_config.yml中搜索avatar中url:/images/avatar.gif，改成想要的图片(图片要提前存入相应的文件夹) 七、更改标题、作者以及链接在_config.yml中搜索author，对title、author、url进行修改。 八、启用侧边栏社交链接next中的_config.yml搜索social进行修改 九、启用友情链接next中的_config.yml搜索links，找到links： Title:…进行更改 十、新建一篇文章tags: - 标签名1 - 标签名2 categories: 分类名 十一、Markdown基本语法见博客中《markdown基本语法》 十二、开启打赏功能next–_fonfig.yml–搜”reward” 十三、开启订阅公众号next–_config.yml–搜”sub” 十四、设置头像为圆形可旋转视频 十五、首页文章设置阅读全文next–_config.yml–搜“auto”/&lt; !– more – &gt; 十六、添加动态背景next–_config.yml–搜”Canvas” 十七、给博客添加fork Github百度“Github corners”找到喜欢的复制，然后在next/layout/_layout.swig中的1&lt;dir class=&quot;headband&quot;&gt;&lt;/dir&gt;dir&gt; 后另起一行，粘贴，并修改1&lt;a = href=&quot;...&quot;&gt; // &quot;...&quot;为你的github网址 十九、修改文章底部带#的标签next/layout/_macro/post.swig找到….rel = “tags”&gt; # … #改成1&lt;i class = &quot;...&quot; &gt;&lt;/i&gt; 二十、增加搜索功能next/_config.yml 二十三、增加搜索功能官方文档–第三方服务–搜索–local search 二十四、增加不蒜子统计功能next/_config.yml搜“busuanzi” 二十五、增加分享内容（没找到对应内容）二十八、隐藏底部的强力驱动next/layout/_partias/footer.swig 三十、hexo博客部署到远端的githubgithub先创建仓库 – git init（博客文件夹）– npm install hexo-deployer-git – –save – hexo d PS:部分视频没有看，有需要再去看。]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown基本语法]]></title>
    <url>%2F2019%2F04%2F03%2Fmarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一级标题二级标题三级标题四级标题五级标题六级标题 列表1 列表2 子列表2.1 子列表2.2 列表3 Jetzilch的Github 斜线字体字体加粗 单行代码块 12多行代码块1多行代码块2 这部分内容是引用的，主要以原作者的内容为主。 加一条横线（视频演示的是虚的，但是这里显示的就是实的了。。。）加一条横虚线]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Crash Course:Study Skills]]></title>
    <url>%2F2019%2F04%2F03%2FCrash-Course-Study-Skills%2F</url>
    <content type="text"><![CDATA[一、笔记载体和笔记方法的选择1.1 笔记载体：Paper√/Computer原因：Paper虽然记录速度慢，但不容易分心，且能提供更多的思考空间。1.2 笔记方法：大纲法/康奈尔法/思维导图 根据实际情况选择1.3 如何记笔记：如何划重点? 摩斯电码法（觉得是重点在段落旁边画·，之后有对这个重点解释证明阐述的，在段落旁边画-） 二、阅读方法（1）现有的研究证明速读是不可能的，或者说是没有效果的。（2）不要抑制默读，抑制默读影响思考。（3）阅读顺序：浏览-问题-阅读-复述/做题/总结（4）最好的阅读法：SCAR（Stop Complaining And Reading） 三、记忆（1）记忆需要间隔。（2）适度难度原则：回忆起越难想起的记忆，记忆的效果越好，但是如果刻意延长回忆时间可能造成无法回忆起记忆而导致记忆丢失。可以使用莱特纳系统进行复习，即找到5个盒子，分别为隔1，3，5，7，考试前五个时间，学习的知识依照时间长短放入各个盒子，然后根据盒子的天数进行复习。类似的手机软件有Anki。（3）要多使用主动记忆（回忆：未见到知识而回忆起知识）而避免被动记忆（再认：见到笔记后再回想起知识）。被动记忆更适合用于设置小测验（根据笔记出题检测自己） 四、计划与整理要形成一个系统：（1）任务管理器：Evernote（2）如何整理笔记。之前的笔记可能比较散乱，要找出时间进行整理，关于知识的整理可以像这样发布在Hexo上。（3）保证笔记都有物理存储方式（每天的笔记很散乱，最好有一个物理载体能把它们归类到一起，比如一个文件盒，我暂时想到的是买散页纸的包装带，或者找文件夹）（4）开发方案，也就是制定计划（我的理解是每天和每周都做总结，就像兼辅考核表一样） 五、注意力与集中（1）注意力随时间递减（2）一般工作25~30分钟，要休息几分钟，但不要做分散注意力的事。（3）注意力与健康有关，养成好习惯（睡眠7hours，每天锻炼）（4）注意力与环境有关，尽量给自己找一个不受干扰的好环境。 六、文章与写作（对应视频第9集）（1）先进行“前写作”（针对已有的结果进行粗糙的写作）（2）带着上一版的问题定向找资源，并记录资源的量，够用就行。（3）开始写作，但不要带有完美主义。（4）修改论文时先看框架，再看语句。改完后可以大声朗读/打印出来进行修改，效果比较好。]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫烦Numpy和Pandas数据处理教程]]></title>
    <url>%2F2019%2F04%2F02%2F%E8%8E%AB%E7%83%A6Numpy%E5%92%8CPandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Numpy一、Numpy的属性12345678import numpy as nparray = np.array([[1,2,3],[2,3,4]])print(array)print(&apos;number of dim:&apos;,array.ndim) #维度print(&apos;shape:&apos;,array.shape) #几行几列print(&apos;size:&apos;,array.size) #几个元素 二、Numpy创建Array五、Numpy的索引1234import numpy as npA = np.arange(3,15)print(A) #[3 4 5 6 7 8 9 10 11 12 13 14]print(A[3]) #6 矩阵换成二维的1234567891011121314151617181920212223import numpy as npA = np.arange(3,15).reshape((3,4))print(A) #[[3 4 5 6] [7 8 9 10] [11 12 13 14]]print(A[2]) #[11 12 13 14]print(A[1][1]) #8 print(A[1,1]) #8 与上述效果一样print(A[:,1]) #第2列的所有数print(A[1,:]) #第2行的所有数print(A[1,1:2]) #[8]print(A[1,1:3]) #[8,9]for row in A: print(row) #按行输出for column in A.T: print(column) #按列输出print(A.flatten()) #把矩阵变成一维for item in A.flat: print(item) #flat和flatten()功能一样，返回值不一样。返回一维矩阵用flatten(),flat是迭代器，返回的是一串类似地址值的值 三、Numpy的Array合并合并12345678910import numpy as npA = np.array([1,1,1])B = np.array([2,2,2])print(np.vstack(A,B)) #vertical stack 上下合并# [1,1,1] [2,2,2]print(np.hstack(A,B)) #horizontal stack 左右合并# [1,1,1,2,2,2] 增加维度123456print(A[:,np.newaxis]) #增加列维度# [[1] [1] [1]]print(A[np.newaxis,:]) #增加行维度# [[1,1,1]] 例子：123456789A = np.array([1,1,1])[:,np.newaxis]B = np.array([2,2,2])[:,np.newaxis]C = np.hstack(A,B)print(C)# [1,2] [1,2] [1,2]print(A.shape,C.shape)# (3,1) (3,2) 多个Array合并123456789101112131415161718C = np.concatenate((A,B,B,A)，axis=0) # vstack和hstack都可以进行多个Array合并，# concatenate的不同在于可以在后面指定合并的方向。# 0为上下合并，1为水平合并print(C)#[[1] [1] [1] [2] [2] [2] [2] [2] [2] [1] [1] [1]] 四、Numpy的分割先生成一个array：12345678910111213141516171819import numpy as npA = np.arange(12).reshape((3,4))print(A)# [[0,1,2][3,4,5][6,7,8][9,10,11]]print(np.split(A,2,axis=1))#1是上下分开，0是左右分开# [array([[0,1], [4,5], [8,9]]), array([[2,3], [6,7], [10,11]])] split只能进行相同分割，进行不相等分割要使用array_split123456789101112print(np.array_split(A,3,axis=1))#[array([[0,1], [4,5], [8,9]]), array([[2], [6], [10]]) array([[3], [7], [11]])] 相对于合并，分割也有vsplit和hsplit123456789101112print(np.vsplit(A,3))#[array([[0,1,2,3]])],[array([[4,5,6,7]])],[array([[8,9,10,11]])]print(np.hsplit(A,2))#[array([[0,1], [4,5], [8,9]]), array([[2,3], [6,7], [10,11]])] 五、Numpy的copy和deep copy12345678910111213141516import numpy as npa = np.arange(4)b = ac = ad = ba[0] = 11 #默认格式是整数# 此时a,b,c,d都会改变，因为python中这种赋值方式下a,b,c,d是完全一样的d[1:3] = [22,33]# 此时a,b.c,d也会全部发生改变b = a.copy() #deep copya[3] = 44#a = [11,22,33,44]b = [11,22,33,3]deep copy后,a变化不会使b变化 Pandas一、Pandas的基本介绍Series123456789101112import pandas as pdimport numpy as nps = pd.Series([1,3,6,np.nan,44,1])print(s)#0 1.01 3.02 6.03 NaN4 44.05 1.0dtype: float64 DataFrame1234567891011121314151617dates = pd.date_range(&apos;20160101&apos;,periods=6)print(dates)# 先生成一个索引DatetimeIndex([&apos;2016-01-01&apos;, &apos;2016-01-02&apos;, &apos;2016-01-03&apos;, &apos;2016-01-04&apos;, &apos;2016-01-05&apos;, &apos;2016-01-06&apos;], dtype=&apos;datetime64[ns]&apos;, freq=&apos;D&apos;)df = pd.DataFrame(np.random.randn(6,4),index=dates,columns=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])print(df)# 生成DataFrame a b c d2016-01-01 0.545643 2.021614 1.210559 0.4678342016-01-02 0.666108 0.419161 -1.943871 -0.9532632016-01-03 -0.759923 -0.337458 -1.865560 0.3280372016-01-04 0.198904 0.880258 -1.369046 0.8859452016-01-05 -0.828801 -0.602095 -0.897741 0.1682772016-01-06 0.937178 -0.593869 0.043363 -0.273371 没有索引生成DataFrame1234567df1 = pd.DataFrame(np.random.randn(3,4))print(df1)# 0 1 2 30 0.378297 -0.354029 0.407989 -0.0678381 -1.210963 2.706774 0.875143 0.3606812 -0.964372 0.919133 0.768482 0.221687 按索引排序123456789df1 = pd.DataFrame(np.arange(12).reshape((3,4)))print(df1)print(df1.sort_index(axis=0,ascending=False)) # 0 1 2 32 8 9 10 111 4 5 6 70 0 1 2 3 按值排序123456print(df1.sort_values(by=2))# 0 1 2 30 0 1 2 31 4 5 6 72 8 9 10 11 二、选择数据先生成一个DataFrame1234567891011121314151617181920212223242526272829303132333435363738394041424344import pandas as pdimport numpy as npdates = pd.date_range(&apos;20130101&apos;,periods=6)df = pd.DataFrame(np.arange(24).reshape((6,4)),index=dates,columns=[&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;])print(df)print(df[&apos;A&apos;])print(df.A)# A B C D2013-01-01 0 1 2 32013-01-02 4 5 6 72013-01-03 8 9 10 112013-01-04 12 13 14 152013-01-05 16 17 18 192013-01-06 20 21 22 232013-01-01 02013-01-02 42013-01-03 82013-01-04 122013-01-05 162013-01-06 20Freq: D, Name: A, dtype: int322013-01-01 02013-01-02 42013-01-03 82013-01-04 122013-01-05 162013-01-06 20Freq: D, Name: A, dtype: int32print(df[0:3])print(df[&apos;20130102&apos;:&apos;20130104&apos;])# A B C D2013-01-01 0 1 2 32013-01-02 4 5 6 72013-01-03 8 9 10 11 A B C D2013-01-02 4 5 6 72013-01-03 8 9 10 112013-01-04 12 13 14 15 从标签来选择1234567print(df.loc[&apos;20130102&apos;])#A 4B 5C 6D 7Name: 2013-01-02 00:00:00, dtype: int32 从列标签中选择，并输出所有行结果1234567891011121314151617print(df.loc[:,[&apos;A&apos;,&apos;B&apos;]])# A B2013-01-01 0 12013-01-02 4 52013-01-03 8 92013-01-04 12 132013-01-05 16 172013-01-06 20 21print(df.loc[&apos;20130102&apos;:,[&apos;A&apos;,&apos;B&apos;]]) A B2013-01-02 4 52013-01-03 8 92013-01-04 12 132013-01-05 16 172013-01-06 20 21 从位置选择123456789101112131415161718192021222324print(df.iloc[3]) #第4行的数据#A 12B 13C 14D 15Name: 2013-01-04 00:00:00, dtype: int32print(df.iloc[3，1]) #第4行第2个数据#13print(df.iloc[3:5，1:3]) #第4行到第6行，第2位到第4位# B C2013-01-04 13 142013-01-05 17 18print(df.iloc[[1,3,5],1:3]) #第2，4，6行...# B C2013-01-02 5 62013-01-04 13 142013-01-06 21 22 混合选择123456print(df.ix[:3,[&apos;A&apos;,&apos;C&apos;]])# A C2013-01-01 0 22013-01-02 4 62013-01-03 8 10 其它1234567891011121314print(df)print(df[df.A&gt;8])# A B C D2013-01-01 0 1 2 32013-01-02 4 5 6 72013-01-03 8 9 10 112013-01-04 12 13 14 152013-01-05 16 17 18 192013-01-06 20 21 22 23 A B C D2013-01-04 12 13 14 152013-01-05 16 17 18 192013-01-06 20 21 22 23 三、Pandas设置值先生成一个DataFrame123456789101112131415161718192021222324252627282930313233343536373839dates = pd.date_range(&apos;20130101&apos;,periods=6)df = pd.DataFrame(np.arange(24).reshape((6,4)),index=dates,columns=[&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;])# A B C D2013-01-01 0 1 2 32013-01-02 4 5 6 72013-01-03 8 9 10 112013-01-04 12 13 14 152013-01-05 16 17 18 192013-01-06 20 21 22 23df.iloc[2,2] = 1111print(df)# A B C D2013-01-01 0 1 2 32013-01-02 4 5 6 72013-01-03 8 9 10 112013-01-04 12 13 14 152013-01-05 16 17 18 192013-01-06 20 21 22 23 A B C D2013-01-01 0 1 2 32013-01-02 4 5 6 72013-01-03 8 9 1111 112013-01-04 12 13 14 152013-01-05 16 17 18 192013-01-06 20 21 22 23df.loc[&apos;20130101&apos;,&apos;A&apos;] = 2222print(df)# A B C D2013-01-01 2222 1 2 32013-01-02 4 5 6 72013-01-03 8 9 1111 112013-01-04 12 13 14 152013-01-05 16 17 18 192013-01-06 20 21 22 23 另一种设置值的方法123456789101112131415161718192021df[df.A&gt;4] = 0print(df)# A B C D2013-01-01 0 1 2 32013-01-02 4 5 6 72013-01-03 0 0 0 02013-01-04 0 0 0 02013-01-05 0 0 0 02013-01-06 0 0 0 0df.A[df.A&gt;4] = 0print(df)# A B C D2013-01-01 0 1 2 32013-01-02 4 5 6 72013-01-03 0 9 10 112013-01-04 0 13 14 152013-01-05 0 17 18 192013-01-06 0 21 22 23 加一列123456789101112131415161718192021df[&apos;F&apos;] = np.nanprint(df)# A B C D F2013-01-01 0 1 2 3 NaN2013-01-02 4 5 6 7 NaN2013-01-03 8 9 10 11 NaN2013-01-04 12 13 14 15 NaN2013-01-05 16 17 18 19 NaN2013-01-06 20 21 22 23 NaNdf[&apos;E&apos;] = pd.Series([1,2,3,4,5,6],index=pd.date_range(&apos;20130101&apos;,periods=6))print(df)# A B C D E2013-01-01 0 1 2 3 12013-01-02 4 5 6 7 22013-01-03 8 9 10 11 32013-01-04 12 13 14 15 42013-01-05 16 17 18 19 52013-01-06 20 21 22 23 6 四、Pandas处理异常数据生成一个带有Nan的DataFrame12345678910111213141516171819202122232425import pandas as pdimport numpy as npdates = pd.date_range(&apos;20130101&apos;,periods=6)df = pd.DataFrame(np.arange(24).reshape((6,4)),index=dates,columns=[&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;])df.iloc[0,1] = np.nandf.iloc[1,2] = np.nanprint(df)# A B C D2013-01-01 0 NaN 2.0 32013-01-02 4 5.0 NaN 72013-01-03 8 9.0 10.0 112013-01-04 12 13.0 14.0 152013-01-05 16 17.0 18.0 192013-01-06 20 21.0 22.0 23print(df.dropna(axis=0,how=&apos;any&apos;))# A B C D2013-01-03 8 9.0 10.0 112013-01-04 12 13.0 14.0 152013-01-05 16 17.0 18.0 192013-01-06 20 21.0 22.0 23 丢掉带有数据的行或列12345678910111213141516171819print(df.dropna(axis=0,how=&apos;any&apos;)) #丢掉行# A B C D2013-01-03 8 9.0 10.0 112013-01-04 12 13.0 14.0 152013-01-05 16 17.0 18.0 192013-01-06 20 21.0 22.0 23print(df.dropna(axis=1,how=&apos;any&apos;)) #丢掉列# A D2013-01-01 0 32013-01-02 4 72013-01-03 8 112013-01-04 12 152013-01-05 16 192013-01-06 20 23print(df.dropna(axis=0,how=&apos;all&apos;)) #行或列全是Nan才删除 将没有填的空，填上数据123456789print(df.fillna(value=0))# A B C D2013-01-01 0 0.0 2.0 32013-01-02 4 5.0 0.0 72013-01-03 8 9.0 10.0 112013-01-04 12 13.0 14.0 152013-01-05 16 17.0 18.0 192013-01-06 20 21.0 22.0 23 判断整个表格中数据是否存在123456789print(df.isnull())# A B C D2013-01-01 False True False False2013-01-02 False False True False2013-01-03 False False False False2013-01-04 False False False False2013-01-05 False False False False2013-01-06 False False False False 数据太多，没办法每行每列找，可以用下列方法123print(np.any(pd.isnull()) == True)#True 五、Pandas导入导出导入表格12345678910111213141516import pandas as pdimport numpy as npdata = pd.read_csv(&apos;C:/Users/zz/Desktop/Python training/1.csv&apos;)print(data)# Student ID Name Gender Language0 1 A male C1 2 B female E2 3 C male A3 4 D female C4 5 E male E5 6 F male A6 7 G female A7 8 H female E8 9 I female C 导出表格1data.to_pickle(&apos;2.pickle&apos;) 六、Pandas合并 concate生成三个DataFrame12345678910111213141516171819202122import pandas as pdimport numpy as npdf1 =pd.DataFrame(np.ones((3,4))*0,columns=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])df2 =pd.DataFrame(np.ones((3,4))*1,columns=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])df3 =pd.DataFrame(np.ones((3,4))*2,columns=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])print(df1)print(df2)print(df3)# a b c d0 0.0 0.0 0.0 0.01 0.0 0.0 0.0 0.02 0.0 0.0 0.0 0.0 a b c d0 1.0 1.0 1.0 1.01 1.0 1.0 1.0 1.02 1.0 1.0 1.0 1.0 a b c d0 2.0 2.0 2.0 2.01 2.0 2.0 2.0 2.02 2.0 2.0 2.0 2.0 第一种合并123456789101112131415161718192021res = pd.concat([df1,df2,df3],axis=0)print(res)# a b c d0 0.0 0.0 0.0 0.01 0.0 0.0 0.0 0.02 0.0 0.0 0.0 0.00 1.0 1.0 1.0 1.01 1.0 1.0 1.0 1.02 1.0 1.0 1.0 1.00 2.0 2.0 2.0 2.01 2.0 2.0 2.0 2.02 2.0 2.0 2.0 2.0res = pd.concat([df1,df2,df3],axis=1)print(res)# a b c d a b c d a b c d0 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0 2.0 2.0 2.0 2.01 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0 2.0 2.0 2.0 2.02 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0 2.0 2.0 2.0 2.0 重新赋予左边的索引12345678910111213res = pd.concat([df1,df2,df3],axis=0，ignore_index=True)print(res)# a b c d0 0.0 0.0 0.0 0.01 0.0 0.0 0.0 0.02 0.0 0.0 0.0 0.03 1.0 1.0 1.0 1.04 1.0 1.0 1.0 1.05 1.0 1.0 1.0 1.06 2.0 2.0 2.0 2.07 2.0 2.0 2.0 2.08 2.0 2.0 2.0 2.0 另一种合并(‘outer’,’inner’)先生成两个DataFrame12345678910111213df1 = pd.DataFrame(np.ones((3,4))*0,index=[1,2,3],columns=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])df2 = pd.DataFrame(np.ones((3,4))*1,index=[2,3,4],columns=[&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;])print(df1)print(df2)# a b c d1 0.0 0.0 0.0 0.02 0.0 0.0 0.0 0.03 0.0 0.0 0.0 0.0 b c d e2 1.0 1.0 1.0 1.03 1.0 1.0 1.0 1.04 1.0 1.0 1.0 1.0 内外连接（默认为outer）1234567891011121314151617181920212223242526272829303132res = pd.concat([df1,df2],join=&apos;outer&apos;)print(res)# a b c d e1 0.0 0.0 0.0 0.0 NaN2 0.0 0.0 0.0 0.0 NaN3 0.0 0.0 0.0 0.0 NaN2 NaN 1.0 1.0 1.0 1.03 NaN 1.0 1.0 1.0 1.04 NaN 1.0 1.0 1.0 1.0res = pd.concat([df1,df2],join=&apos;inner&apos;)print(res)# b c d1 0.0 0.0 0.02 0.0 0.0 0.03 0.0 0.0 0.02 1.0 1.0 1.03 1.0 1.0 1.04 1.0 1.0 1.0res = pd.concat([df1,df2],join=&apos;inner&apos;,ignore_index=True)print(res)# b c d0 0.0 0.0 0.01 0.0 0.0 0.02 0.0 0.0 0.03 1.0 1.0 1.04 1.0 1.0 1.05 1.0 1.0 1.0 根据索引连接123456789df1 = pd.DataFrame(np.ones((3,4))*0,index=[1,2,3],columns=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])df2 = pd.DataFrame(np.ones((3,4))*1,index=[2,3,4],columns=[&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;])res = pd.concat([df1,df2],axis=1,join_axes=[df1.index])print(res)# a b c d b c d e1 0.0 0.0 0.0 0.0 NaN NaN NaN NaN2 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.03 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0 append添加123456789101112131415161718192021222324252627df1 =pd.DataFrame(np.ones((3,4))*0,columns=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])df2 =pd.DataFrame(np.ones((3,4))*1,columns=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])df3 =pd.DataFrame(np.ones((3,4))*2,columns=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])res = df1.append(df2,ignore_index=True)print(res)# a b c d0 0.0 0.0 0.0 0.01 0.0 0.0 0.0 0.02 0.0 0.0 0.0 0.03 1.0 1.0 1.0 1.04 1.0 1.0 1.0 1.05 1.0 1.0 1.0 1.0res = df1.append([df2,df3],ignore_index=True)print(res)# a b c d0 0.0 0.0 0.0 0.01 0.0 0.0 0.0 0.02 0.0 0.0 0.0 0.03 1.0 1.0 1.0 1.04 1.0 1.0 1.0 1.05 1.0 1.0 1.0 1.06 2.0 2.0 2.0 2.07 2.0 2.0 2.0 2.08 2.0 2.0 2.0 2.0 七、Pandas合并 merge生成两个DataFrame12345678910111213141516171819202122import pandas as pdimport numpy as npleft = pd.DataFrame(&#123;&apos;key&apos;: [&apos;K0&apos;, &apos;K1&apos;, &apos;K2&apos;, &apos;K3&apos;], &apos;A&apos;: [&apos;A0&apos;, &apos;A1&apos;, &apos;A2&apos;, &apos;A3&apos;], &apos;B&apos;: [&apos;B0&apos;, &apos;B1&apos;, &apos;B2&apos;, &apos;B3&apos;]&#125;)right = pd.DataFrame(&#123;&apos;key&apos;: [&apos;K0&apos;, &apos;K1&apos;, &apos;K2&apos;, &apos;K3&apos;], &apos;C&apos;: [&apos;C0&apos;, &apos;C1&apos;, &apos;C2&apos;, &apos;C3&apos;], &apos;D&apos;: [&apos;D0&apos;, &apos;D1&apos;, &apos;D2&apos;, &apos;D3&apos;]&#125;)print(left)print(right)# key A B0 K0 A0 B01 K1 A1 B12 K2 A2 B23 K3 A3 B3 key C D0 K0 C0 D01 K1 C1 D12 K2 C2 D23 K3 C3 D3 merge12345678res = pd.merge(left,right,on=&apos;key&apos;)print(res)# key A B C D0 K0 A0 B0 C0 D01 K1 A1 B1 C1 D12 K2 A2 B2 C2 D23 K3 A3 B3 C3 D3 两列key1234567891011121314151617181920212223242526left = pd.DataFrame(&#123;&apos;key1&apos;: [&apos;K0&apos;, &apos;K0&apos;, &apos;K1&apos;, &apos;K2&apos;], &apos;key2&apos;: [&apos;K0&apos;, &apos;K1&apos;, &apos;K0&apos;, &apos;K1&apos;], &apos;A&apos;: [&apos;A0&apos;, &apos;A1&apos;, &apos;A2&apos;, &apos;A3&apos;], &apos;B&apos;: [&apos;B0&apos;, &apos;B1&apos;, &apos;B2&apos;, &apos;B3&apos;]&#125;)right = pd.DataFrame(&#123;&apos;key1&apos;: [&apos;K0&apos;, &apos;K1&apos;, &apos;K1&apos;, &apos;K2&apos;], &apos;key2&apos;: [&apos;K0&apos;, &apos;K0&apos;, &apos;K0&apos;, &apos;K0&apos;], &apos;C&apos;: [&apos;C0&apos;, &apos;C1&apos;, &apos;C2&apos;, &apos;C3&apos;], &apos;D&apos;: [&apos;D0&apos;, &apos;D1&apos;, &apos;D2&apos;, &apos;D3&apos;]&#125;)res = pd.merge(left,right,on=[&apos;key1&apos;,&apos;key2&apos;])print(res)# key1 key2 A B C D0 K0 K0 A0 B0 C0 D01 K1 K0 A2 B2 C1 D12 K1 K0 A2 B2 C2 D2res = pd.merge(left,right,on=[&apos;key1&apos;,&apos;key2&apos;],how=&apos;outer&apos;)# how = [&apos;left&apos;,&apos;right&apos;,&apos;outer&apos;,&apos;inner&apos;] print(res)# key1 key2 A B C D0 K0 K0 A0 B0 C0 D01 K0 K1 A1 B1 NaN NaN2 K1 K0 A2 B2 C1 D13 K1 K0 A2 B2 C2 D24 K2 K1 A3 B3 NaN NaN5 K2 K0 NaN NaN C3 D3 indicator生成DataFrame1234df1 = pd.DataFrame(&#123;&apos;col1&apos;:[0,1], &apos;col_left&apos;:[&apos;a&apos;,&apos;b&apos;]&#125;)df2 = pd.DataFrame(&#123;&apos;col1&apos;:[1,2,2],&apos;col_right&apos;:[2,2,2]&#125;)print(df1)print(df2) 使用indicator12345678res = pd.merge(df1, df2, on=&apos;col1&apos;, how=&apos;outer&apos;, indicator=True)print(res)# col1 col_left col_right _merge0 0 a NaN left_only1 1 b 2.0 both2 2 NaN 2.0 right_only3 2 NaN 2.0 right_only index1234567891011121314left = pd.DataFrame(&#123;&apos;A&apos;: [&apos;A0&apos;, &apos;A1&apos;, &apos;A2&apos;], &apos;B&apos;: [&apos;B0&apos;, &apos;B1&apos;, &apos;B2&apos;]&#125;, index=[&apos;K0&apos;, &apos;K1&apos;, &apos;K2&apos;])right = pd.DataFrame(&#123;&apos;C&apos;: [&apos;C0&apos;, &apos;C2&apos;, &apos;C3&apos;], &apos;D&apos;: [&apos;D0&apos;, &apos;D2&apos;, &apos;D3&apos;]&#125;, index=[&apos;K0&apos;, &apos;K2&apos;, &apos;K3&apos;])res = pd.merge(left, right, left_index=True, right_index=True, how=&apos;outer&apos;)print(res)# A B C DK0 A0 B0 C0 D0K1 A1 B1 NaN NaNK2 A2 B2 C2 D2K3 NaN NaN C3 D3 handle overlapping12345678boys = pd.DataFrame(&#123;&apos;k&apos;: [&apos;K0&apos;, &apos;K1&apos;, &apos;K2&apos;], &apos;age&apos;: [1, 2, 3]&#125;)girls = pd.DataFrame(&#123;&apos;k&apos;: [&apos;K0&apos;, &apos;K0&apos;, &apos;K3&apos;], &apos;age&apos;: [4, 5, 6]&#125;)res = pd.merge(boys, girls, on=&apos;k&apos;, suffixes=[&apos;_boy&apos;, &apos;_girl&apos;], how=&apos;inner&apos;)print(res)# k age_boy age_girl0 K0 1 41 K0 1 5 八、Pandas Plot画图生成Series12345678910111213141516import pandas as pdimport numpy as npimport matplotlib.pyplot as pltdata = pd.Series(np.random.randn(1000), index=np.arange(1000))data = data.cumsum()data.plot()plt.show()data = pd.DataFrame(np.random.randn(1000, 4), index=np.arange(1000), columns=list(&quot;ABCD&quot;))data = data.cumsum()ax = data.plot.scatter(x=&apos;A&apos;, y=&apos;B&apos;, color=&apos;DarkBlue&apos;, label=&quot;Class 1&quot;)data.plot.scatter(x=&apos;A&apos;, y=&apos;C&apos;, color=&apos;LightGreen&apos;, label=&apos;Class 2&apos;, ax=ax)plt.show()]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>numpy</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫烦Python基础笔记]]></title>
    <url>%2F2019%2F04%2F01%2F%E8%8E%AB%E7%83%A6Python%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、安装注意配置环境变量和pipe3的环境变量（新版安装时打勾就可以自动配置） 二、基本使用2.1 print功能2.2 基本数学运算&emsp;&emsp;次方用**表示，区别于传统的^.&emsp;&emsp;取余用%2.3 变量variable&emsp;&emsp;命名时多个单词用下划线隔开&emsp;&emsp;多个变量复制：a,b,c = 11,12,13 三、while循环和for循环四、if判断Python中并没有类似三目运算符的命令，但是有替代。如，1234worked = True result = &apos;done&apos; if worked else &apos;not yet&apos;//如果worked是True，则&apos;done&apos;被赋值给result，false则是‘not yet’被赋值给result print(result) 五、定义功能六、变量形式七、模块安装安装Numpy 八、文件读取九、class类十、input输入十一、元组turple、列表List、字典十二、模块import]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F31%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" $ hexo new ‘My New Post’ More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
