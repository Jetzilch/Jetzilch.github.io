<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[web前端知识day01_HTML]]></title>
    <url>%2F2019%2F08%2F16%2Fweb%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86day01-HTML%2F</url>
    <content type="text"><![CDATA[一、HTML入门案例(静夜思)1.概述HTML：Hyper Text Markup Language 超文本标记语言超文本：比普通文本功能强大，能实现不同样式(比如加粗，居中，斜体)标记语言：使用标签对内容进行描述的语言。 2.使用下列标签完成静夜思案例12345&lt;h1&gt;&lt;/h1&gt; 一级标题&lt;b&gt;&lt;/b&gt; 加粗&lt;i&gt;&lt;/i&gt; 斜体&lt;/br&gt; 换行&lt;p&gt;&lt;/p&gt;段落]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday27]]></title>
    <url>%2F2019%2F08%2F15%2Fjavaday27%2F</url>
    <content type="text"><![CDATA[一、类的加载1.类的初始化类的初始化是由加载，连接，初始化三部分实现的加载：将class文件加载到内存，并创建一个相应的Class对象。连接：初始化： 2.类的加载器负责将class文件加载到内存中，并生成对应的Class对象虽然我们不需要关心类的加载机制，但是了解它有助于帮我们理解程序的运行。 2.1 类加载器的组成Bootstrap ClassLoader 根类加载器也叫引导类加载器，负责System，String这样的核心类的加载，位于JDK中JRE的lib目录下的rt.jar文件中。Extension ClassLoader 扩展加载器负责JRE的扩展目录中jat包的加载在JDK中JRE的lib目录下ext目录。System ClassLoader 系统加载器负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径。 二、反射1.概述Java反射机制是指在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的人以一个方法和属性；这种动态获取的信息以及动态调用对象方法的功能成语java语言的反射机制。]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday26]]></title>
    <url>%2F2019%2F08%2F14%2Fjavaday26%2F</url>
    <content type="text"><![CDATA[一、网络编程1.概述什么是计算机网络？就是将多台电脑通过通信线路连接起来，实现资源共享和信息传递的计算机系统。网络编程的作用实现网络互连的不同计算机上的程序之间的数据交换。 2.网络模型网络模型研究的问题，就是计算机网络之间以何种规则进行通信。网络模型一般指OSI(Open System Interconnection开放系统互连)参考模型 TCP/IP参考模型应用层 应用层表示层会话层传输层 传输层网络层 网际层数据链路层 主机至网络层物理层网络应用程序由：网络编程，IO流，多线程组成。 3.网络编程三要素(1)IP地址：网络中每台计算机的唯一标识。作用是找到电脑(2)端口：用来区分电脑上的每一个程序。作用是区分程序(3)协议 作用是根据某种规则“说出程序能懂的话” 3.1 IP地址IP地址：网络中计算机的唯一标识。计算机只能识别二进制的数据，但IP地址不是一个二进制的数，而是一个形如192.168.1.100这样的数这是因为192.168.1.100换算成二进制是11000000 10101000 00000001 01100100如果用二进制来表示IP地址，并使用它进行配置IP地址，记忆起来就比较麻烦，而且容易出错。为了方便表示IP地址，我们就把IP地址的每一个字节(IP地址有四个字节)上的数据换算成十进制，然后用.分开来表示，如上。这种方法也叫 点分十进制 。IP地址的组成：网络号段+主机号段IP地址的分类：A类：第一号段为网络号，第二号段为主机号。1.0.0.1—127.255.255.254一个A类的网络号段可以配256*256*256台计算机(16777216)B类：前二号段为网络号段+后二段主机号段. 128.0.0.1–191.255.255.254一个B类的网络号段可以配256*256台计算机(65536)C类：前三号段为网络号段+后一段的主机号段 192.0.0.1—223.255.255.254一个C类的网络号段可以配256台计算机192.168.X.X和10.X.X.X私有地址：在互联网上不使用，而被用在局域网中。两个DOS命令 windows版ipconfig 查看本机IP地址ping 后面跟ip地址。测试本机与指定的ip地址间的通信是否有问题mac版ifconfig 查看本机IP地址ping 后面跟ip地址。测试本机与指定的ip地址间的通信是否有问题,mac版默认会一直进行测试，control+c可以终止，不是command+c。特殊的ip地址：127.0.0.1回环地址(表示本机)x.x.x.255广播地址x.x.x.0网络地址 4.InetAddress类为了方便我们对ip地址的获取和操作，Java提供了一个类InetAddress供我们使用。InetAddress类没有构造方法如果一个类没有构造方法：（1）成员全部是静态的(Math,Arrays,Colletions)（2）单例设计模式(Runtime)（3）类中有静态方法返回该类对象(InetAddress) 4.1 InetAddress类的成员方法public static InetAddress getByName(String host):根据主机名或者ip地址的字符串表示得到ip地址对象。 5.端口号有物理端口和逻辑端口(我们想说的是逻辑端口)物理端口：网卡口逻辑端口：我们指的就是逻辑端口（1）每个网络程序都会至少有一个逻辑端口，用于标识进程的逻辑地址（2）有效端口：0～65535，其中0～1024为系统使用或作为保留端口 6.协议(通信的规则)UDP:把数据打包数据有限制(64k)不需要建立连接，所以速度快，但是不可靠。TCP:建立连接通道数据无限制效率低，可靠。举例：UDP：发短信，一次发一条，不需要经过对方同意TCP：打电话，只要电话通了，说多少话都可以，需要对方同意才能进行通话。 7.Socket(网络套接字)Socket编程就是网络编程。Socket：网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字。 7.1 Socket原理机制（1）通信的两端都有Socket。（2）网络通信其实就是Socket之间的通信。（3）数据在两个Socket之间通过IO传输。 8.UDP协议发送数据和接收数据SendDemo123456789101112131415161718192021222324252627282930313233343536373839404142package cn.itcast_02;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;import java.net.SocketException;import java.net.UnknownHostException;/* * UDP协议发送数据： * （1）创建Socket对象 * （2）创建数据并打包 * （3）调用Socket对象的发送方法发送数据包 * （4）释放资源 */public class SendDemo &#123; public static void main(String[] args) throws IOException &#123; //创建Socket对象 DatagramSocket ds = new DatagramSocket(); //创建数据并打包 //DatagramPacket(byte[] buf,int length,InetAddress address,int port) //创建数据 byte[] bys = &quot;helloworld&quot;.getBytes(); //数组长度 int length = bys.length; //IP地址 InetAddress address = InetAddress.getByName(&quot;192.168.43.178&quot;); //端口 int port = 10086; //打包 DatagramPacket dp = new DatagramPacket(bys, length,address,port); //调用Socket对象的发送方法发送数据 //public void send(DatagramPacket p) ds.send(dp); //释放资源 ds.close(); &#125;&#125; ReceiveDemo1234567891011121314151617181920212223242526272829303132333435363738394041424344package cn.itcast_02;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;/* * UDP协议接收数据： * （1）创建Socket对象 * （2）创建一个数据包(接收容器) * （3）调用Socket对象的接收方法接收数据 * （4）解析数据并显示在控制台 * （5）释放资源 */public class ReceiveDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建Socket对象 DatagramSocket ds = new DatagramSocket(10086); // 创建一个数据包(接收容器) // DatagramPacket(byte[] buf,int length) byte[] bys = new byte[1024]; int length = bys.length; DatagramPacket dp = new DatagramPacket(bys, length); // 调用Socket对象的接收方法接收数据 ds.receive(dp); // 解析数据包 // 获取对方IP InetAddress address = dp.getAddress(); String ip = address.getHostAddress(); // public byte[] getData():获取数据缓冲区 // public int getLength():获取数据实际长度 byte[] bys2 = dp.getData(); int len = dp.getLength(); String s = new String(bys2, 0, len); System.out.println(ip+&quot;:&quot;+s); // 释放资源 ds.close(); &#125;&#125;]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday25]]></title>
    <url>%2F2019%2F08%2F13%2Fjavaday25%2F</url>
    <content type="text"><![CDATA[一、GUI(图形用户接口)1.GUI与CLI的区别GUI(Graphocal User Interface):用图形的方式来显示计算机操作的界面，这样更加方便直观。CLI(Command line User Interface):命令行用户接口，就是常见的Dos命令行操作，需要记忆一些常用命令，操作不直观。 2.awt和swing包的概述java.awt:Abstract Window ToolKit(抽象窗口工具包),需要调用本地系统方法实现功能。属重量级控件。(与系统关联性强，所以叫称为重量级，重量级的移植性比较差)javax.swing:在AWT基础上，建立一套图形界面系统，其中提供了更多的组件，而且完全由Java实现，增强了移植性，属轻量级控件。 3.GUI继承体系Component组件可以理解成对象。看图(图以后补…) 4.FrameComponent组件的整个体系子类和方法很多，所以我们用到哪个再学哪个。 5.如何关闭窗口(事件监听机制)事件监听机制：（1）事件源 事件发生的地方（2）事件 就是要发生的事情（3）事件处理 就是针对发生的事件做出的处理方案（4）事件监听 把事件源与事件关联起来1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package cn.itcast_02;import java.awt.Frame;import java.awt.event.WindowEvent;import java.awt.event.WindowListener;/* * * 关闭窗口案例 */public class FrameDemo &#123; public static void main(String[] args) &#123; Frame f = new Frame(); f.setBounds(400,200,400,300); //让窗口关闭 //事件源 //事件：对窗体的处理 //事件处理：关闭窗口(System.exit(0)); //事件监听 f.addWindowListener(new WindowListener() &#123; @Override public void windowOpened(WindowEvent e) &#123; &#125; @Override public void windowIconified(WindowEvent e) &#123; &#125; @Override public void windowDeiconified(WindowEvent e) &#123; &#125; @Override public void windowDeactivated(WindowEvent e) &#123; &#125; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; @Override public void windowClosed(WindowEvent e) &#123; &#125; @Override public void windowActivated(WindowEvent e) &#123; &#125; &#125;); f.setVisible(true); &#125;&#125; 上面的代码实现了窗口关闭的功能，但是WindoListener接口需要重写的方法太多，仅仅需要实现一个功能却要将接口的所有方法重写，很麻烦。解决方案如下：接口(方法比较多)–适配器类(实现接口，仅仅空实现)–实现类(仅重写需要实现的功能)通过适配器类实现接口，空实现所有需要重写的方法，然后创建实现类继承适配器类，实现类中仅需要重写自己想要使用的功能就行。 6.加入按钮、文本框、文本域实现数据转移案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package cn.itcast_02;import java.awt.Button;import java.awt.FlowLayout;import java.awt.Frame;import java.awt.TextArea;import java.awt.TextField;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;/* * 增加一个按钮、文本框、文本域 */public class FrameDemo2 &#123; public static void main(String[] args) &#123; //创建窗体 Frame f= new Frame(&quot;数据转移程序&quot;); //设置窗体属性和布局 f.setBounds(400,200,400,300); f.setLayout(new FlowLayout()); //创建按钮 Button bu = new Button(&quot;数据转移&quot;); bu.setSize(20, 20); //创建文本框 final TextField tf = new TextField(20); //加final是局部内部类访问局部变量，局部变量需要用final修饰 //上述是视频中的说法，实际操作时，没加final并没有报错，不知道是不是新版本的特性？ //创建文本域 final TextArea ta = new TextArea(10,40); //添加组件到窗体 f.add(bu); f.add(ta); f.add(tf); //设置窗体关闭 f.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;); //对按钮添加事件 bu.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; //获取文本框的值 String tfStr = tf.getText().trim(); //清空数据 tf.setText(&quot;&quot;); //设置给文本域 //ta.setText(tfStr); ta.append(tfStr+&quot;\n&quot;); //获取光标 tf.requestFocus(); &#125; &#125;); //显示窗体 f.setVisible(true); &#125;&#125; 7.通过鼠标移动到按钮上更改背景色案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package cn.itcast_06;import java.awt.Button;import java.awt.Color;import java.awt.FlowLayout;import java.awt.Frame;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;/* * 增加一个按钮、文本框、文本域 */public class FrameDemo &#123; public static void main(String[] args) &#123; // 创建窗体 Frame f = new Frame(&quot;数据转移程序&quot;); // 设置窗体属性和布局 f.setBounds(400, 200, 400, 300); f.setLayout(new FlowLayout()); // 创建按钮 Button redButton = new Button(&quot;红色&quot;); // 添加按钮到窗体 f.add(redButton); // 设置窗体关闭 f.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;); // //对按钮添加动作监听 // redButton.addActionListener(new ActionListener() &#123; // @Override // public void actionPerformed(ActionEvent e) &#123; // f.setBackground(Color.RED); // &#125; // &#125;); // 对按钮添加鼠标点击事件 // redButton.addMouseListener(new MouseAdapter() &#123; // @Override // public void mouseClicked(MouseEvent e) &#123; // f.setBackground(Color.RED); // &#125; // &#125;); // 对按钮添加鼠标加入事件 redButton.addMouseListener(new MouseAdapter() &#123; @Override public void mouseEntered(MouseEvent e) &#123; f.setBackground(Color.RED); &#125; &#125;); // 对按钮添加鼠标离开退出事件 redButton.addMouseListener(new MouseAdapter() &#123; @Override public void mouseExited(MouseEvent e) &#123; f.setBackground(Color.WHITE); &#125; &#125;); // 显示窗体 f.setVisible(true); &#125;&#125; 8。文本框中只能输入数字案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package cn.itcast_07;import java.awt.FlowLayout;import java.awt.Frame;import java.awt.Label;import java.awt.TextField;import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;/* * */public class FrameDemo &#123; public static void main(String[] args) &#123; // 创建窗体对象并设置属性 Frame f = new Frame(&quot;不能输入非数字字符&quot;); f.setBounds(400, 200, 400, 300); f.setLayout(new FlowLayout()); // 创建标签对象 Label label = new Label(&quot;请输入你的QQ号码，不能是非数字&quot;); TextField tf = new TextField(40); // 添加组件到窗体 f.add(label); f.add(tf); // 设置窗体关闭 f.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;); // 给文本框添加事件 tf.addKeyListener(new KeyAdapter() &#123; @Override public void keyPressed(KeyEvent e) &#123; // 如果你取得是数字字符，显示。如果是非数字字符，取消。 char ch = e.getKeyChar(); if (!(ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos;)) &#123; e.consume(); //视频中是可以实现效果的，但是是实际操作数字和字母还是能输入 //backspace之类的键倒是变成不能输入了 //不用太担心，理解思想和主要操作就好，之后基本不会使用到这个。 //可能是版本问题不同导致。 &#125; &#125; &#125;); // 窗体可视化 f.setVisible(true); &#125;&#125; 9.一级菜单1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package cn.itcast_08;import java.awt.FlowLayout;import java.awt.Frame;import java.awt.Menu;import java.awt.MenuBar;import java.awt.MenuItem;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class FrameDemo &#123; public static void main(String[] args) &#123; // 创建窗体 Frame f = new Frame(&quot;一级菜单&quot;); // 设置窗体属性和布局 f.setBounds(400, 200, 400, 300); f.setLayout(new FlowLayout()); //创建菜单栏 MenuBar mb = new MenuBar(); //创建菜单 Menu m = new Menu(&quot;文件&quot;); //创建菜单项 MenuItem mi = new MenuItem(&quot;退出系统&quot;); //添加 m.add(mi); mb.add(m); //设置菜单栏 f.setMenuBar(mb); //添加退出系统功能 mi.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; System.exit(0); &#125; &#125;); //设置窗体退出 f.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;); //窗体可视化 f.setVisible(true); &#125;&#125; 10.多级菜单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package cn.itcast_09;import java.awt.FlowLayout;import java.awt.Frame;import java.awt.Menu;import java.awt.MenuBar;import java.awt.MenuItem;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import java.io.IOException;public class FrameDemo &#123; public static void main(String[] args) &#123; // 创建窗体 Frame f = new Frame(&quot;一级菜单&quot;); // 设置窗体属性和布局 f.setBounds(400, 200, 400, 300); f.setLayout(new FlowLayout()); // 创建菜单栏 MenuBar mb = new MenuBar(); // 创建菜单 Menu m1 = new Menu(&quot;文件&quot;); Menu m2 = new Menu(&quot;更改名称&quot;); // 创建菜单项 MenuItem mi1 = new MenuItem(&quot;好好学习&quot;); MenuItem mi2 = new MenuItem(&quot;天天向上&quot;); MenuItem mi3 = new MenuItem(&quot;恢复标题&quot;); MenuItem mi4 = new MenuItem(&quot;打开记事本&quot;); MenuItem mi5 = new MenuItem(&quot;退出系统&quot;); // 添加 m1.add(m2); m1.add(mi4); m1.add(mi5); m2.add(mi1); m2.add(mi2); m2.add(mi3); mb.add(m1); // 设置菜单栏 f.setMenuBar(mb); // 添加打开记事本功能 mi4.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; Runtime r = Runtime.getRuntime(); try &#123; r.exec(&quot;open -a TextEdit&quot;); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; &#125; &#125;); // 添加退出系统功能 mi5.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; System.exit(0); &#125; &#125;); // 设置窗体退出 f.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;); // 窗体可视化 f.setVisible(true); &#125;&#125; 二、NetBeans]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday24]]></title>
    <url>%2F2019%2F08%2F13%2Fjavaday24%2F</url>
    <content type="text"><![CDATA[一、JDK5新特性:Lock锁1.概述为了让锁更清晰的表达，Java提供了Lock接口。 2.售卖电影票案例演示SellTickets类123456789101112131415161718192021222324252627282930package cn.itcast_01;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class SellTickets implements Runnable &#123; private int tickets = 100; private Lock lock = new ReentrantLock(); @Override public void run() &#123; while (true) &#123; try &#123; lock.lock(); if (tickets &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;正在卖倒数第&quot; + (tickets--) + &quot;张票&quot;); &#125; &#125; finally &#123; lock.unlock(); &#125; &#125; &#125;&#125; SellTicketsDemo类123456789101112131415package cn.itcast_01;public class SellTicketsDemo &#123; public static void main(String[] args) &#123; SellTickets st = new SellTickets(); Thread t1 = new Thread(st,&quot;窗口1&quot;); Thread t2 = new Thread(st,&quot;窗口2&quot;); Thread t3 = new Thread(st,&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 二、死锁问题1.概述死锁问题指的是两个或者两个以上的线程在执行过程中，因争夺资源产生的一种互相等待的现象。举例：中国人、美国人吃饭案例中国人需要两支筷子才能吃饭，美国人需要刀叉才能吃饭。现在中国人有1支筷子，一把刀。等美国人给他筷子美国人只有一支筷子，一把叉，等中国人给他刀，两个人都在等待，没有办法吃饭。同步的弊端：（1）效率低（2）容易出现死锁 2.死锁问题代码体现MyLock类12345678910package cn.itcast_02;/* * */public class MyLock &#123; //创建两把锁 public static final Object objA = new Object(); public static final Object objB = new Object(); &#125; DieLock类1234567891011121314151617181920212223242526272829package cn.itcast_02;public class DieLock extends Thread &#123; private boolean flag; public DieLock(boolean flag) &#123; this.flag = flag; &#125; @Override public void run() &#123; if (flag) &#123; synchronized (MyLock.objA) &#123; System.out.println(&quot;if objA&quot;); synchronized (MyLock.objB) &#123; System.out.println(&quot;if objB&quot;); &#125; &#125; &#125; else &#123; synchronized (MyLock.objB) &#123; System.out.println(&quot;else objB&quot;); synchronized (MyLock.objA) &#123; System.out.println(&quot;else objA&quot;); &#125; &#125; &#125; &#125;&#125; DieLockDemo类1234567891011package cn.itcast_02;public class DieLockDemo &#123; public static void main(String[] args) &#123; DieLock dl1 = new DieLock(true); DieLock dl2 = new DieLock(false); dl1.start(); dl2.start(); &#125;&#125; 三、线程间的通信1.概述线程间的通信指不同种类的线程针对统一资源的操作。(想想买包子和买包子的例子)2.案例演示Student类12345678910111213141516171819202122232425262728293031323334package cn.itcast_03;public class Student &#123; private String name; private int age; public Student() &#123; super(); &#125; public Student(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; SetThread类1234567891011121314151617181920212223242526272829package cn.itcast_03;public class SetThread implements Runnable &#123; private Student s; public SetThread(Student s) &#123; super(); this.s = s; &#125; @Override public void run() &#123; int x = 0; while (true) &#123; synchronized (s) &#123; if (x % 2 == 0) &#123; s.setName(&quot;林青霞&quot;); s.setAge(27); &#125; else &#123; s.setName(&quot;哈哈哈&quot;); s.setAge(100); &#125; x++; &#125; &#125; &#125;&#125; GetThread类123456789101112131415161718192021package cn.itcast_03;public class GetThread implements Runnable &#123; private Student s; public GetThread(Student s) &#123; super(); this.s = s; &#125; @Override public void run() &#123; while(true) &#123; synchronized (s) &#123; System.out.println(s.getName() + &quot;---&quot; + s.getAge()); &#125; &#125; &#125;&#125; StudentDemo类1234567891011121314151617package cn.itcast_03;public class StudentDemo &#123; public static void main(String[] args) &#123; Student s = new Student(); //创建线程对象 GetThread gt1 = new GetThread(s); SetThread st1 = new SetThread(s); Thread t1 = new Thread(gt1); Thread t2 = new Thread(st1); t1.start(); t2.start(); &#125;&#125; 现在这个程序虽然保证了线程安全，但是仍然有问题：（1）如果一开始是GetThread抢到CPU执行权，此时Student对象仍是默认赋值null和0，这样就会输出null—0，没有意义。就像还没做好包子，只有面粉，结果别人就把它买走了。（2）如果SetThread一直抢到执行权，则会一直进行赋值，而之前被赋值的内容失去了意义，白费功夫了，这也是有问题的。应该等数据被GetThread”消费”后再进行“生产”。就像没有人来买包子，我却一直做，而我只能装一个包子，所以每次做了新的包子，就把旧的包子丢掉了。依据上述的问题，我们正常的解决思路应该是：（1）生产者(SetThread):先看是否有数据，有就等待，没有就生产。（2）消费者(GetThread):先看是否有数据，有就消费，没有就等待。为了处理这个问题，Java就提供了一种机制：等待唤醒机制。加入等待唤醒机制后：（1）生产者(SetThread):先看是否有数据，有就等待，没有就生产，生产完之后通知消费者来消费数据。（2）消费者(GetThread):先看是否有数据，有就消费，没有就等待，通知生产者生产数据。 3.Java等待唤醒机制等待唤醒机制由Object类中的三个方法来实现：wait():等待notify():唤醒单个线程notifyAll():唤醒所有线程这些方法都与线程相关，为什么不定义在Thread类中呢？因为这些方法的调用必须通过锁对象调用，而我们刚才使用的锁对象是任意锁对象，所以这些方法必须定义在OBject类中，这样任意对象才都能调用。 四、线程组1.概述Java中使用ThreadGroup来表示线程组，它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。 2.如何对线程进行分组创建一个新的组，并在创建新的线程对象时通过构造方法对其进行分组。 五、线程池1.概述程序启动一个线程要与系统交互，占用资源较多。如果存在一个线程池，里面存在一些线程，当程序要创建大量生存周期很短的线程时，可以使用线程池。线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。(省去了启动线程时占用资源)JDK5之前，必须手动实现自己的线程池，JDK5之后，Java内置支持线程池。 2.线程池简单案例演示步骤：（1）创建一个线程池对象，通过带参构造确定要创建几个线程对象Executors类的public static ExecutorService newFixedThreadPool(int nThreads)（2）上述创建的线程池对象可以执行：可以执行Runnable对象或者Callable对象代表的线程。所以我们这里要做一个类实现Runnable接口（3）调用如下方法即可:Future&lt;?&gt; submit(Runnable task) Future submit(Callable task)（4）如何结束？shoutdown();1234567891011121314151617181920212223242526272829303132package cn.itcast_08;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/* * 步骤：（1）创建一个线程池对象，通过带参构造确定要创建几个线程对象Executors类的public static ExecutorService newFixedThreadPool(int nThreads)（2）上述创建的线程池对象可以执行：可以执行Runnable对象或者Callable对象代表的线程。所以我们这里要做一个类实现Runnable接口（3）调用如下方法即可:Future&lt;?&gt; submit(Runnable task)&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)（4）如何结束？shoutdown(); */public class ExceutorsDemo &#123; public static void main(String[] args) &#123; //（1）创建一个线程池对象，通过带参构造确定要创建几个线程对象 ExecutorService pool = Executors.newFixedThreadPool(2); //可以执行Runnable对象或者Callable对象代表的线程。 pool.submit(new MyRunnable()); pool.submit(new MyRunnable()); //结束进程池 pool.shutdown(); &#125;&#125; 3.多线程实现方式3:Callable(接口)—了解Callable:带泛型的接口这里指定的泛型其实是call()方法的返回值类型很简单，把call()当run()使用，但是可以带返回值，不知道返回什么可以返回null。这个接口的实现类对象无法传递给Thread的带参构造，也就是说Thread没有接收Callable实现类对象的带参构造方法，所以用的不多，它主要是依赖线程池实现的。这个实现方法的好处是：（1）有返回值（2）可以抛异常弊端：繁琐。 六、匿名内部类使用多线程(至少要看懂代码，不过这个代码都是你自己写出来的，你要之后再写不出来，也说不过去…)123456789101112131415161718192021222324252627282930313233343536package cn.itcast_09;/* * 匿名内部类使用多线程 */public class Demo &#123; public static void main(String[] args) &#123; //实现多线程方式1:继承Thread类 new Thread() &#123; @Override public void run() &#123; for(int x=0;x&lt;50;x++) &#123; System.out.println(&quot;hello:&quot;+x); &#125; &#125; &#125;.start(); //实现多线程方式2:实现Runnable接口 new Thread(new Runnable() &#123; @Override public void run() &#123; for(int x=0;x&lt;50;x++) &#123; System.out.println(&quot;world:&quot;+x); &#125; &#125; &#125;) &#123; @Override public void run() &#123; for(int x=0;x&lt;50;x++) &#123; System.out.println(&quot;java:&quot;+x); &#125; &#125; &#125;.start();//开发时不会这样做，但面试可能会问， //因为接口实现类要重写run()方法，而Thread子类也可以重写run()，所以才会出现上述情况 //如果出现这样的情况，结果是执行Thread子类的run() &#125;&#125; 七、定时器1.概述及案例演示12345678910111213141516171819202122232425262728293031323334353637383940414243444546package cn.itcast_12;import java.util.Timer;import java.util.TimerTask;/* * 定时器：可以让我们在指定时间做某件事情，还可以重复的做某件事情。 * 依赖Timer和TimerTask这两个类： * Timer：定时 * Timer() * schedule(TimerTask t,long delay) * schedule(TimerTask t,long delay,long period) * TimerTask：任务 */public class TimerDemo &#123; public static void main(String[] args) &#123; // 创建TImer对象 Timer t = new Timer(); t.schedule(new MyTask(t), 1000,1000);//第三个参数的意思是隔多少毫秒后再执行任务。 &#125;&#125;class MyTask extends TimerTask &#123; private Timer t; public MyTask() &#123; super(); &#125; public MyTask(Timer t) &#123; super(); this.t = t; &#125; @Override public void run() &#123; System.out.println(&quot;学习时间结束&quot;); //t.cancel();//使用cancel()表示已经退出任务，所以如果指定了schedule()第三个参数， //又在此处使用cancel(),则不会重复任务，因为调用此方法后任务已经退出，不会再执行。 &#125;&#125; 2.练习1.需求：在指定的时间删除指定目录1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package cn.itcast_12;import java.io.File;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Timer;import java.util.TimerTask;public class TimerTest &#123; public static void main(String[] args) throws ParseException &#123; Timer t = new Timer(); t.schedule(new DeleteFolder(t), 3000); &#125;&#125;class DeleteFolder extends TimerTask &#123; private Timer t; public DeleteFolder(Timer t) &#123; super(); this.t = t; &#125; public DeleteFolder() &#123; super(); &#125; @Override public void run() &#123; System.out.println(&quot;1&quot;); File srcFolder = new File(&quot;/Users/chenjie/Desktop/demo&quot;); System.out.println(&quot;1&quot;); deleteFolder(srcFolder); System.out.println(&quot;1&quot;); t.cancel(); &#125; private void deleteFolder(File srcFolder) &#123; File[] fileArr = srcFolder.listFiles(); if (fileArr != null) &#123; for (File file : fileArr) &#123; if (file.isDirectory()) &#123; deleteFolder(file); &#125; else &#123; file.delete(); &#125; &#125; &#125; srcFolder.delete(); &#125;&#125; 八、多线程面试题1.多线程有几种实现方案，分别是哪几种？一般答2种。继承Thread类实现Runnable接口扩展一种：实现Callable接口，这个得和线程池结合。 2.同步有几种方式，分别是什么？两种。同步代码块同步方法 3.启动一个线程是run()还是start()?它们的区别？srart()run():封装了被线程执行的代码，直接调用仅仅是普通方法的调用start():启动线程，并有JVM自动调用run() 4.sleep()和wait()的区别？sleep():必须指定时间。不释放锁wait():可以不指定时间，也可以指定时间。释放锁。 5.为什么wait(),notify(),notifyAll()都定义在Object类中？因为这些方法的调用时依赖于锁对象的，而而同步代码块的锁对象是任意对象。Object代表的正是任意对象，所以定义在里面。 6.线程的生命周期图？新建-就绪-运行-死亡新建-就绪-运行-阻塞-就绪-运行-死亡建议：画图解释 九、设计模式1.面向对象思想设计原则如果要深入了解面向对象的思想，就必须熟悉总结的面向对象思想的设计原则：（1）单一职责高内聚，低耦合。即每个类应该只有一个职责，对外只提供一种功能，而引起类变化的原因应该只有一个。（2）开闭原则一个对象对扩展开放，对修改关闭。简单的说就是对类的改动是通过增加代码进行的，而不是修改现有代码。(借助抽象和多态)如手机有游戏功能是在原有手机类上增加功能，而不是改动原有的手机类。（3）里氏替换原则在任何父类出现的地方都可以用它的子类代替（4）依赖注入原则要依赖于抽象，不要依赖于具体实现。（5）接口分离原则一个接口不需要提供太多的行为，一个接口应该只提供一种对外的功能，不应该把左右的操作都封装到一个接口中。（6）迪米特原则降低各个对象之间的耦合，提高系统的可维护性。在模块之间应该只通过接口编程，而不理会模块的内部工作原理。它可以使各个模块耦合度降到最低，保证软件的复用。 2.设计模式设计模式就是一套反复使用、多人知晓、经过分类编目的代码设计经验的总结。设计模式是一种思想，与具体语言无关。 2.1 设计模式分类（1）创建型模式 对象的创建简单工厂模式 工厂方法模式 单例设计模式（2）结构型模式 对象的组成(结构)（3）行为型模式 对象的行为2.1.1 简单工厂模式就是创建一个工厂类负责创建某类的实例，这样就可以调用工厂类方法创建对象，不用再去单独创建各个对象，缺点是如果有新的对象增加，就需要不断修改工厂类，不利于后期维护。2.1.2 工厂方法模式创建一个Factory类，碰到具体情况，需要创建什么对象，就再创建一个“什么Factory”类，这样就不影响已有的代码，后期维护容易，增强了系统的扩展性。缺点是需要多编写代码，增加了工作量。2.1.3 单例设计模式单例模式就是要确保类在内存中只有一个对象，该对象必须自动创建，并且对外提供。如何实现？（1）把构造方法私有（2）再成员位置自己创建一个对象（3）通过一个公共的方法提供访问饿汉式：类一加载就创建对象12345678910111213141516public class Student &#123; //构造私有 private Student() &#123; &#125; //自己造一个 //静态方法只能访问静态成员变量 static Student s = new Student(); //提供公共的访问方式 //为了保证外界能够直接使用该方法，加静态 public static Student getStudent() &#123; return s; &#125;&#125; 懒汉式：用的时候才去创建对象。12345678910111213public class Teacher &#123; private Teacher() &#123; &#125; private static Teacher t = null; public static Teacher getTeacher() &#123; if(t==null) &#123; t = new Teacher(); &#125; return t; &#125;&#125; 面试题1.单例模式的思想是神恶魔？请写一个代码体现。开发：饿汉式(是不会出问题的单例模式)面试：懒汉式(可能会出问题的单例模式)]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday23]]></title>
    <url>%2F2019%2F08%2F11%2Fjavaday23%2F</url>
    <content type="text"><![CDATA[一、多线程1.概述如果程序只有一条执行路径，那么该程序就是单线程程序。如果程序有多条执行路径，那么该程序就是多线程程序。要想了解多线程，必须了解线程，而要想了解线程，必须了解进程。 1.1 什么是进程？进程：就是正在运行的程序，是系统进行资源分配和调用的独立单位。每一个进程都有它自己的内存空间和系统资源。 1.2 多进程有什么意义？单进程计算机一次只能做一件事情，现在的计算机都是多进程的，可以运行多个程序，有多个进程(如一边玩游戏一边音乐)。它的意义：在一个时间段内执行多个进程，提高CPU的使用率。问题：一边玩游戏，一边听音乐是同时进行的吗？不是。因为单核CPU在某一个时间点上只能做一件事情。我们会觉得玩游戏和听音乐是同时进行，是因为CPU在程序间进行高效切换处理，让我们觉得是同时进行的。 1.3 什么是线程？在同一个进程内又可以执行多个任务。每一个任务我们就可以看成是一个线程。线程是进程(程序)的执行单元，也叫执行路径。是程序使用CPU的基本单位。 1.4 什么是多线程？单线程：程序只有一条执行路径。多线程：程序有多条执行路径。 1.5 多线程的意义？多线程的意义不是提高程序的执行速度，而是提高应用程序的使用率。程序的执行其实都是在抢CPU的资源，即CPU的执行权。而一个进程的线程越多，抢到的几率就越大。但是不能保证一定能抢到，所以线程的执行具有随机性。 1.6 并行和并发并行：逻辑上同时发生，指在某一个时间内同时运行多个程序。并发：物理上同时发生，指在某一个时间点同时运行多个程序举例：我在使用百度搜索引擎，3秒后你也使用百度搜索引擎，这叫并行。我们俩同时在14:30使用百度搜索引擎，这叫并发。 1.7 Java程序的运行原理Java命令会启动Java虚拟机JVM，相当于启动了一个应用程序，也就是启动了一个进程，该进程会自动启动一个“主线程”，然后主线程去调用某个类的main()，所以main方法运行在主线程中。 1.8 JVM虚拟机的启动是单线程的还是多线程的？多线程，原因是垃圾回收线程也要先启动，否则容易出现内存溢出。加上之前的主线程，至少启动了两个线程，所以JVM的启动是多线程的。 1.9Java如何实现多线程程序要实现多线程程序，首先必须创建一个进程，只有调用系统功能才能创建进程。Java是没有办法做到调用系统功能去创建进程的。但是可以将C/C++写好的调用系统功能封装成类，然后使用Java进行调用。于是就出现了Thread类。通过查看API，我们知道有两种方式实现多线程程序。 2.方式1实现多线程程序:继承Thread类步骤：（1）自定义类MyThread继承Thread类。（2）MyThread类里面重写run()(思考)为什么要重写run()？因为并不是MyThread类里面的所有代码都要被线程执行，Java就提供了Thread类中的run()用来包含那些需要被线程执行的代码。（3）创建对象（4）启动线程案例演示：MyThread类12345678910package cn.itcast_01;public class MyThread extends Thread &#123; @Override public void run() &#123; for(int x=0;x&lt;100;x++) &#123; System.out.println(&quot;hello&quot;+x); &#125; &#125;&#125; MyThreadDemo类1234567891011121314151617181920212223242526272829package cn.itcast_01;public class MyThreadDemo &#123; public static void main(String[] args) &#123; MyThread my = new MyThread(); // my.run(); // my.run(); //如果是多线程，结果应该是两个方法调用结果的重叠，而不是按顺序的输出。所以这还是单线程。 //所以说明形如上面的调用方法依然是单线程，如何实现多线程的调用呢？ //要实现多线程的调用，就必须提到另一个方法:start() //面试题: //run()和start()的区别？ //run():仅仅是封装被线程执行的代码，直接调用的是普通方法。 //start():首先启动了线程，然后再由JVM去调用该线程的run(). //所以正确调用方式如下： //my.start(); //my.start(); //IllegalThreadStateException:非法的线程状态异常 //连续调用两次my.start()会出现上述异常，为什么呢？ //因为上面两个语句的意思都是启动这个线程，第一个语句已经启动了线程，第二个语句要启动时，发现线程已经启动了，所以就报错了。 //所以应该创建两个线程对象，然后各自调用start()才是启动两个线程。 MyThread my2 = new MyThread(); my.start(); my2.start(); &#125;&#125; 2.1 如何获取线程对象的名称？如何获取线程名称？getName()如何设置线程对象的名称？setName()如何获取main()的线程对象名称？public static Thread currentThread():返回当前线程的对象引用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package cn.itcast_03;/* * 如何获取线程名称？ * getName() * 如何设置线程对象的名称？ * setName() * 如何获取main()的线程对象名称？ * public static Thread currentThread():返回当前线程的对象引用 */public class MyThreadDemo &#123; public static void main(String[] args) &#123; MyThread my1 = new MyThread(); MyThread my2 = new MyThread(); //调用方法设置名称 //这种方法类似之前Student类的无参+setXxx(); my1.setName(&quot;获取100个数&quot;); my2.setName(&quot;错误&quot;); my1.start(); my2.start(); //此外，还可以通过带参直接设置名字,前提是要自己给出子类的带参构造方法， //可以自动生成。 MyThread my3 = new MyThread(&quot;线程3&quot;); MyThread my4 = new MyThread(&quot;线程4&quot;); my3.start(); my4.start(); //获取当前线程的对象名称 System.out.println(Thread.currentThread().getName()); &#125; /* * 为什么名称是：Thread-？编号 * 父类无参给了一个“Thread-”+nextThreadNum()的值，然后通过init(...)将其转为字符数组， * 调用getName()时，getName()内部调用String.valueOf(...)将字符数组转为字符串return。 * */ // 通过上述解析，我们知道了这个名称的由来，但是这个名称对我们来说意义不大，所以我们要对它进行设置。 // 如何设置线程对象的名称？ // setName() //我们已经知道了如何设置和获取线程对象名称，但是我们如何获取main()的线程对象名称？ //Java提供了一个方法: //public static Thread currentThread():返回当前线程的对象引用 &#125; 3.Java时如何对线程进行调用的？线程有两种调度模型(1)分时调度模型 平均分配每个线程占用CPU的时间片。(可以理解成你用5min，我用5min这种感觉)(2)抢占是调度模型 优先级高的线程分配到的CPU时间片相对多一些，优先让优先级高的线程使用CPU，如果优先级相同，则从中随便选择一个。Java使用的是抢占式调度模型。所以接下来我们要学习如何设置和获得线程的优先级？12345678910111213141516171819202122232425262728293031323334package cn.itcast_04;/* * 没有设置线程的优先级都有默认优先级，如何获得线程的优先级？ * public final int getPriority():返回线程对象的优先级。 * 线程默认优先级为5. * 线程优先级的范围为1-10 * 如何设置线程对象的优先级？ * public final void setPriority():更改线程的优先级。 * 注意：线程优先级仅仅表示线程获取cpu时间片的几率比较高，要在运行次数比较多才能看到效果，因为cpu调用线程具有随机性。 */public class ThreadPriorityDemo &#123; public static void main(String[] args) &#123; ThreadPriority tp1 = new ThreadPriority(&quot;hello&quot;); ThreadPriority tp2 = new ThreadPriority(&quot;world&quot;); ThreadPriority tp3 = new ThreadPriority(&quot;java&quot;); //获取线程对象的优先级 // System.out.println(tp1.getPriority()); // System.out.println(tp2.getPriority()); // System.out.println(tp3.getPriority()); //设置线程优先级 //tp1.setPriority(100000); //报错。IllegalArgumentException(非法参数异常) //抛出的异常表明向方法传递了一个不合法或不正确的参数。 //线程优先级的范围为1-10. tp1.setPriority(10); tp2.setPriority(1); tp1.start(); tp2.start(); tp3.start(); &#125;&#125; 4.线程控制4.1 线程休眠ThreadSleep类1234567891011121314151617181920212223242526272829package cn.itcast_04;import java.util.Date;public class ThreadSleep extends Thread &#123; public ThreadSleep() &#123; super(); &#125; public ThreadSleep(String name) &#123; super(name); &#125; @Override public void run() &#123; for (int x = 0; x &lt; 100; x++) &#123; System.out.println(getName() + &quot;:&quot; + x+&quot;日期：&quot;+new Date()); //休眠 try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; ThreadSleepDemo类123456789101112131415161718192021package cn.itcast_04;/* * * */public class ThreadSleepDemo &#123; public static void main(String[] args) &#123; ThreadSleep ts1 = new ThreadSleep(); ThreadSleep ts2 = new ThreadSleep(); ThreadSleep ts3 = new ThreadSleep(); ts1.setName(&quot;hello&quot;); ts2.setName(&quot;world&quot;); ts3.setName(&quot;java&quot;); ts1.start(); ts2.start(); ts3.start(); &#125;&#125; 4.2线程加入ThreadJoin类1234567891011121314151617181920package cn.itcast_04;public class ThreadJoin extends Thread &#123; public ThreadJoin() &#123; super(); &#125; public ThreadJoin(String name) &#123; super(name); &#125; @Override public void run() &#123; for(int x=0;x&lt;100;x++) &#123; System.out.println(getName()+&quot;:&quot;+x); &#125; &#125;&#125; ThreadJoinDemo类12345678910111213141516171819202122package cn.itcast_04;/* * public final void join():等待该线程停止 */public class ThreadJoinDemo &#123; public static void main(String[] args) &#123; ThreadJoin tj1 = new ThreadJoin(&quot;hello&quot;); ThreadJoin tj2 = new ThreadJoin(&quot;world&quot;); ThreadJoin tj3 = new ThreadJoin(&quot;java&quot;); tj1.start(); try &#123; tj1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; tj2.start(); tj3.start(); &#125;&#125; 4.3 线程礼让ThreadYield类12345678910111213141516171819202122package cn.itcast_04;public class ThreadYield extends Thread &#123; public ThreadYield() &#123; super(); &#125; public ThreadYield(String name) &#123; super(name); &#125; @Override public void run() &#123; for(int x=0;x&lt;100;x++) &#123; System.out.println(getName()+&quot;:&quot;+x); Thread.yield(); &#125; &#125;&#125; ThreadYieldDemo类1234567891011121314151617package cn.itcast_04;/* * public static void yield():暂停当前正在执行的对象,并执行其他进程 * 让多个线程的执行更和谐，但是无法保证一个线程一次。 */public class ThreadYieldDemo &#123; public static void main(String[] args) &#123; ThreadYield ty1 = new ThreadYield(&quot;hello&quot;); ThreadYield ty2 = new ThreadYield(&quot;java&quot;); ty1.start(); ty2.start(); &#125;&#125; 4.4 守护线程(坦克大战图解)ThreadDaemon类123456789101112131415161718192021package cn.itcast_04;public class ThreadDaemon extends Thread &#123; public ThreadDaemon() &#123; super(); &#125; public ThreadDaemon(String name) &#123; super(name); &#125; @Override public void run() &#123; for(int x=0;x&lt;100;x++) &#123; System.out.println(getName()+&quot;:&quot;+x); &#125; &#125;&#125; ThreadDaemonDemo类12345678910111213141516171819202122232425package cn.itcast_04;/* * public final void setDaemon(boolean on):将该线程标记为守护线程或用户线程。 * 当前正在运行的线程都是守护线程时，Java虚拟机退出，该方法必须在启动线程前调用。 */public class ThreadDaemonDemo &#123; public static void main(String[] args) &#123; ThreadDaemon td1 = new ThreadDaemon(&quot;关羽&quot;); ThreadDaemon td2 = new ThreadDaemon(&quot;张飞&quot;); //设置守护线程 td1.setDaemon(true); td2.setDaemon(true); td1.start(); td2.start(); //对当前线程设置名称 Thread.currentThread().setName(&quot;刘备&quot;); for(int x=0;x&lt;5;x++) &#123; System.out.println(Thread.currentThread().getName()+&quot;:&quot;+x); &#125; &#125;&#125; 4.5 中断线程ThreadStop类12345678910111213141516171819202122232425262728293031package cn.itcast_04;import java.util.Date;public class ThreadStop extends Thread&#123; public ThreadStop() &#123; super(); &#125; public ThreadStop(String name) &#123; super(name); &#125; @Override public void run() &#123; System.out.println(&quot;开始时间：&quot;+new Date()); //休息10s try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; //e.printStackTrace(); System.out.println(&quot;线程被终止了&quot;); &#125; System.out.println(&quot;结束时间：&quot;+new Date()); &#125;&#125; ThreadStopDemo类123456789101112131415161718192021222324252627package cn.itcast_04;/* * public final void stop():让线程停止，已过时，但仍可以使用。 * public void interrupt():中断线程。把线程状态终止，并抛出一个InterruptException。 * 建议使用interrupt() * */public class ThreadStopDemo &#123; public static void main(String[] args) &#123; ThreadStop ts = new ThreadStop(); ts.start(); //调用stop() try &#123; Thread.sleep(3000); //ts.stop(); //具有不安全性，不建议使用。 //有些情况我们终止进程后，还要执行后面的命令，而stop()之后不会再执行后面的命令 //interrupt()则会执行后面的命令。 ts.interrupt(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 5.线程声明周期图解面试题：线程的生命周期（1）新建：创建线程对象。调用start()之后，进入就绪状态（2）就绪：有执行资格，没有执行权。得到CPU的执行权之后，进入运行状态（3）运行：有执行资格，有执行权。运行过程中，如果被别人抢到了执行权，该线程会回到就绪状态。调用sleep()或者wait()后进入阻塞状态。 阻塞：由于一些操作让线程处于该状态，没有执行资格，没有执行权。 而另一些操作，比如sleep()时间到或是notify()，可以把它激活，激活后处于就绪状态。run()结束中断进程intertupt()（4）死亡：线程对象变成垃圾，等待被回收。 6.方式2实现多线程程序：实现Runnale接口步骤：（1）自定义MyRunnable实现Runnable接口（2）重写run()（3）创建MyRunnable类的对象（4）创建Thread类的对象，并把（3）的对象作为构造参数传递案例演示MyRunnable类12345678910111213package cn.itcast_05;public class MyRunnable implements Runnable &#123; @Override public void run() &#123; for(int x=0;x&lt;100;x++) &#123; //使用实现接口的方式，就不能直接使用Thread类的方法，但是可以间接使用 System.out.println(Thread.currentThread().getName()+&quot;:&quot;+x); &#125; &#125;&#125; MyRunnableDemo类123456789101112131415161718192021package cn.itcast_05;public class MyRunnableDemo &#123; public static void main(String[] args) &#123; // 创建MyRunnable类的对象 MyRunnable my = new MyRunnable(); // 创建Thread类的对象,使用MyRunnable对象作为构造参数 // Thread t1 = new Thread(my); // Thread t2 = new Thread(my); // t1.setName(&quot;林青霞&quot;); // t1.setName(&quot;刘意&quot;); //方式2设置线程名称 Thread t1 = new Thread(my,&quot;林青霞&quot;); Thread t2 = new Thread(my,&quot;刘意&quot;); t1.start(); t2.start(); &#125;&#125; 6.1 既然有方式1，为什么会有方式2呢？实现多线程的方式方式1:继承Thread类步骤：（1）自定义MyThread类继承Thread类（2）在MyThread类中重写run()（3）创建MyThread类对象（4）启动线程对象。问题：（1）为什么要重写run()？run()里面封装的是被线程执行的代码（2）启动线程对象用的是哪个方法？start()（3）run()和start()的区别run():直接调用仅仅是普通方法start():调用是先启动线程，再由JVM调用run().方式2:（1）自定义MyRunnable类实现Runnable接口（2）在MyRunnable类中重写run()（3）创建MyRunnable类对象（4）创建Thread对象，将MyRunnable类对象作为参数传递。问题：（1）有了方式1，为什么还有方式2？解决了单继承的局限性。适合多个相同程序的代码去处理同一个资源的情况，把线程同程序的代码，数据有效分离，较好的体现了面向对象的设计思想。 多线程程序练习1.需求：某电影院有100张票，3个售票窗口，请设计一个程序模拟该电影院售票。使用两种多线程方式实现。（1）继承Thread类方式实现SellTicket类123456789101112package cn.itcast_06;public class SellTicket extends Thread &#123; private static int tickets = 100; @Override public void run() &#123; while(tickets&gt;0) &#123; System.out.println(getName()+&quot;倒数第&quot;+(tickets--)+&quot;票已经卖出&quot;); &#125; &#125;&#125; SellTicketDemo类1234567891011121314151617package cn.itcast_06;public class SellTicketsDemo &#123; public static void main(String[] args) &#123; SellTicket st1 = new SellTicket(); SellTicket st2 = new SellTicket(); SellTicket st3 = new SellTicket(); st1.setName(&quot;窗口1&quot;); st2.setName(&quot;窗口2&quot;); st3.setName(&quot;窗口3&quot;); st1.start(); st2.start(); st3.start(); &#125;&#125; (2)实现Runnable接口方式实现SellTicket类123456789101112package cn.itcast_07;public class SellTicket implements Runnable &#123; private int tickets = 100; @Override public void run() &#123; while(tickets&gt;0) &#123; System.out.println(&quot;倒数第&quot;+(tickets--)+&quot;票已经从&quot;+Thread.currentThread().getName()+&quot;卖出&quot;); &#125; &#125;&#125; SellTicketDemo类123456789101112131415package cn.itcast_07;public class SellTicketsDemo &#123; public static void main(String[] args) &#123; SellTicket st = new SellTicket(); Thread t1 = new Thread(st,&quot;窗口1&quot;); Thread t2 = new Thread(st,&quot;窗口2&quot;); Thread t3 = new Thread(st,&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 上述的售票是实时的，就是刚卖出票，数据就直接传输到网络上，但是实际的网络做不到实时传输，总是存在延迟的情况，所以在出售一张票之后，需要一定时间的延迟，为此，我们对方式2进行改进。（选择方式2是因为在这个情况下方式2比方式1更具有优势，也更好的体现了面向对象的特点）改进需求：每张票卖出后有100ms延迟。通过加入延迟后产生两个问题：（1）相同的票卖了多次这是因为CPU的每一次执行必须是原子性(最简单基本的,无法在分割)的操作。ticket–其实进行了赋值与自减两个操作，当进行完赋值，正要进行自减时，窗口2进来了，此时tickets还未变成99，所以窗口2还是卖出了第100张票，所以出现了上述问题。（2）出现负数票随机性和延迟导致的。其实这就是线程安全的问题，所以接下来我们要学习怎么解决线程安全的问题 7.解决线程安全问题的基本思想首先要判断是否会有线程安全问题？（1）是否是多线程环境（2）是否有共享数据（3）是否有多条语句操作共享数据（上述的练习就是三个语句同时操作共享数据tickets所以才出问题）三个条件我们上述的例子都满足，所以会出现了线程安全问题。多线程环境和共享数据时不可避免的，所以我们解决问题要从（3）入手，将多条语句操作共享数据的代码包装成一个整体，让某个线程在执行的时候，其他线程不能执行。为此，Java为我们提供了同步机制。 7.1 解决线程安全问题实现1同步代码块格式：synchronized(对象){需要同步的代码};使用同步后代码：SellTicket类12345678910111213141516171819202122package cn.itcast_07;public class SellTicket implements Runnable &#123; private int tickets = 100; Object obj = new Object(); @Override public void run() &#123; while(true) &#123; synchronized (obj) &#123; if(tickets&gt;0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;倒数第&quot; + (tickets--) + &quot;票已经从&quot; + Thread.currentThread().getName() + &quot;卖出&quot;); &#125; &#125; &#125; &#125;&#125; SellTicketDemo类123456789101112131415package cn.itcast_07;public class SellTicketsDemo &#123; public static void main(String[] args) &#123; SellTicket st = new SellTicket(); Thread t1 = new Thread(st,&quot;窗口1&quot;); Thread t2 = new Thread(st,&quot;窗口2&quot;); Thread t3 = new Thread(st,&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 7.2 同步的特点、好处、弊端特点：|–前提：多个线程|–解决问题的时候要注意：多个线程使用的是同一个对象好处：同步的出现解决了多线程的安全问题弊端：当线程相当多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率。 7.3 同步代码块的应用同步代码块的锁对象是谁？任意对象同步方法的格式及锁对象问题？同步方法的格式：把同步关键字加在方法上。但是把同步关键字加在方法上会出现不知道锁是谁的问题，就会出现没有同步的结果(从上面的例子来说就是又出现重复票和负数票)同步方法的对象是谁？this静态方法及锁对象问题？class对象(类的字节码文件对象) Sellticket.class]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday22]]></title>
    <url>%2F2019%2F08%2F11%2Fjavaday22%2F</url>
    <content type="text"><![CDATA[一、登录注册IO版(掌握)二、操作基本数据的流1.概述操作基本类型数据的流DataInputStream构造方法:DataInputStream(InputStream in)DataOutputStream构造方法:DataOutputStream(OutputStream out)案例演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package cn.itcast_01;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;/* * DataInputStream 构造方法:DataInputStream(InputStream in) DataOutputStream 构造方法:DataOutputStream(OutputStream out) */public class DataStreamDemo &#123; public static void main(String[] args) throws IOException&#123; write(); read(); &#125; public static void write() throws IOException &#123; DataOutputStream dos = new DataOutputStream(new FileOutputStream(&quot;dos.txt&quot;)); dos.writeByte(10); dos.writeShort(100); dos.writeInt(1000); dos.writeLong(100000000000000l); dos.writeChar(&apos;a&apos;); dos.writeFloat(12.34f); dos.writeDouble(12.56); dos.writeBoolean(true); dos.close(); &#125; public static void read() throws IOException &#123; DataInputStream dis = new DataInputStream(new FileInputStream(&quot;dos.txt&quot;)); System.out.println(dis.readByte()); System.out.println(dis.readShort()); System.out.println(dis.readInt()); System.out.println(dis.readLong()); System.out.println(dis.readChar()); System.out.println(dis.readFloat()); System.out.println(dis.readDouble()); System.out.println(dis.readBoolean()); dis.close(); &#125; &#125; 三、内存操作流1.概述用于处理临时存储信息的，程序结束，数据从内存中消失。2.分类2.1操作字节数组ByteInputStreamByteOutputStream2.2操作字符数组CharArrayReaderCharArrayWriter2.3操作字符串StringReaderStringWriter案例演示1234567891011121314151617181920212223242526272829303132333435363738394041424344package cn.itcast_02;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;/* * * 1.概述用于处理临时存储信息的，程序结束，数据从内存中消失。2.分类2.1操作字节数组ByteInputStreamByteOutputStream2.2操作字符数组CharArrayReaderCharArrayWriter2.3操作字符串StringReaderStringWriter */public class ByteArrayStreamDemo &#123; public static void main(String[] args) throws IOException &#123; //写数据 //创建写字节数组的对象 ByteArrayOutputStream baos = new ByteArrayOutputStream(); //写数据 for(int x=0;x&lt;10;x++) &#123; baos.write((&quot;hello&quot;+x).getBytes()); &#125; //不用释放资源，没有意义 //读数据 ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); int by = 0; while((by=bais.read())!=-1) &#123; System.out.print((char)by); &#125; &#125;&#125; 四、打印流1.概述字节打印流 PrintStream字符打印流 PrintWriter 2.打印流的特点：（1）只有写数据的，没有读取数据，只能操作目的地，不能操作数据源。（2）可以操作任意类型的数据。（3）如果启动了自动刷新，能够自动刷新。（4）该流可以直接操作文本文件。哪些流对象是可以直接操作文本文件的？FileInputStream,FileOutputStream,FileWriter,FileReader.PrintWriter,PrintStream.流可分为基本流和高级流：基本流：就是能够直接读写文件的高级流：在基本流基础上提供了一些其它功能。 3.打印流的特有功能:自动刷新格式：PrintWriter pw = new PrintWriter(new PrintWriter(“pw2.txt”),true);还是应该调用println()才可以这个时候不仅仅自动刷新了，还实现了数据的换行。println()其实等价于：123bw.write();bw.newline();bw.flush(); 五、标准输入输出流(System类)1.概述public static final InputStream in:标准输入流public static final PrintStream out:标准输出流2.三种方式实现键盘录入… 六、随机访问流1.概述RandomAccessFile类不属于流，是Object类的子类。但他融合了InputStream和OutputStream的功能。支持对随机访问文件的读取和写入。构造方法：public RandomAccessFile(String name,String mode):第一个参数是文件路径，第二个参数是操作文件的模式。模式有四种，我们最常用的”rw”，这种方式表示我既可以写数据，也可以读取数据。 七、合并流1.概论a.txt,b.txt合并到c.txt]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday21]]></title>
    <url>%2F2019%2F08%2F09%2Fjavaday21%2F</url>
    <content type="text"><![CDATA[一、字符流1.转换流出现的原因及思想由于字节流操作中文不是特别方便，所以，java就提供了转换流。字符流=字节流+编码表。 2.编码表2.1 概述由现实世界的字符和对应的数值组成的一张表。ASCII码表ISO-8859-1:拉丁码表gb2312:简体中文gbk:gb18030:GBK的取代版本BIG-5码：繁体Unicode:UTF-8:最用三个字节来表示一个字符。能用一个的就用一个(ACSCII兼容)一个表示不了，就用两个实在不行，就用三个。 2.2 编码和解码编码：把看得懂的变成看不懂的。解码：把看不懂的变成看的懂的。 3.字符流3.1 OutputStreamWriterOutputStreamWriter(OutputStream out):根据默认编码把字节流的数据转换成字符流。OutputStreamWriter(OutputStream out，String charsetName):根据默认编码把字节流的数据转换成字符流。把字节流转换为字符流。 3.2 InputStreamReaderInputStreamReader(InputStream is):用默认的编码读取数据InputStreamReader(InputStream is,String charsetName):用指定的编码读取数据。 3.3字符流的5种写数据的方法write(int c):写一个字符write(char[] cbuf):写一个字符数组write(char[] cbuf,int off,int len):写一个字符数组的一部分write(String str):写一个字符串write(String str,int off,int len):写一个字符串的一部分 面试题1.close()和flush()的区别?close()关闭流对象，但是先刷新一次缓冲区。关闭之后，流对象不可以继续再使用了。flush()仅仅刷新缓冲区，刷新之后流对象还可以继续使用。 3.4字符流的2种读数据方法public int read():读取一个字符。public int read(char[] cbuf):读取一个字符数组。 4.转换流的简化写法由于我们常见的操作都是使用本地默认编码，所以，不用指定编码而转换流的长度有点长，所以Java就提供了其子类供我们使用。FileWriter:用法同OutputStreamWriterFileReader:用法同InputStreamReader 5.字符缓冲流的特殊功能写:newLine()读:readLine() 二、IO流练习1.复制文本文件(掌握字符流复制文本文件的五种方式，推荐字符缓冲流的特殊功能，即newLine()和readLine())123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117package cn.itcast_01;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;/* * 复制文本文件 * * 分析： * 复制数据，如果我们知道用记事本打开能够读懂，就用字符流，否则用字节流。 * 字符流有五种方式，推荐掌握第五种，就是字符缓冲流的特殊功能：newLine()和readLine() * * 数据源 * desktop/a.txt * 目的地 * desktop/demo/b.txt * */public class CopyFileDemo &#123; public static void main(String[] args) throws IOException &#123; String srcString = &quot;/Users/chenjie/Desktop/a.txt&quot;; String desString = &quot;/Users/chenjie/Desktop/demo/b.txt&quot;; // method1(srcString,desString); // method2(srcString,desString); //method3(srcString, desString); //method4(srcString,desString); method5(srcString,desString); &#125; //字符缓冲流一次读取一行 private static void method5(String srcString, String desString) throws IOException &#123; BufferedReader br = new BufferedReader(new FileReader(srcString)); BufferedWriter bw = new BufferedWriter(new FileWriter(desString)); String line = null; while((line=br.readLine())!=null) &#123; bw.write(line); bw.newLine(); bw.flush(); &#125; bw.close(); br.close(); &#125; //字符缓冲流一次读取一个字节数组 private static void method4(String srcString, String desString) throws IOException &#123; BufferedReader br = new BufferedReader(new FileReader(srcString)); BufferedWriter bw = new BufferedWriter(new FileWriter(desString)); char[] chs = new char[1024]; int len = 0; while ((len = br.read(chs)) != -1) &#123; bw.write(chs, 0, len); bw.flush(); &#125; bw.close(); br.close(); &#125; // 字符缓冲流一次读取一个字节 private static void method3(String srcString, String desString) throws IOException &#123; BufferedReader br = new BufferedReader(new FileReader(srcString)); BufferedWriter bw = new BufferedWriter(new FileWriter(desString)); int ch = 0; while ((ch = br.read()) != -1) &#123; bw.write(ch); &#125; bw.close(); br.close(); &#125; // 字符流一次读取一个字节数组 private static void method2(String srcString, String desString) throws IOException &#123; FileReader fr = new FileReader(srcString); FileWriter fw = new FileWriter(desString); char[] chs = new char[1024]; int len = 0; while ((len = fr.read(chs)) != -1) &#123; fw.write(chs, 0, len); fw.flush(); &#125; fw.close(); fr.close(); &#125; // 字符流一次读取一个字节 private static void method1(String srcString, String desString) throws IOException &#123; FileReader fr = new FileReader(srcString); FileWriter fw = new FileWriter(desString); int ch = 0; while ((ch = fr.read()) != -1) &#123; fw.write(ch); &#125; fw.close(); fr.close(); &#125;&#125; 2.复制图片(四种方式)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package cn.itcast_01;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;/* * 复制图片的四种方式 */public class CopyFileDemo2 &#123; public static void main(String[] args) throws IOException &#123; String src = &quot;/Users/chenjie/Desktop/a.jpg&quot;; String des = &quot;/Users/chenjie/Desktop/demo/b.jpg&quot;; // method1(src,des); // method2(src,des); // method3(src,des); method4(src, des); &#125; // 一次读取一个字节 private static void method1(String src, String des) throws IOException &#123; FileInputStream fis = new FileInputStream(src); FileOutputStream fos = new FileOutputStream(des); int by = 0; while ((by = fis.read()) != -1) &#123; fos.write(by); &#125; fos.close(); fis.close(); &#125; // 一次读取一个字节数组 private static void method2(String src, String des) throws IOException &#123; FileInputStream fis = new FileInputStream(src); FileOutputStream fos = new FileOutputStream(des); byte[] bys = new byte[1024]; int len = 0; while ((len = fis.read(bys)) != -1) &#123; fos.write(bys, 0, len); &#125; fos.close(); fis.close(); &#125; // 字节缓冲流一次读取一个字节 private static void method3(String src, String des) throws IOException &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(des)); int by = 0; while ((by = bis.read()) != -1) &#123; bos.write(by); &#125; bos.close(); bis.close(); &#125; // 字节缓冲流一次读取一个字节数组 private static void method4(String src, String des) throws IOException &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(des)); byte[] bys = new byte[1024]; int len = 0; while ((len = bis.read(bys)) != -1) &#123; bos.write(bys,0,len); &#125; bos.close(); bis.close(); &#125;&#125; 3.把ArrayList集合中的字符串数据存储到文本文件123456789101112131415161718192021222324252627282930313233package cn.itcast_02;import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;import java.util.ArrayList;/* * 需求：把ArrayList集合中的字符串数据存储到文本文件 */public class ArrayListToFileDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建集合对象 ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); // 创建字符缓冲流输出对象 BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;/Users/chenjie/Desktop/c.txt&quot;)); // 添加元素 array.add(&quot;hello&quot;); array.add(&quot;world&quot;); array.add(&quot;java&quot;); // 遍历 for (String s : array) &#123; bw.write(s); bw.newLine(); bw.flush(); &#125; bw.close(); &#125;&#125; 4.从文本文件中读取数据(每一行为一个字符串数据)到集合中，并遍历集合12345678910111213141516171819202122232425262728package cn.itcast_02;import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;import java.util.ArrayList;/* * 需求：从文本文件中读取数据(每一行为一个字符串数据)到集合中，并遍历集合 */public class FileToArrayListDemo &#123; public static void main(String[] args) throws IOException&#123; BufferedReader br = new BufferedReader(new FileReader(&quot;/Users/chenjie/Desktop/c.txt&quot;)); ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); String s = null; while((s=br.readLine())!=null) &#123; array.add(s); &#125; br.close(); for(String str :array) &#123; System.out.println(str); &#125; &#125;&#125; 5.我有一个文本文件中存储了几个名称，请大家写一个程序实现随机获取一个人的名字。林青霞 风清扬 刘意 武鑫 刘晓曲1234567891011121314151617181920212223242526272829package cn.itcast_02;import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;import java.util.ArrayList;import java.util.Random;/* * 我有一个文本文件中存储了几个名称，请大家写一个程序实现随机获取一个人的名字。 林青霞 风清扬 刘意 武鑫 刘晓曲 */public class GetName &#123; public static void main(String[] args) throws IOException&#123; BufferedReader br = new BufferedReader(new FileReader(&quot;/Users/chenjie/Desktop/c.txt&quot;)); ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); String line = null; while((line=br.readLine())!=null) &#123; array.add(line); &#125; br.close(); Random r = new Random(); int index= r.nextInt(array.size()); System.out.println(&quot;该幸运者是:&quot;+array.get(index)); &#125;&#125; 6.复制单级文件夹1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package cn.itcast_03;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;/* * 复制单级文件夹 * * 数据源:/Users/chenjie/Desktop/demo * 目的地:/Users/chenjie/Desktop/test * * 分析： * （1）封装目录 * （2）获取该目录下所有文件的File数组 * （3）遍历该File数组，得到每一个File对象 * （4）把该File进行复制 * */public class CopyFolderDemo &#123; public static void main(String[] args) throws IOException&#123; //封装目录 File src = new File(&quot;/Users/chenjie/Desktop/demo&quot;); File des = new File(&quot;/Users/chenjie/Desktop/test&quot;); if(!des.exists()) &#123; des.mkdir(); &#125; //获取该目录下所有文件的File数组 File[] fileArray = src.listFiles(); //遍历该File数组，得到每一个File对象 //把该File进行复制 for(File file:fileArray) &#123; File newFile = new File(des,file.getName()); copyFile(file,newFile); &#125; &#125; private static void copyFile(File file, File newFile) throws IOException&#123; //创建字节缓冲流对象 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(newFile)); //复制数据 byte[] bys = new byte[1024]; int len = 0; while((len=bis.read(bys))!=-1) &#123; bos.write(bys,0,len); &#125; &#125;&#125; 7.复制单级文件夹中指定文件并修改文件名称123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package cn.itcast_04;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.FilenameFilter;import java.io.IOException;/* * 复制单级文件夹中指定文件并修改文件名称 * 指定文件是a.txt文件 * 修改后的文件是b.jpg * * 分析： * （1）封装目录 * （2）获取该目录下txt文件的File数组 * （3）遍历该File数组，得到每一个File对象 * （4）把该File进行复制 * （5）在目的地目录下改名 * */public class CopyFolderDemo &#123; public static void main(String[] args) throws IOException &#123; // 封装目录 File scrFolder = new File(&quot;/Users/chenjie/Desktop/demo&quot;); File desFolder = new File(&quot;/Users/chenjie/Desktop/test&quot;); if (!desFolder.exists()) &#123; desFolder.mkdir(); &#125; // 获取该目录下txt文件的File数组 File[] fileArray = scrFolder.listFiles(new FilenameFilter() &#123; @Override public boolean accept(File dir, String name) &#123; return name.endsWith(&quot;.txt&quot;) &amp;&amp; new File(dir, name).isFile(); &#125; &#125;); // 遍历该File数组，得到每一个File对象 for (File file : fileArray) &#123; // 把该File进行复制 File newFile = new File(desFolder, file.getName()); copyFile(file, newFile); &#125; // 在目的地目录下改名 File[] desFileArray = desFolder.listFiles(); for(File desFile:desFileArray) &#123; String newName = desFile.getName().replace(&quot;.txt&quot;, &quot;.jpg&quot;); File newFile = new File(desFolder,newName); desFile.renameTo(newFile); &#125; &#125; private static void copyFile(File file, File newFile) throws IOException &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(newFile)); byte[] bys = new byte[1024]; int len = 0; while ((len = bis.read(bys)) != -1) &#123; bos.write(bys, 0, len); &#125; bos.close(); bis.close(); &#125;&#125; 8.复制多级文件夹123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package cn.itcast_05;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;/* * 复制多级文件夹 * * 分析: * （1）封装数据源File * （2）封装目的地File * （3）判断该File是文件夹还是文件 * （3.1）是文件夹 * 就在目的地目录创建该文件夹 * 获取该File对象下的所有文件或文件夹对象 * 遍历每得到每一个File对象 * 回到（3） * （3.2）是文件 * 就复制（字节流） */public class CopyFolderDemo &#123; public static void main(String[] args) throws IOException &#123; // 封装数据源File File srcFile = new File(&quot;/Users/chenjie/Desktop/demo&quot;); // 封装目的地File File desFile = new File(&quot;/Users/chenjie/Desktop/test&quot;); if (!desFile.exists()) &#123; desFile.mkdir(); &#125; // 复制文件夹功能 copyFolder(srcFile, desFile); &#125; private static void copyFolder(File srcFile, File desFile) throws IOException &#123; if (srcFile.isDirectory()) &#123; // 文件夹 // 在目的地文件加中创建创建文件夹 File newFile = new File(desFile, srcFile.getName()); newFile.mkdir(); // 获取该File对象下的所有文件或文件夹对象 File[] fileArray = srcFile.listFiles(); // 遍历每得到每一个File对象 for(File file:fileArray) &#123; copyFolder(file,newFile); &#125; &#125; else &#123; // 文件 File newFile = new File(desFile,srcFile.getName()); copyFile(srcFile, newFile); &#125; &#125; private static void copyFile(File srcFile, File desFile) throws IOException &#123; // 创建字节缓冲流对象 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(srcFile)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(desFile)); // 复制数据 byte[] bys = new byte[1024]; int len = 0; while ((len = bis.read(bys)) != -1) &#123; bos.write(bys, 0, len); &#125; bos.close(); bis.close(); &#125;&#125; 9.键盘录入5个学生信息(姓名，语文成绩，数学成绩，英语成绩)，按总分从高到低存入文本文件。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package cn.itcast_06;import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;import java.util.Comparator;import java.util.Scanner;import java.util.TreeSet;/* * 键盘录入5个学生信息(姓名，语文成绩，数学成绩，英语成绩)，按总分从高到低存入文本文件。 * * * 分析： * （1）创建学生对象 * （2）创建集合对象 * TreeSet&lt;Student&gt; * （3）键盘录入学生信息存储到集合 * （4）遍历集合，把数据写入文本文件 */public class StudentDemo &#123; public static void main(String[] args) throws IOException &#123; //创建集合对象 TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student s1, Student s2) &#123; int num = s2.getSum()-s1.getSum(); int num2 = num==0?s1.getChinese()-s2.getChinese():num; int num3 = num2==0?s1.getMath()-s2.getMath():num2; int num4 = num3==0?s1.getEnglish()-s2.getEnglish():num3; int num5 = num4==0?s1.getName().compareTo(s2.getName()):num4; return num5; &#125; &#125;); //键盘录入学生信息存储到集合 for(int x=1;x&lt;=5;x++) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入第&quot;+x+&quot;个同学的信息:&quot;); System.out.println(&quot;姓名：&quot;); String name = sc.nextLine(); System.out.println(&quot;语文成绩：&quot;); int chinese = sc.nextInt(); System.out.println(&quot;数学成绩：&quot;); int math = sc.nextInt(); System.out.println(&quot;英语成绩：&quot;); int english = sc.nextInt(); //创建学生对象 Student s = new Student(name,chinese,math,english); //把学生信息添加到集合中 ts.add(s); &#125; //遍历集合，把数据写入文本文件 BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;Student.txt&quot;)); bw.write(&quot;学生信息如下：&quot;); bw.newLine(); bw.flush(); bw.write(&quot;姓名，语文成绩，数学成绩，英语成绩&quot;); bw.newLine(); bw.flush(); for(Student s:ts) &#123; StringBuilder sb = new StringBuilder(); sb.append(s.getName()).append(&quot;,&quot;).append(s.getChinese()).append(&quot;,&quot;).append(s.getMath()).append(&quot;,&quot;).append(s.getEnglish()); String str = String.valueOf(sb); bw.write(str); bw.newLine(); bw.flush(); &#125; bw.close(); System.out.println(&quot;学生信息存储完毕&quot;); &#125;&#125; 10.已知s.txt文件中有这样一个字符串:“fsdafsafasljlasdjflaskjdlfjs”请编写程序读取数据内容，把数据排序后写入ss.txt1234567891011121314151617181920212223242526272829303132333435363738394041424344package cn.itcast_07;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.util.Arrays;/* * 需求：已知s.txt文件中有这样一个字符串: “fsdafsafasljlasdjflaskjdlfjs” 请编写程序读取数据内容，把数据排序后写入ss.txt * 分析 * （1）创建s.txt文件 * （2）读取该文件的内容，存到一个字符串中 * （3）将字符串转成字符数组 * （4）对字符数组进行排序 * （5）字符数组转为字符串 * （5）创建ss.txt，写入字符串 */public class StringDemo &#123; public static void main(String[] args) throws IOException&#123; //创建s.txt文件,读取该文件的内容，存到一个字符串中 BufferedReader br = new BufferedReader(new FileReader(&quot;s.txt&quot;)); String line = br.readLine(); br.close(); //将字符串转成字符数组 char[] chs = line.toCharArray(); //对字符数组进行排序 Arrays.sort(chs); //字符数组转为字符串 String s = new String(chs); //创建ss.txt，写入字符串 BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;ss.txt&quot;)); bw.write(s); bw.close(); &#125;&#125; 11.用Reader模拟BufferedReader的readLine()功能readLine()的特点：一次读取一行，根据换行符判断是否结束，只返回内容，不返回换行符。12.自定义模拟LineNumberReader的特有功能获取每次读取数据的行号 三、案例]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday20]]></title>
    <url>%2F2019%2F08%2F09%2Fjavaday20%2F</url>
    <content type="text"><![CDATA[一、递归1.递归概述递归:方法定义中调用方法本身的现象。(方法的嵌套调用不是递归)注意事项：（1）递归一定要有出口，否则就是死递归。举例：1234567public void show(int n) &#123; if(n&lt;=0) &#123; System.exit(0); &#125; System.out.println(n); show(--n);//这个--n就是保证出口，防止死递归。&#125; （2）递归的次数不嫩太多，否则内存容易溢出。（3）构造方法不能递归使用。 递归练习1.不死神兔问题1，1，2，3，5，8…求第20个数。(三种方法：数组实现，变量的变化实现，递归实现)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package cn.itcast_02;/* * 斐波那契数的实现，第20个数 * * 三种方法： * （1）数组实现 * （2）变量的变化实现 * （3）递归实现 */public class DiGuiDemo2 &#123; public static void main(String[] args) &#123; // 数组实现 int[] arr = new int[20]; arr[0] = 1; arr[1] = 1; for (int x = 2; x &lt; arr.length; x++) &#123; arr[x] = arr[x - 1] + arr[x - 2]; &#125; System.out.println(arr[19]); // 变量的变化实现 // 两个相邻的数 // 第一次：1，1 // 第二次：1，2 // 第三次：1，3 // 。。。 int a = 1; int b = 1; for (int x = 0; x &lt; 18; x++) &#123; int temp = a; a = b; b = temp + b; &#125; System.out.println(b); //递归实现 int result = fib(20); System.out.println(result); &#125; //返回值类型：int //参数列表：int n public static int fib(int n) &#123; if(n==1 || n==2) &#123; return 1; &#125;else &#123; return fib(n-1)+fib(n-2); &#125; &#125;&#125; 2.删除带内容的文件夹目录12345678910111213141516171819202122232425262728293031323334353637383940414243444546package cn.itcast_03;import java.io.File;/* * * 需求：递归删除带内容的目录 * * 目录已经给定：demo * * 分析： * （1）封装目录 * （2）获取该目录下的所有文件或文件夹的File数组 * （3）遍历该File数组，得到每一个File对象 * （4）判断File对象是否是文件夹 * 是：回到（2） * 不是：删除。 * */public class FileDeleteDemo &#123; public static void main(String[] args) &#123; //封装目录 File srcFolder = new File(&quot;/Users/chenjie/Desktop/demo&quot;); //递归实现 deleteFolder(srcFolder); &#125; public static void deleteFolder(File srcFolder) &#123; //获取该目录下的所有文件或文件夹的File数组 File[] fileArr = srcFolder.listFiles(); //遍历该File数组，得到每一个File对象 for(File file:fileArr) &#123; if(file.isDirectory()) &#123; deleteFolder(file); &#125;else if(file.isFile()) &#123; System.out.println(file.getName()+&quot;---&quot;+file.delete()); &#125; &#125; System.out.println(srcFolder.getName()+&quot;---&quot;+srcFolder.delete()); &#125;&#125; 二、IO流1.IO流概述IO流用来处理设备之间的数据传输问题。就是上传文件和下载文件。Java对数据的操作是通过流的方式。Java用于操作流的对象都在IO包中。 2.IO流分类（1）按流向输入流（读取数据）输出流（写出数据）（2）按数据类型字节流字符流（文本数据就使用字符流）一般探讨IO流默认是按数据类型分。 3.IO流常用基类字节输入流 InputStream字节输出流 OutputStream字符输入流 Reader字符输出流 Writer 4.简单案例演示需求：我要往一个文本文件中输入一句话：hello,io。分析：（1）这个操作最好采用字符流来做，但是字符流是在字节流之后才出现的，所以先试试字节流如何操作。（2）由于我是要往文件中写一句话，所以我们要采用字节输出流通过上面的分析，我们知道要使用：FileOutputStream注意：每种基类的子类都是以父类名作为后缀名。XxxOutputStreamXxxInputStreamXxxReaderXxxWriter 4.1 FileOutputStream构造方法：FileOutputStream(File file)FileOutputStream(String name)创建字节输出流对象做了哪几件事？（1）调用系统功能去创建文件（2）创建fos对象（3）把fos对象指向这个文件1234567891011121314151617181920212223242526272829package cn.itcast_01;import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;public class FileOutputStreamDemo &#123; public static void main(String[] args) throws IOException &#123; //创建字节流输出对象 //FileOutputStream(File file) //File file = new File(&quot;fos.txt&quot;); //FileOutputStream fos = new FileOutputStream(file); //FileOutputStream(String name) FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;); //写数据 //String s = &quot;hello,io&quot;; //byte[] bys = s.getBytes(); fos.write(&quot;hello,io&quot;.getBytes()); //释放资源 //关闭此文件输出流并释放与此流有关的所有系统资源 fos.close(); //为什么一定要close()呢？ //（1）让流对象变成垃圾，这样就可以被垃圾回收器回收了。 //（2）通知系统去释放跟该文件相关的资源。 &#125;&#125; 12345678910111213141516171819202122232425262728package cn.itcast_01;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;/* * 往文件中写入数据 */public class FileOutputStreamDemo2 &#123; public static void main(String[] args) throws IOException &#123; //创建字节输出流对象 FileOutputStream fos2 = new FileOutputStream(&quot;fos2.txt&quot;,true); //写入数据 fos2.write(97); fos2.write(57); fos2.write(55); //写一个字节数组的一部分 byte[] bys = &#123;97,98,99,100,101&#125;; fos2.write(bys,1,3); //释放资源 fos2.close(); &#125;&#125; 5.FileInputStream读取数据的方式：（1）int read():一次读取一个字节（2）int read(byte[] b):一个读取一个字节数组123456789101112131415161718192021222324252627282930313233343536373839404142package cn.itcast_02;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;/* * 字节输入流 * 字节数据读取演示 */public class FileInputStreamDemo &#123; public static void main(String[] args) throws IOException &#123; //创建字节输入流 FileInputStream fis = new FileInputStream(&quot;fis.txt&quot;); //调用read()读取数据 // int by = fis.read(); // System.out.println(by); // System.out.println((char)by); // by = fis.read(); // System.out.println(by); // System.out.println((char)by); //读取多次可以用循环改进，麻烦的是如何控制循环判断条件 //经过测试我们知道，如果读取的结果是-1，说明已经读取到文件的结尾了。 //所以改进结果如下 // int by = fis.read(); // while(by != -1) &#123; // System.out.print((char)by); // by = fis.read(); // &#125; //上述代码不够简洁，最终版代码如下 int by = 0; while((by=fis.read())!=-1) &#123; System.out.print((char)by); &#125; //释放资源 fis.close(); &#125;&#125; 练习1.复制文本文件2.把hahaha.jpg内容复制到当前目录的mn.jpg3.把hahaha.mp4复制到当前目录的copy.mp4 5.2一次读取一个字节数组12345678910111213141516171819202122232425262728293031323334353637383940package cn.itcast_02;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;/* * 一次读取一个数组 */public class FileInputStreamDemo2 &#123; public static void main(String[] args) throws IOException &#123; //创建字节输入流对象 FileInputStream fis = new FileInputStream(&quot;a.txt&quot;); // byte[] bys = new byte[20]; // int len=fis.read(bys);//返回的是实际读取的个数 // System.out.println(len); // System.out.println(new String(bys)); //经过测试，如果fis.read()的结果是-1，说明已经没有数据可读了。 //所以代码复制的改进如下 // byte[] bys = new byte[5]; // int len=0; // while((len=fis.read(bys))!=-1) &#123; // System.out.print(new String(bys,0,len)); // &#125; //数组的长度一般是1024或者1024的整数倍。 //所以最终版如下 byte[] bys = new byte[1024]; int len=0; while((len=fis.read(bys))!=-1) &#123; System.out.print(new String(bys,0,len)); &#125; //释放资源 fis.close(); &#125;&#125; 6.字节缓冲区流Java在设计的时候提供了字节缓冲区流来读写数据。写数据：BufferedOutputStream读数据：BufferedInputStream构造方法可以指定缓冲区的大小，但我们一般用不上，因为默认缓冲区大小就足够了。//BuffredOutputStream(OutputStream out)为什么不直接传递一个具体的文件或文件路径，而是传递一个OutputStream对象呢？因为字节缓冲区仅仅提供缓冲区，为高效而设计的。真正的读写操作还得靠基本的流对象实现。缓冲区写数据案例演示1234567891011121314151617181920212223package cn.itcast_03;import java.io.BufferedOutputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;/* * * 字节输出流缓冲区演示 */public class BufferedOutputStreamDemo &#123; public static void main(String[] args) throws IOException &#123; //创建字节输出流缓冲区对象 BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;bos.txt&quot;)); //写入数据 bos.write(&quot;helloworld java&quot;.getBytes()); //释放资源，只要释放bos就行 bos.close(); &#125;&#125; 练习1.四种方式复制文件普通复制，一次读取一个字节高效复制，一次读取一个字节普通复制，一次读取一个字节数组高效复制，一次读取一个字节数组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package cn.itcast_04;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;/* * 四种方法copy文件 */public class IOTest &#123; public static void main(String[] args) throws IOException &#123; method1(&quot;a.txt&quot;, &quot;b1.txt&quot;);// 共耗时：6233毫秒 method2(&quot;a.txt&quot;, &quot;b2.txt&quot;);// 共耗时：43毫秒 method3(&quot;a.txt&quot;, &quot;b2.txt&quot;);// 共耗时：8毫秒 method4(&quot;a.txt&quot;, &quot;b2.txt&quot;);// 共耗时：3毫秒 &#125; // 两个明确 // 返回值：void // 参数列表：String a,String b // 普通复制，一次获取一个字节 public static void method1(String a, String b) throws IOException &#123; long startTime = System.currentTimeMillis(); // 创建字节输入流对象 FileInputStream fis = new FileInputStream(a); // 创建字节输出流对象 FileOutputStream fos = new FileOutputStream(b); int by = 0; while ((by = fis.read()) != -1) &#123; fos.write(by); &#125; // 释放资源 fos.close(); fis.close(); long endTime = System.currentTimeMillis(); System.out.println(&quot;共耗时：&quot; + (endTime - startTime) + &quot;毫秒&quot;); &#125; // 高效复制，一次获取一个字节 public static void method2(String a, String b) throws IOException &#123; long startTime = System.currentTimeMillis(); // 创建字节输入流对象 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(a)); // 创建字节输出流对象 BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(b)); int by = 0; while ((by = bis.read()) != -1) &#123; bos.write(by); &#125; // 释放资源 bos.close(); bis.close(); long endTime = System.currentTimeMillis(); System.out.println(&quot;共耗时：&quot; + (endTime - startTime) + &quot;毫秒&quot;); &#125; // 普通复制，一次获取一个字节数组 public static void method3(String a, String b) throws IOException &#123; long startTime = System.currentTimeMillis(); // 创建字节输入流对象 FileInputStream fis = new FileInputStream(a); // 创建字节输出流对象 FileOutputStream fos = new FileOutputStream(b); byte[] bys = new byte[1024]; int len = 0; while ((len = fis.read(bys)) != -1) &#123; fos.write(bys, 0, len); &#125; // 释放资源 fos.close(); fis.close(); long endTime = System.currentTimeMillis(); System.out.println(&quot;共耗时：&quot; + (endTime - startTime) + &quot;毫秒&quot;); &#125; // 高效复制，一次获取一个字节数组 public static void method4(String a, String b) throws IOException &#123; long startTime = System.currentTimeMillis(); // 创建字节输入流对象 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(a)); // 创建字节输出流对象 BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(b)); byte[] bys = new byte[1024]; int len = 0; while ((len = bis.read(bys)) != -1) &#123; bos.write(bys, 0, len); &#125; // 释放资源 bos.close(); bis.close(); long endTime = System.currentTimeMillis(); System.out.println(&quot;共耗时：&quot; + (endTime - startTime) + &quot;毫秒&quot;); &#125;&#125;]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday19]]></title>
    <url>%2F2019%2F08%2F08%2Fjavaday19%2F</url>
    <content type="text"><![CDATA[一、异常1.异常概述程序的异常：Throwable严重问题：Error 我们不处理，这种问题一般都是很严重的，比如说内存溢出。问题：Exception 编译期问题：不是RuntimeException的异常 必须处理的，因为不处理，编译就不能通过。 运行期问题：RuntimeException 不处理，这个问题出现肯定是我们的代码不够严谨，需要修正代码 2.JVM的异常默认处理方案（1）把异常的名称，错误原因及异常出现的位置等信息输出在了控制台。 3.异常处理方案3.1 try…catch…finallytry…catch…finally的处理格式 :try { 可能出现问题的代码;}catch (异常名 变量) { 针对问题的处理；}finally { 释放资源；} 变形格式：try { 可能出现问题的代码;}catch (异常名 变量) { 针对问题的处理；}注意：try里面的代码越少越好。catch里面必须有内容，哪怕是给出一个简单的提示。 3.2 throws 抛出（2）程序停止运行。 4.编译期异常与运行期异常的区别编译期异常：Java程序必须显示处理，否则程序就会发生错误，无法通过编译。运行时异常：无需显示处理，也可以和编译时异常一样处理。 5.Throwable的几个方法public String getMessage():异常的消息字符串public String toString():返回异常的简单信息描述。此对象的类name(全路径名)“：”(冒号和一个空格)调用此对象getLocalizedMessage()的结果(默认返回到的是getMessage()内容)printStackTrace()获取异常类名和异常信息，以及异常出现在程序中的位置，返回值void。 6.throws定义功能方法时，需要把出现的问题暴露出来让调用者去处理，那么就通过throws在方法上标识。 6.1 前提有些时候我们是可以对异常进行处理的，但是又有时候，我们根本就没有权限去处理这个异常。或者说，我处理不了，我就不处理了。为了解决出错问题，Java针对这种情况，就提供了一个处理方法：抛出。格式：throws 异常类名注意：这个格式必须跟在方法的括号后面。在方法声明上抛出，是为了告诉调用者，这个方法可能会有问题。尽量不要在main()抛出异常，没有意义。小结：编译器异常抛出，将来调用者必须处理。运行期异常抛出，将来调用可以不处理。 7.throw(与前面的throws不相同)throw:如果出现了异常情况，我们可以把该异常抛出，这个时候抛出的应该是异常的对象，而不是异常的类。、12345678910111213141516171819package cn.itcast_06;/* * throw:如果出现了异常情况，我们可以把该异常抛出，这个时候抛出的应该是异常的对象，而不是异常的类。 */public class ExceptionDemo &#123; public static void main(String[] args) &#123; method(); &#125; public static void method() &#123; int a =10; int b=0; if(b==0) &#123; throw new ArithmeticException(); &#125;else &#123; System.out.println(a/b); &#125; &#125;&#125; 面试题1.throws和throw的区别throws：用在方法声明后面，跟的是异常类名可以跟多个异常类名，用逗号隔开。表示抛出异常，由该方法的调用者来处理throws表示出现异常的一种可能性，并不一定会发生这些异常throw：用在方法体内，跟的是异常对象名只能抛出一个异常对象名表示抛出异常，有方法体内的语句处理执行throw一定是抛出了某种异常 总结：那我们到底如何处理异常原则：如果该功能内部可以将问题处理，用try，如果处理不了，交由调用者处理，就用throws区别：后续程序需要继续运行就用try后续程序不需要继续进行就throws举例：感冒了自己吃点药就好了。try吃了好几天药都没好结果得了H7N9，那就得throws到医院了.如果医院没有特效药就变成Error了。 二、finally的特点作用及面试题格式：try…catch..finally特点：被finally控制的语句一定会执行。作用：用于释放资源，在IO流操作和数据库操作中会见到。 面试题1.final，finally，finalize的区别final 最终的意思，可以修饰类（类不能被继承），成员变量（变量是常量），成员方法（方法不能被重写）finally 异常处理的一部分，用于释放资源。一般来说代码肯定会执行，特殊情况，在执行到finally之前JVM退出了，代码就执行不了了。finalize 是Object类的一个方法，用于垃圾回收。2.如果catch里面有return语句，请问finally里面的代码还会执行吗？如果会，是在return前还是return后。会。前。准确的说，应该是在中间。3.try…catch…finally的格式变形A:try…catch…finallyB:try…catchC:try…finallyD:try…catch…catch…finallytry一定要有。 三、自定义异常Java不可能囊括我们开发时所碰到的所有异常，所以有时候我们要自己定义异常类，这个类必须继承Exception类或RuntimeException类。演示：自定义异常类1234567891011package cn.itcast_08;public class MyException extends Exception&#123; public MyException() &#123; super(); &#125; public MyException(String message) &#123; super(message); &#125;&#125; 自定义教师类并加入检查功能1234567891011package cn.itcast_08;public class Teacher &#123; public void check(int score) throws MyException &#123; if(score&gt;100 || score&lt;0) &#123; throw new MyException(&quot;分数只能在0～100之间&quot;); &#125;else &#123; System.out.println(&quot;分数没有问题&quot;); &#125; &#125;&#125; 自定义测试类123456789101112131415161718192021222324package cn.itcast_08;import java.util.Scanner;/* * 自定义异常演示 * */public class ExceptionDemo &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入要检查的分数：&quot;); int score = sc.nextInt(); //创建教师对象，调用检查方法 Teacher t = new Teacher(); try &#123; t.check(score); &#125; catch (MyException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 异常的注意事项(总结)（1）子类重写父类方法时，子类的方法必须抛出相同的异常或父类异常的子类(父亲坏了，儿子不能比父亲更坏)（2）如果父类抛出了多个异常，子类重写父类时，只能抛出相同的异常或是它的子集，不能抛出父类没有的异常。（3）如果被重写的方法没有异常抛出，那么子类的方法绝对不可以抛出异常，如果子类方法内有异常发生，那么子类只能try，不能throws 四、File类1.File概述文件和目录路径名的抽象表示形式。我们要实现IO的操作，就必须知道硬盘上文件的表现形式。而Java提供了一个类File供我们使用。 2.File类的构造方法File(String pathname):根据一个路径得到File对象。File(String parent,String child):根据一个目录和一个子文件/目录(可能是文件，也可能是目录)得到一个FIle对象。File的对象不一定是文件，也可能是文件夹。File(File parent,String child):根据一个父File对象和一个子文件/目录得到File对象。 3.File类的创建功能public boolean createNewFile():创建文件，如果没有路径，默认是当前项目的路径。public boolean mkdir():创建文件夹，如果存在这样的文件夹，就不创建了，返回false。public boolean mkdirs():创建多级文件夹，如果路径中存在未创建的父文件夹，执行该命令会进行创建。如果使用该命令创建文件而不是文件夹，最后的结果是创建一个以文件名为名字(带后缀)的文件夹. 4.File类的删除功能public boolean delete()Java中的删除不走回收站。 5.File类的重命名功能public boolean renameTo(File dest)路径以盘符开始:绝对路径路径不以盘符开始:相对路径如果路径名相同就是改名。如果路径名不同，就是改名加剪切。 6.File类的判断功能isDirectory():是否是目录isFile():是否是文件exists():是否存在canRead():是否可读canWrite():是否可写isHidden():是否隐藏 7.File类的基本获取功能getAbsolutePath():绝对路径getPath():相对路径(相对于本项目的路径)getName():获得文件名length():lastModified():上次修改时间 8.File类的高级获取功能String[] list():获取指定目录下的所有文件或文件夹的名称数组File[] listFiles():获取指定目录下的所有文件或文件夹的File数组 练习1.判断桌面目录下是否有后缀名为.jpg的文件，如果有，就输出该文件的名称。方法1:先遍历，然后判断是否符合条件，符合条件的话就输出123456789101112131415161718192021222324252627282930313233package cn.itcast_08;import java.io.File;/* * 练习1 */public class FileDemo &#123; public static void main(String[] args) &#123; //封装桌面目录 File file = new File(&quot;/Users/chenjie/Desktop&quot;); //获取该目录下所有文件或文件夹的File数组。 File[] fileArray = file.listFiles(); //遍历该File数组，得到每一个File对象 //判断是否是文件 //是：继续判断是否是以.jpg结尾 // 是：输出文件名 // 否：不理它 //否：不理它 for(File f:fileArray) &#123; if(f.isFile()) &#123; if(f.getName().endsWith(&quot;.jpg&quot;)) &#123; System.out.println(f.getName()); &#125; &#125; &#125; &#125;&#125; 方法2:获取时就进行判断是否符合条件，符合条件后再添加到数组中，最后遍历数组。要想实现方法2，要学习一个新的知识点文件过滤器的实现思想和代码体现String[] list(FilenameFilter filter):File[] listFiles(FilenameFilter filter):1234567891011121314151617181920212223242526272829303132333435package cn.itcast_08;import java.io.File;import java.io.FilenameFilter;/* * 文件过滤器 */public class FIleDemo2 &#123; public static void main(String[] args) &#123; //封装桌面目录 File file = new File(&quot;/Users/chenjie/Desktop&quot;); //获取该目录下所有文件或文件夹的File数组。 File[] fileArray = file.listFiles(); String[] strArray = file.list(new FilenameFilter() &#123; @Override public boolean accept(File dir, String name) &#123; // File file = new File(dir,name); // boolean flag = file.isFile(); // boolean flag2 = name.endsWith(&quot;.jpg&quot;); // return flag &amp;&amp; flag2; //改进 return new File(dir,name).isFile() &amp;&amp; new File(dir,name).getName().endsWith(&quot;.jpg&quot;); &#125; &#125;); //遍历 for(String s:strArray) &#123; System.out.println(s); &#125; &#125;&#125; 2.批量修改文件名称123456789101112131415161718192021222324252627282930313233343536373839404142package cn.itcast_09;import java.io.File;/* * 需求：把桌面的文件夹中的文件名进行批量修改 * * 思路： * （1）封装目录 * （2）获取该目录下所有文件的File数组 * （3）遍历该File数组，得到每一个File对象 * （4）拼接一个新的名称，然后重命名即可。 */public class FileDemo &#123; public static void main(String[] args) &#123; //封装目录 File srcFolder = new File(&quot;/Users/chenjie/Desktop/demo&quot;); //获取该目录下所有的文件的File数组 File[] fileArray = srcFolder.listFiles(); //（3）遍历该File数组，得到每一个File对象 //（4）拼接一个新的名称，然后重命名即可。 for(File file:fileArray) &#123; if(file.isFile()) &#123; if(file.getName().endsWith(&quot;.jpg&quot;)) &#123; String name = file.getName(); int startIndex = name.indexOf(&quot;_&quot;); String numberString = name.substring(startIndex+1,startIndex+4); int lastIndex = name.lastIndexOf(&quot;_&quot;); String nameString = name.substring(lastIndex+1,lastIndex+5); StringBuilder sb = new StringBuilder(); sb.append(numberString).append(&quot;_&quot;).append(nameString).append(&quot;.jpg&quot;); String result = String.valueOf(sb); File newFile = new File(srcFolder,result); file.renameTo(newFile); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday18]]></title>
    <url>%2F2019%2F08%2F07%2Fjavaday18%2F</url>
    <content type="text"><![CDATA[一、Map1.Map概述针对只知道学号，不知道学生名字的情况，Java提供了一个新的集合类：Map通过查看API，我们知道Map集合的一个最大的特点，就是它可以存储键值对的元素，这个时候存储我们上面的需求，就可以这样做学号1 姓名1学号2 姓名2学号3 姓名3学号不可重复，名字可以重复 2.Map集合的特点2.1 将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。Map集合和Collection集合的区别？Map集合存储元素是成对出现的。Map集合的键是唯一的，值是可重复的。Collection集合存储元素是单独出现的。Set是唯一的，List是可重复的。2.2Map集合的数据结构只对键有效，跟值无关。Collection集合的数据结构是针对元素有效。 3.Map集合的功能概述3.1 添加功能V put(K key,V value):添加或修改元素。如果键是第一次存储，就直接存储元素，返回null如果键不是第一次存储，就用值把以前的值替换掉，返回以前的值。3.2 删除功能void clear()：移除所有的键值对元素。V remove(Object key):根据键删除键值对元素，并把值返回。3.3 判断功能boolean containsKey(Object key)：判断集合是否包含指定的键。boolean containsValue(Object value)：判断集合是否包含指定的键。boolean isEmpty():判断集合是否为空。3.4 获取功能Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet():???V get(Object key):根据键获取值。Set keySet():获取集合中所有键的集合。Collection values():获取集合中所有值的集合。3.5 长度功能int size():返回集合中的键值对的对数。 练习1.Map集合的遍历123456789101112131415161718192021222324252627282930package cn.itcast_01;import java.util.HashMap;import java.util.Map;import java.util.Set;/* * Map集合的遍历 */public class MapDemo3 &#123; public static void main(String[] args) &#123; //创建集合对象 Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); //创建元素并添加到集合 map.put(&quot;杨过&quot;, &quot;小龙女&quot;); map.put(&quot;郭靖&quot;, &quot;黄蓉&quot;); map.put(&quot;杨康&quot;, &quot;穆念慈&quot;); map.put(&quot;陈玄风&quot;, &quot;梅超风&quot;); //遍历 //获取所有的键 Set&lt;String&gt; set = map.keySet(); for(String key:set)&#123; //根据键去找值 String s = map.get(key); System.out.println(key+&quot;---&quot;+s); &#125; &#125;&#125; 方法2:1234567891011121314151617181920212223242526272829303132333435363738package cn.itcast_01;import java.util.HashMap;import java.util.Map;import java.util.Set;/* * 获得所有键值对对象的集合 * 遍历键值对对象的集合，得到每一个键值对对象 * 根据键值对对象获取键和 * * * * 键值对对象如何表示： * Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet():返回的是键值对对象的集合。 */public class MapDemo4 &#123; public static void main(String[] args) &#123; //创建集合对象 Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); //创建元素并添加到集合 map.put(&quot;杨过&quot;, &quot;小龙女&quot;); map.put(&quot;郭靖&quot;, &quot;黄蓉&quot;); map.put(&quot;杨康&quot;, &quot;穆念慈&quot;); map.put(&quot;陈玄风&quot;, &quot;梅超风&quot;); //获取所有键值对对象的集合 Set&lt;Map.Entry&lt;String,String&gt;&gt; set = map.entrySet(); //遍历键值对对象的集合，得到每一个键值对对象 for(Map.Entry&lt;String, String&gt; me:set) &#123; //根据键值对对象获取键和值 String key = me.getKey(); String value = me.getValue(); System.out.println(key+&quot;---&quot;+value); &#125; &#125;&#125; 二、HashMap1.概述是基于哈希表的Map接口实现。哈希表的作用是用来保证键的唯一性，依赖于hasCode()和equals() 2.HashMap键值不同的案例键是String，值是String键是Integer，值是String键是String，值是Student键是Student，值是String。 三、TreeMap1.概述键是红黑树结构，可以保证键的排序和唯一性。 2.TreeMap键不同的案例TreeMap&lt;String,String&gt;Treemap&lt;Student,String&gt; Map集合案例1.需求：”aababcabcdabcde”,获取字符串中每一个字母出现的次数要求结果：a(5)b(4)c(3)d(2)e(1)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package cn.itcast_05;import java.util.Scanner;import java.util.Set;import java.util.TreeMap;/* * 需求：&quot;aababcabcdabcde&quot;,获取字符串中每一个字母出现的次数要求结果：a(5)b(4)c(3)d(2)e(1) * * * 分析： * （1）定义一个字符串（可改进为键盘录入） * （2）定义一个TreeMap集合 * 键：Character * 值：Integer * （3）把字符串转换为字符数组 * （4）遍历字符数组，得到每一个字符 * （5）拿刚才得到的字符作为键到集合中去找值，看返回值 * 是null：说明该键不存在，就把该字符作为键，1作为值存储 * 不是null：说明该键存在，就把值加1，然后重新存储该键和值。 * （6）定义字符串缓冲区变量 * （7）遍历集合，得到键和值，进行按照要求拼接。 * （8）把字符串缓冲区转换为字符串输出。 * * */public class TreeMapDemo &#123; public static void main(String[] args) &#123; //定义一个键盘录入的字符串 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入字符串：&quot;); String line = sc.nextLine(); //定义一个TreeMap集合 TreeMap&lt;Character,Integer&gt; tm = new TreeMap&lt;Character,Integer&gt;(); //把字符串转换成字符数组 char[] chs = line.toCharArray(); //遍历字符数组，得到每一个字符 for(char ch:chs) &#123; //拿刚才得到的字符作为键到集合中去找值，看返回值 Integer i = tm.get(ch); //是null：说明该键不存在，就把该字符作为键，1作为值存储 if(i == null) &#123; tm.put(ch, 1); &#125;else &#123; // 不是null：说明该键存在，就把值加1，然后重新存储该键和值。 i++; tm.put(ch, i); &#125; &#125; //定义字符串缓冲区变量 StringBuilder sb = new StringBuilder(); //遍历集合，得到键和值，进行按照要求拼接。 Set&lt;Character&gt; set = tm.keySet(); for(Character ch:set) &#123; Integer i = tm.get(ch); sb.append(ch).append(&quot;(&quot;).append(i).append(&quot;)&quot;); &#125; String str = String.valueOf(sb); System.out.println(str); &#125;&#125; 2.集合的嵌套遍历2.1HashMap嵌套HashMap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package cn.itcast_05;import java.util.HashMap;import java.util.Set;/* * HashMap嵌套HashMap * * 传智播客 * jc 基础班 * 陈玉楼 20 * 高跃 22 * jy 就业班 * 李杰 21 * 曹石磊 23 * * */public class HashMapDemo2 &#123; public static void main(String[] args) &#123; //创建集合对象 HashMap&lt;String,HashMap&lt;String,Integer&gt;&gt; czbkMap = new HashMap&lt;String,HashMap&lt;String,Integer&gt;&gt;(); //创建基础班集合对象 HashMap&lt;String,Integer&gt; jcMap = new HashMap&lt;String,Integer&gt;(); jcMap.put(&quot;陈玉楼&quot;, 20); jcMap.put(&quot;高跃&quot;, 22); //创建就业班集合对象 HashMap&lt;String,Integer&gt; jyMap = new HashMap&lt;String,Integer&gt;(); jyMap.put(&quot;李杰&quot;, 21); jyMap.put(&quot;曹石磊&quot;, 23); //把基础班和就业班添加到传智播客集合中 czbkMap.put(&quot;jc&quot;, jcMap); czbkMap.put(&quot;jy&quot;, jyMap); //遍历集合 Set&lt;String&gt; czbkSet = czbkMap.keySet(); for(String key:czbkSet) &#123; System.out.println(key+&quot;:&quot;); HashMap&lt;String,Integer&gt; hm =czbkMap.get(key); Set&lt;String&gt; hmSet = hm.keySet(); for(String key2:hmSet) &#123; Integer i = hm.get(key2); System.out.println(key2+&quot;---&quot;+i); &#125; &#125; &#125;&#125; 2.2HashMap嵌套ArrayList1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package cn.itcast_05;import java.util.ArrayList;import java.util.HashMap;import java.util.Set;/* * 需求：假设HashMap集合的元素是ArrayList。有3个。 * 每一个ArrayList集合的值是字符串 * 元素我已经完成，请遍历 * * 结果 * 三国演义 * 吕布 * 周瑜 * 笑傲江湖 * 令狐冲 * 林平之 * 神雕侠侣 * 郭靖 * 杨过 * * */public class HashMapIncludeArrayListDemo &#123; public static void main(String[] args) &#123; //创建大集合 HashMap&lt;String,ArrayList&lt;String&gt;&gt; hm = new HashMap&lt;String,ArrayList&lt;String&gt;&gt;(); //创建ArrayList集合并添加元素 ArrayList&lt;String&gt; array1 = new ArrayList&lt;String&gt;(); array1.add(&quot;吕布&quot;); array1.add(&quot;周瑜&quot;); ArrayList&lt;String&gt; array2 = new ArrayList&lt;String&gt;(); array2.add(&quot;令狐冲&quot;); array2.add(&quot;林平之&quot;); ArrayList&lt;String&gt; array3 = new ArrayList&lt;String&gt;(); array3.add(&quot;郭靖&quot;); array3.add(&quot;杨过&quot;); //把小集合添加到大集合中 hm.put(&quot;三国演义&quot;, array1); hm.put(&quot;笑傲江湖&quot;, array2); hm.put(&quot;神雕侠侣&quot;, array3); //遍历集合 Set&lt;String&gt; set = hm.keySet(); for(String key:set) &#123; System.out.println(key+&quot;:&quot;); ArrayList&lt;String&gt; value = hm.get(key); for(String str:value) &#123; System.out.println(&quot;\t&quot;+str); &#125; &#125; &#125;&#125; 2.3ArrayList嵌套HashMap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package cn.itcast_05;import java.util.ArrayList;import java.util.HashMap;import java.util.Set;/* * ArrayList嵌套HashMap集合并遍历 * * 需求： * 假设ArrayList集合的元素是HashMap。有三个。 * * 结果： * 周瑜---小乔 * 吕布---貂蝉 * * 郭靖---黄蓉 * 杨过---小龙女 * * 令狐冲---任盈盈 * 林平之---岳灵珊 * */public class ArrayListIncludeHashMapDemo &#123; public static void main(String[] args) &#123; //创建集合对象 ArrayList&lt;HashMap&lt;String,String&gt;&gt; array = new ArrayList&lt;HashMap&lt;String,String&gt;&gt;(); //创建元素并添加 HashMap&lt;String,String&gt; hm1 = new HashMap&lt;String,String&gt;(); hm1.put(&quot;周瑜&quot;, &quot;小乔&quot;); hm1.put(&quot;吕布&quot;, &quot;貂蝉&quot;); array.add(hm1); HashMap&lt;String,String&gt; hm2 = new HashMap&lt;String,String&gt;(); hm2.put(&quot;郭靖&quot;, &quot;黄蓉&quot;); hm2.put(&quot;杨过&quot;, &quot;小龙女&quot;); array.add(hm2); HashMap&lt;String,String&gt; hm3 = new HashMap&lt;String,String&gt;(); hm3.put(&quot;令狐冲&quot;, &quot;任盈盈&quot;); hm3.put(&quot;林平之&quot;, &quot;岳灵珊&quot;); array.add(hm3); //遍历 for(HashMap&lt;String,String&gt; hm:array) &#123; Set&lt;String&gt; set = hm.keySet(); for(String key:set) &#123; String s = hm.get(key); System.out.println(key+&quot;---&quot;+s); &#125; System.out.println(); &#125; &#125;&#125; 2.4HashMap嵌套HashMap嵌套HashMap（三层嵌套）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package cn.itcast_06;import java.util.ArrayList;import java.util.HashMap;import java.util.Set;/* * 为了更符合要求： * 这次的数据就看成是学生对象。 * * 传智播客 * bj 北京校区 * jc 基础班 * 林青霞 27 * 风清扬 30 * jy 就业班 * 赵雅芝 28 * 武鑫 29 * sh 上海校区 * jc 基础班 * 郭美美 20 * 犀利哥 22 * jy 就业班 * 罗玉凤 21 * 马征 23 * gz 广州校区 * jc 基础班 * 王力宏 30 * 李静磊 32 * jy 就业班 * 朗朗 31 * 柳岩 33 * xa 西安校区 * jc 基础班 * 范冰冰 27 * 刘意 30 * jy 就业班 * 李冰冰 28 * 张志豪 29 */public class HashMapDemo &#123; public static void main(String[] args) &#123; //创建大集合 HashMap&lt;String,HashMap&lt;String,ArrayList&lt;Student&gt;&gt;&gt; czbkMap = new HashMap&lt;String,HashMap&lt;String,ArrayList&lt;Student&gt;&gt;&gt;(); // 北京校区数据 HashMap&lt;String,ArrayList&lt;Student&gt;&gt; bjCzbkMap = new HashMap&lt;String,ArrayList&lt;Student&gt;&gt;(); ArrayList&lt;Student&gt; array1 = new ArrayList&lt;Student&gt;(); array1.add(new Student(&quot;林青霞&quot;,27)); array1.add(new Student(&quot;风清扬&quot;,30)); ArrayList&lt;Student&gt; array2 = new ArrayList&lt;Student&gt;(); array2.add(new Student(&quot;赵雅芝&quot;,28)); array2.add(new Student(&quot;武鑫&quot;,29)); bjCzbkMap.put(&quot;jc&quot;, array1); bjCzbkMap.put(&quot;jy&quot;, array2); czbkMap.put(&quot;北京校区&quot;, bjCzbkMap); // 上海校区数据 HashMap&lt;String,ArrayList&lt;Student&gt;&gt; shCzbkMap = new HashMap&lt;String,ArrayList&lt;Student&gt;&gt;(); ArrayList&lt;Student&gt; array3 = new ArrayList&lt;Student&gt;(); array3.add(new Student(&quot;郭美美&quot;,27)); array3.add(new Student(&quot;犀利哥&quot;,22)); ArrayList&lt;Student&gt; array4 = new ArrayList&lt;Student&gt;(); array4.add(new Student(&quot;罗玉凤&quot;,21)); array4.add(new Student(&quot;马征&quot;,23)); shCzbkMap.put(&quot;jc&quot;, array3); shCzbkMap.put(&quot;jy&quot;, array4); czbkMap.put(&quot;上海校区&quot;, shCzbkMap); // 广州校区数据 HashMap&lt;String,ArrayList&lt;Student&gt;&gt; gzCzbkMap = new HashMap&lt;String,ArrayList&lt;Student&gt;&gt;(); ArrayList&lt;Student&gt; array5 = new ArrayList&lt;Student&gt;(); array5.add(new Student(&quot;王力宏&quot;,30)); array5.add(new Student(&quot;李静磊&quot;,32)); ArrayList&lt;Student&gt; array6 = new ArrayList&lt;Student&gt;(); array6.add(new Student(&quot;朗朗&quot;,31)); array6.add(new Student(&quot;柳岩&quot;,33)); gzCzbkMap.put(&quot;jc&quot;, array5); gzCzbkMap.put(&quot;jy&quot;, array6); czbkMap.put(&quot;广州校区&quot;, gzCzbkMap); // 西安校区数据 HashMap&lt;String,ArrayList&lt;Student&gt;&gt; xaCzbkMap = new HashMap&lt;String,ArrayList&lt;Student&gt;&gt;(); ArrayList&lt;Student&gt; array7 = new ArrayList&lt;Student&gt;(); array7.add(new Student(&quot;范冰冰&quot;,27)); array7.add(new Student(&quot;刘意&quot;,30)); ArrayList&lt;Student&gt; array8 = new ArrayList&lt;Student&gt;(); array8.add(new Student(&quot;李冰冰&quot;,28)); array8.add(new Student(&quot;张志豪&quot;,29)); xaCzbkMap.put(&quot;jc&quot;, array7); xaCzbkMap.put(&quot;jy&quot;, array8); czbkMap.put(&quot;西安校区&quot;, xaCzbkMap); //遍历 Set&lt;String&gt; czbkMapSet = czbkMap.keySet(); for(String czbkMapkey:czbkMapSet) &#123; System.out.println(czbkMapkey+&quot;:&quot;); HashMap&lt;String,ArrayList&lt;Student&gt;&gt; czbkMapValue =czbkMap.get(czbkMapkey); Set&lt;String&gt; czbkMapSetSet = czbkMapValue.keySet(); for(String czbkMapkeykey:czbkMapSetSet) &#123; System.out.println(&quot;\t&quot;+czbkMapkeykey+&quot;:&quot;); ArrayList&lt;Student&gt; value = czbkMapValue.get(czbkMapkeykey); for(Student s:value) &#123; System.out.println(&quot;\t\t&quot;+s.getName()+&quot;---&quot;+s.getAge()); &#125; &#125; &#125; &#125;&#125; 面试题1.HashMap和Hashtable的区别Hashtable：线程安全，效率低。不允许null键和null值。HashMap：线程不安全，效率高。允许null键和null值。2.List，Set，Map等接口是否都继承自Map接口？List，Set不是继承自Map接口，它们继承自Collection接口而Map接口本身就是一个顶层接口。3.常见的集合都有哪些？都有什么方法？ 二、Collections1.Collection类概述针对集合操作的工具类 2.Collection成员方法public static void sort(List list)：排序 默认情况下是自然排序.如果同时有自然排序和比较器排序，以比较器排序为主public static int binarySearch(List&lt;?&gt; list,T key)：二分查找public static T max(Collection&lt;?&gt; coll)：最大值public static void reverse(List&lt;?&gt; list)：反转public static void shuffle(list&lt;?&gt; list)：随机置换 3.Collection和Collections的区别Collection：单列集合的顶层接口。有子类接口List和SetCollections：是针对集合操作的工具类，有对集合进行排序和二分查找的方法。 练习1.模拟斗地主洗牌和发牌(发出的牌要排序)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package cn.itcast_04;import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;import java.util.TreeSet;/* * 思路： * * （1）创建一个HashMap集合 * （2）创建一个ArrayList集合 * （3）创建花色数组和点数数组 * （4）从0开始往hashMap存储编号，并存储对应的牌 * 同时往ArrayList里面存储编号即可。 * （5）洗牌（洗的是编号） * （6）发牌（发的也是编号，为了保证编号也是排序的，就创建TreeSet集合接收） * （7）看牌（遍历TreeSet集合，获取编号，到HashMap集合中找对应的牌） */public class PokerDemo &#123; public static void main(String[] args) &#123; // 创建一个HashMap集合 HashMap&lt;Integer, String&gt; hm = new HashMap&lt;Integer, String&gt;(); // 创建一个ArrayList集合 ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;(); // 装牌 // 定义一个花色数组 String[] colors = &#123; &quot;♠️&quot;, &quot;♥️&quot;, &quot;♣️&quot;, &quot;♦️&quot; &#125;; // 定义一个点数数组 String[] numbers = &#123; &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;, &quot;J&quot;, &quot;Q&quot;, &quot;K&quot;, &quot;A&quot;, &quot;2&quot; &#125;; // 从0开始往HashMap里面存储编号，并存储对应的牌，同时往ArrayList里面存储编号即可。 int index = 0; for(String number: numbers) &#123; for(String color:colors) &#123; String poker = color.concat(number); hm.put(index, poker); array.add(index); index++; &#125; &#125; hm.put(index, &quot;🃏&quot;); array.add(index); index++; hm.put(index, &quot;大王&quot;); array.add(index); //洗牌 Collections.shuffle(array); //发牌（发的也是编号，为了保证编号也是排序的，就创建TreeSet集合接收） TreeSet&lt;Integer&gt; fengQingYang = new TreeSet&lt;Integer&gt;(); TreeSet&lt;Integer&gt; linQingXia = new TreeSet&lt;Integer&gt;(); TreeSet&lt;Integer&gt; liuYi = new TreeSet&lt;Integer&gt;(); TreeSet&lt;Integer&gt; diPai = new TreeSet&lt;Integer&gt;(); for(int x=0;x&lt;array.size();x++) &#123; if(x&gt;=array.size()-3) &#123; diPai.add(array.get(x)); &#125;else if(x%3 ==0) &#123; fengQingYang.add(array.get(x)); &#125;else if(x%3==1) &#123; linQingXia.add(array.get(x)); &#125;else if(x%3==2) &#123; liuYi.add(array.get(x)); &#125; &#125; //看牌 lookPoker(&quot;风清扬&quot;,fengQingYang,hm); lookPoker(&quot;林青霞&quot;,linQingXia,hm); lookPoker(&quot;刘意&quot;,liuYi,hm); lookPoker(&quot;底牌&quot;,diPai,hm); &#125; //看牌功能 public static void lookPoker(String name,TreeSet&lt;Integer&gt; ts,HashMap&lt;Integer,String&gt; hm) &#123; System.out.print(name+&quot;的牌是：&quot;); for(Integer key:ts) &#123; String value = hm.get(key); System.out.print(value+&quot; &quot;); &#125; System.out.println(); &#125;&#125;]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday17]]></title>
    <url>%2F2019%2F08%2F05%2Fjavaday17%2F</url>
    <content type="text"><![CDATA[一、登陆注册案例(集合版)(要掌握这个案例)1.需求分析需求：用户注册登陆案例分析：… 2.用户普通描述类cn.itcast_01.pojo12345678910111213141516171819202122232425262728293031323334package cn.itcast_01.pojo;/** * * 这是用户基本描述类 * * @author chenjie * @version V1.0 * */public class User &#123; //用户名 private String username; //密码 private String password; public User() &#123; super(); &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; &#125; 3.用户操作接口cn.itcast_01.dao1234567891011121314151617181920212223242526272829303132package cn.itcast_01.dao;import cn.itcast_01.pojo.User;/** * 这是针对用户进行操作的接口 * * @author chenjie * @version V1.0 * */public interface UserDao &#123; /** * 这是用户登陆功能 * * @param username * 用户名 * @param password * 密码 * @return 返回登陆是否成功 */ public abstract boolean isLogin(String username,String password); /** * 这是用户注册功能 * * @param user * 要注册的用户信息 */ public abstract void regist(User user); &#125; 4.用户操作类cn.itcast_01.dao.impl123456789101112131415161718192021222324252627282930313233343536373839404142package cn.itcast_01.dao.impl;import java.util.ArrayList;import cn.itcast_01.dao.UserDao;import cn.itcast_01.pojo.User;/** * 这是用户操作的具体实现类（集合版） * * @author chenjie * @version V1.0 * * */public class UserDaoImpl implements UserDao &#123; //为了让多个方法使用同一个集合，就把集合定义为成员变量 //为了不让外人看到，用private //为了让多个对象共享同一个成员变量，用static private static ArrayList&lt;User&gt; array = new ArrayList&lt;User&gt;(); @Override public boolean isLogin(String username, String password) &#123; // 遍历集合，获取每一个用户，并判断该用户的用户名和密码是否和传递过来的匹配 boolean flag = false; for(User u:array) &#123; if(u.getUsername().equals(username) &amp;&amp; u.getPassword().equals(password)) &#123; flag = true; break; &#125; &#125; return flag; &#125; @Override public void regist(User user) &#123; // 把用户信息存入集合 //ArrayList&lt;User&gt; array = new ArrayList&lt;User&gt;(); array.add(user); &#125;&#125; 5.测试类cn.itcast_01.test123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package cn.itcast_01.test;import java.util.Scanner;import cn.itcast_01.dao.UserDao;import cn.itcast_01.dao.impl.UserDaoImpl;import cn.itcast_01.game.GuessNumber;import cn.itcast_01.pojo.User;/** * 用户测试类 * * @author chenjie * @version V1.0 * * 新增加的两个小问题 * （1）多个对象共享同一个成员变量，用静态 * （2）循环里面如果有switch，并且在switch里面有break，那么结束的不是循环，而是switch语句。 * * */public class UserTest &#123; public static void main(String[] args) &#123; while(true) &#123; //欢迎界面，给出选择项 System.out.println(&quot;--------------欢迎光临--------------&quot;); System.out.println(&quot;1 登录&quot;); System.out.println(&quot;2 注册&quot;); System.out.println(&quot;3 退出&quot;); System.out.println(&quot;请输入你的选择(输入除上述以外的其它数字都会使系统退出)：&quot;); //键盘录入选择，根据选择做不同的操作 Scanner sc = new Scanner(System.in); //为了后面录入信息的方便，我所有的数据录入全部用字符接收 String choiceString = sc.nextLine(); //switch语句的多个地方要使用，我就定义到外面 UserDao ud = new UserDaoImpl(); //经过简单的思考，我选择switch switch (choiceString) &#123; case &quot;1&quot;: //登录界面，请输入用户名和密码 System.out.println(&quot;--------------登录界面--------------&quot;); System.out.println(&quot;请输入用户名：&quot;); String username = sc.nextLine(); System.out.println(&quot;请输入密码&quot;); String password = sc.nextLine(); //调用登录功能 //UserDao ud = new UserDaoImpl(); boolean flag = ud.isLogin(username, password); if(flag) &#123; System.out.println(&quot;登录成功，玩小游戏码？y/n：&quot;); while(true) &#123; String choice = sc.nextLine(); if(choice.equalsIgnoreCase(&quot;y&quot;)) &#123; GuessNumber.start(); System.out.println(&quot;还要再玩一次吗？y/n：&quot;); &#125;else &#123; break; &#125; &#125; System.out.println(&quot;感谢使用，下次再见&quot;); System.exit(0); //break;//这里写break结束的是switch &#125;else &#123; System.out.println(&quot;用户名或密码有误，登录失败&quot;); &#125; break; case &quot;2&quot;: //注册界面，请输入用户名和密码 System.out.println(&quot;--------------注册界面--------------&quot;); System.out.println(&quot;请输入用户名：&quot;); String newUsername = sc.nextLine(); System.out.println(&quot;请输入密码&quot;); String newPassword = sc.nextLine(); //把用户名和密码封装到一个对象中 User user = new User(); user.setUsername(newUsername); user.setPassword(newPassword); //调用注册功能 //多态 //UserDao ud = new UserDaoImpl(); //具体类使用 //UserDaoImpl = new UserDaoImpl(); ud.regist(user); System.out.println(&quot;注册成功&quot;); break; case &quot;3&quot;: default: System.out.println(&quot;谢谢使用，欢迎下次再来&quot;); System.exit(0); break; &#125; &#125; &#125;&#125; 6.猜数字小游戏cn.itcast_01.game1234567891011121314151617181920212223242526272829package cn.itcast_01.game;import java.util.Scanner;public class GuessNumber &#123; public GuessNumber() &#123; super(); // TODO Auto-generated constructor stub &#125; public static void start() &#123; int number = (int)(Math.random()*100)+1; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入你猜的数字&quot;); int guessNumber = sc.nextInt(); while(!(guessNumber==number)) &#123; if(guessNumber&gt;number) &#123; System.out.println(&quot;你输入的数字大了&quot;); &#125;else &#123; System.out.println(&quot;你输入的数字小了&quot;); &#125; System.out.println(&quot;请输入你猜的数字：&quot;); guessNumber = sc.nextInt(); &#125; System.out.println(&quot;恭喜你，猜对了&quot;); &#125; &#125; 二、Set集合1.List与Set的区别List:有序(存储顺序和取出顺序一致)，可重复Set:无序(存储顺序和取出顺序不一致)，唯一。//这里的无序指的是没有按照添加的顺序，作为一个集合，存储数据的时候肯定会有自己的存储顺序，如果添加的顺序恰好和存储的顺序一样，这不算是有序。1234567891011121314151617181920212223242526import java.util.HashSet;import java.util.Set;/* * HashSet集合遍历字符串演示 */public class SetDemo &#123; public static void main(String[] args) &#123; Set&lt;String&gt; set = new HashSet&lt;String&gt;(); set.add(&quot;hello&quot;); set.add(&quot;world&quot;); set.add(&quot;java&quot;); set.add(&quot;world&quot;); set.add(&quot;java&quot;); //增强for遍历 for(String x:set) &#123; System.out.println(x); //结果: // world //添加两个同样的元素，存储时只存了一个。 // java // hello &#125; &#125; 从上述结果可以看出Set集合的元素是无序并且唯一的， 2.HashSet是如何保证元素的唯一性的通过查看add方法的源码，我们知道这个方法底层依赖两个方法：hashCode()和equals()执行add(…)时，首先比较哈希值（1）如果相同，继续比较地址值或equals()，a、如果返回true，说明元素重复，就不添加；返回false说明元素不重复，就添加到集合。（2）如果不同，就直接添加到集合中。如果类没有重写这两个方法，默认是的是Object()，一般来说不相同。而String类重写了hashCode()和equals()，所以，它就可以把内容相同的字符串去掉。只留下一个，保证了元素的唯一性。 3.HashSet保证元素唯一的方法图解哈希表：是一个元素为链表的数组，综合了数组和链表的好处。(结合字典理解，数组的索引就是拼音的声母，链表就是以该声母为声母的所有字的集合) 4.TreeSet特点能够对元素按照某种规则进行排序排序有两种方式：自然排序和比较器排序TreeSet排序总结:排序(自然排序和比较器排序)和唯一 5.TreeSet保证元素排序的源码解析真正的比较是依赖于元素的compareTo(),而这个方法是定义在Comparable里面的。所以，你要想重写该方法，就必须实现Comparable接口。这个接口表示的就是自然排序。 6.TreeSet底层的二叉树结构TreeSet底层是二叉树结构，而且是红黑树(一种自平衡的二叉树)保证唯一性：相同的不存保证排序：比较，小的放左边，大的放右边。遍历时，采用左-中-右的方法进行遍历。 7.TreeSet存储自定义对象并保证排序和唯一7.1 要提前说明排序方7.2 要定义情况才算相同 TreeSet存储自定义对象并遍历练习(按照要求的顺序存储)1.按照名字的长度排列学生类代码1234567891011121314151617181920212223242526272829303132333435363738public class Student implements Comparable&lt;Student&gt;&#123; private String name; private int age; public Student() &#123; super(); // TODO Auto-generated constructor stub &#125; public Student(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public int compareTo(Student s) &#123; int num; num = this.name.length()-s.name.length(); num = num==0?this.name.compareTo(s.name):num; num = num==0?this.age-s.age:num; return num; &#125; &#125; 测试类代码12345678910111213141516171819202122232425262728293031323334import java.util.TreeSet;/* * 按照名字长度排序 */public class TreeSetTest2 &#123; public static void main(String[] args) &#123; //创建集合对象 TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(); //创建元素 Student s1 = new Student(&quot;linqingxia&quot;,27); Student s2 = new Student(&quot;zhangguorong&quot;,29); Student s3 = new Student(&quot;wanglihong&quot;,23); Student s4 = new Student(&quot;linqingxia&quot;,27); Student s5 = new Student(&quot;liushishi&quot;,22); Student s6 = new Student(&quot;wuqilong&quot;,40); Student s7 = new Student(&quot;fengqingy&quot;,22); //添加元素 ts.add(s1); ts.add(s2); ts.add(s3); ts.add(s4); ts.add(s5); ts.add(s6); ts.add(s7); //遍历 for(Student s : ts) &#123; System.out.println(s.getName()+&quot;---&quot;+s.getAge()); &#125; &#125;&#125; 8.比较器排序public TreeSet(Comparator&lt;? super E&gt; comparator)//比较器排序123456789101112131415161718192021222324252627public class Student &#123; private String name; private int age; public Student() &#123; super(); // TODO Auto-generated constructor stub &#125; public Student(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125; 测试类（使用匿名内部类实现比较器排序）123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.Comparator;import java.util.TreeSet;public class TreeSetTest &#123; public static void main(String[] args) &#123; //创建集合对象 TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(new Comparator&lt;Student&gt;() &#123; public int compare(Student s1,Student s2) &#123; //姓名长度 int num = s1.getName().length()-s2.getName().length(); //姓名内容 num = num==0?s1.getName().compareTo(s2.getName()):num; //年龄 num = num==0?s1.getAge()-s2.getAge():num; return num; &#125; &#125;); //创建元素 Student s1 = new Student(&quot;linqingxia&quot;,27); Student s2 = new Student(&quot;zhangguorong&quot;,29); Student s3 = new Student(&quot;wanglihong&quot;,23); Student s4 = new Student(&quot;linqingxia&quot;,27); Student s5 = new Student(&quot;liushishi&quot;,22); Student s6 = new Student(&quot;wuqilong&quot;,40); Student s7 = new Student(&quot;fengqingy&quot;,22); //添加元素 ts.add(s1); ts.add(s2); ts.add(s3); ts.add(s4); ts.add(s5); ts.add(s6); ts.add(s7); //遍历 for(Student s : ts) &#123; System.out.println(s.getName()+&quot;---&quot;+s.getAge()); &#125; &#125;&#125; 9.TreeSet集合保证元素排序和唯一性的原理总结唯一性：是根据比较的返回值吃否是0来决定。排序：自然排序（元素具备比较性）：让元素所属的类实现Comparable接口比较器排序（集合具备比较性）：让集合的构造方法接收一个比较器接口的子类对象Comparator 练习1.编写一个程序，获取10个1至20的随机数，要求随机数不重复。12345678910111213141516171819202122232425262728package cn.itcast_08;import java.util.HashSet;import java.util.Random;/* * 产生10个1-20的随机数，不重复并遍历 */public class HashSetDemo &#123; public static void main(String[] args) &#123; //创建随机数对象 Random r = new Random(); //创建集合对象 HashSet&lt;Integer&gt; hs = new HashSet&lt;Integer&gt;(); //判断集合长度是否小于10 while(hs.size()&lt;10) &#123; int num = r.nextInt(20)+1; hs.add(num); &#125; //遍历集合 for(Integer i : hs) &#123; System.out.println(i); &#125; &#125;&#125; 2.键盘录入5个学生信息（姓名，语文成绩，数学成绩，英语成绩），按照总分从高到低输出到控制台。自己的做法12345678910111213141516171819202122232425262728293031323334353637383940414243package cn.itcast_09;import java.util.Comparator;import java.util.TreeSet;public class TreeSetTest &#123; public static void main(String[] args) &#123; //创建集合对象 TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student s1, Student s2) &#123; int sum1 = s1.getScore1()+s1.getScore2()+s1.getScore3(); int sum2 = s2.getScore1()+s2.getScore2()+s2.getScore3(); int num = sum2-sum1; num = num==0?s2.getName().length()-s1.getName().length():num; num = num==0?s2.getName().compareTo(s1.getName()):num; return num; &#125; &#125;); //创建学生对象并添加至集合 Student s1 = new Student(&quot;luo&quot;,20,20,20); Student s2 = new Student(&quot;xiao&quot;,30,20,20); Student s3 = new Student(&quot;chen&quot;,40,20,20); Student s4 = new Student(&quot;yu&quot;,50,20,20); Student s5 = new Student(&quot;xu&quot;,60,20,20); Student s6 = new Student(&quot;luo&quot;,20,20,20); ts.add(s1); ts.add(s2); ts.add(s3); ts.add(s4); ts.add(s5); ts.add(s6); //遍历 for(Student s:ts) &#123; System.out.println(s.getName()+&quot;---&quot;+s.getScore1()); &#125; &#125;&#125; 三、Collection集合总结Collection|–List 有序，可重复|—-ArrayList 底层数据结构是数组，查询快，增删慢。线程不安全，效率高。|—-Vector 底层数据结构是数组，查询快，增删慢。线程安全，效率低。|—-LinkedList 底层数据结构是链表，查询慢，增删快，线程不安全，效率高。|–Set 无序，唯一|—-HashSet 底层数据结构是哈希表，依赖hashCode()和equals()保证唯一性，开发中自动生成这两个方法即可。|—-LinkedHashSet 底层数据结构是链表和哈希表，由链表保证元素有序，由哈希表保证元素唯一。|—-TreeSet 底层数据结构是红黑树。通过自然排序和比较器排序来保证元素有序。根据比较的返回值是否是0来决定。 四、针对Collection集合我们该如何使用唯一吗？|–是：Set–排序吗？|—-是：TreeSet|—-否：HashSet|—-如果你知道是Set，但不知道使用哪个Set，就用HashSet。|–否：List–安全吗？|—-是：Vector|—-否：ArrayList或LinkedList|——查询多：ArrayList|——增删多：LinkedList|—-如果你知道是List，但是不知道是哪个List，就用ArrayList。如果你知道是collection集合，但是不知道用谁，就用ArrayList。如果你知道用集合，就用ArrayList。 五、常用的数据结构ArrayXxx：底层数据结构是数组，查询快，增删慢。LinkXxx：底层数据结构是链表，查询慢，增删快。HashXxx：底层数据是哈希表。依赖两个方法，hashCode()和equals()TreeXxx：底层数据结构是二叉树。两种方式排序：自然排序和比较器排序]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday16]]></title>
    <url>%2F2019%2F08%2F04%2Fjavaday16%2F</url>
    <content type="text"><![CDATA[一、List子类 1.ArrayList前面讲的都是以ArrayList举例，所有该讲的都讲完了 2.Vector特有功能2.1 添加功能public void addElement(Object obj):2.2 获取功能public Object elementAt(int index):public Enumeration elements(): 3.LinkedList特有功能3.1 添加功能public void addFirst(Object e)public void addLast(Object e)3.2获取功能public Object getFirst()public Object getLast()3.3 删除功能public Object removeFirst()public Object removeLast()12345678910111213141516171819202122232425262728import java.util.LinkedList;/* * LinkedList特有功能演示 */public class LinkedListDemo &#123; public static void main(String[] args) &#123; //创建集合对象 LinkedList link = new LinkedList(); link.add(&quot;world&quot;); link.addFirst(&quot;hello&quot;); link.addLast(&quot;java&quot;); System.out.println(&quot;link:&quot;+link);//link:[hello, world, java] System.out.println(&quot;----------&quot;); System.out.println(&quot;link.getFirst():&quot;+link.getFirst());//link.getFirst():hello System.out.println(&quot;link.getLast():&quot;+link.getLast());//link.getLast():java System.out.println(&quot;link:&quot;+link); System.out.println(&quot;--------&quot;); System.out.println(&quot;removeFirst():&quot;+link.removeFirst());//removeFirst():hello System.out.println(&quot;removeLast():&quot;+link.removeLast());//removeLast():java System.out.println(&quot;link:&quot;+link);//link:[world] &#125;&#125; List集合练习1.ArrayList（1）去除集合中字符串的重复值（字符串的内容相同）12345678910111213141516171819202122232425262728293031323334353637383940import java.util.ArrayList;import java.util.Iterator;/* * 方法1 */public class ArrayListTest &#123; public static void main(String[] args) &#123; ArrayList array = new ArrayList(); array.add(&quot;hello&quot;); array.add(&quot;world&quot;); array.add(&quot;java&quot;); array.add(&quot;world&quot;); array.add(&quot;java&quot;); array.add(&quot;world&quot;); array.add(&quot;java&quot;); array.add(&quot;java&quot;); array.add(&quot;world&quot;); array.add(&quot;java&quot;); //创建新集合 ArrayList newArray = new ArrayList(); //遍历旧集合 Iterator it = array.iterator(); while(it.hasNext()) &#123; String s = (String)it.next(); if(!newArray.contains(s)) &#123; newArray.add(s); &#125; &#125; //遍历新集合 for(int x=0;x&lt;newArray.size();x++) &#123; String s = (String)newArray.get(x); System.out.println(s); &#125; &#125; &#125; 方法2:1234567891011121314151617181920212223242526272829303132333435363738import java.util.ArrayList;import java.util.Iterator;/* * 方法2 */public class ArrayListTest2 &#123; public static void main(String[] args) &#123; ArrayList array = new ArrayList(); array.add(&quot;hello&quot;); array.add(&quot;world&quot;); array.add(&quot;java&quot;); array.add(&quot;world&quot;); array.add(&quot;java&quot;); array.add(&quot;world&quot;); array.add(&quot;java&quot;); array.add(&quot;java&quot;); array.add(&quot;world&quot;); array.add(&quot;java&quot;); for(int x=0;x&lt;array.size()-1;x++) &#123; for(int y=x+1;y&lt;array.size();y++) &#123; if(array.get(x).equals(array.get(y))) &#123; array.remove(y); y--; &#125; &#125; &#125; //遍历集合 Iterator it = array.iterator(); while(it.hasNext()) &#123; String s = (String)it.next(); System.out.println(s); &#125; &#125;&#125; （2）去除集合中自定义对象的重复值（对象的成员变量值都相同）方法1:12345678910111213141516171819202122232425262728293031323334353637383940public class ArrayListTest3 &#123; public static void main(String[] args) &#123; //创建集合对象 ArrayList array = new ArrayList(); //创建自定义对象 Student s1 = new Student(&quot;111&quot;,11); Student s2 = new Student(&quot;112&quot;,11); Student s3 = new Student(&quot;113&quot;,11); Student s4 = new Student(&quot;111&quot;,11); Student s5 = new Student(&quot;112&quot;,11); Student s6 = new Student(&quot;111&quot;,11); //添加自定义对象到集合中 array.add(s1); array.add(s2); array.add(s3); array.add(s4); array.add(s5); array.add(s6); //创建新的集合对象 ArrayList newArray = new ArrayList(); //遍历旧集合，有新集合没有的元素就加进去 for(int x=0;x&lt;array.size();x++) &#123; Student s = (Student)array.get(x); if(!newArray.contains(s)) &#123; newArray.add(s); &#125; &#125; //遍历新集合 for(int x=0;x&lt;newArray.size();x++) &#123; Student s = (Student)newArray.get(x); System.out.println(s.getName()+&quot;---&quot;+s.getAge()); &#125; &#125;&#125; 方法2:123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.ArrayList;import java.util.Iterator;/* * 方法2 */public class ArrayTest4 &#123; public static void main(String[] args) &#123; //创建集合对象 ArrayList array = new ArrayList(); //创建自定义对象 Student s1 = new Student(&quot;111&quot;,11); Student s2 = new Student(&quot;112&quot;,11); Student s3 = new Student(&quot;113&quot;,11); Student s4 = new Student(&quot;111&quot;,11); Student s5 = new Student(&quot;112&quot;,11); Student s6 = new Student(&quot;111&quot;,11); //添加自定义对象到集合中 array.add(s1); array.add(s2); array.add(s3); array.add(s4); array.add(s5); array.add(s6); //通过选择排序对比，有重复的元素就删除 for(int x=0;x&lt;array.size()-1;x++) &#123; for(int y=x+1;y&lt;array.size();y++) &#123; if(array.get(x).equals(array.get(y))) &#123; array.remove(y); y--; &#125; &#125; &#125; //遍历集合 Iterator it = array.iterator(); while(it.hasNext()) &#123; Student s = (Student)it.next(); System.out.println(s.getName()+&quot;---&quot;+s.getAge()); &#125; &#125; &#125; 2.LinkedList请用LinkedList模拟栈数据结构的集合，并测试。12345678910111213141516171819202122232425262728import java.util.LinkedList;/** * 自定义栈集合 * * @author chenjie * @version V1.0 */public class MyStack &#123; private LinkedList link; public MyStack() &#123; link = new LinkedList(); &#125; public void add(Object obj) &#123; link.addFirst(obj); &#125; public Object get() &#123; //return link.getFirst(); return link.removeFirst(); &#125; public boolean isEmpty() &#123; return link.isEmpty(); &#125;&#125; 123456789101112131415161718/* * */public class MyStackDemo &#123; public static void main(String[] args) &#123; MyStack ms = new MyStack(); ms.add(&quot;hello&quot;); ms.add(&quot;world&quot;); ms.add(&quot;java&quot;); while(!ms.isEmpty()) &#123; System.out.println(ms.get()); &#125; &#125;&#125; 二、泛型1.概述是一个把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型。也叫参数化类型，把类型当作参数一样传递。格式：&lt;数据类型&gt;：此处的数据类型只能是引用类型。 2.泛型的好处（1）把运行时期的问题提前到了编译期间。（2）避免了强制类型转换。（3）优化了程序设计，解决了黄色警告线。 3.泛型的引用3.1 泛型类把泛型定义在类上格式：public class 类名&lt;泛型类型1,…&gt;注意；泛型类型必须是引用类型。 3.2 泛型方法把泛型定义在方法上好处：我的方法可以接收任意类型格式举例：public void show(T t) 3.3 泛型接口把泛型定义在接口上格式：public interface Inter {} 3.4 泛型高级之通配符(1)&lt;?&gt;:任意类型。(2)&lt;? extends E&gt;:向上限定，该类及其子类。(3)&lt;? super E&gt;:向下限定，该类及其父类。 123456789101112131415161718192021import java.util.ArrayList;import java.util.Collection;public class AnimalDemo &#123; public static void main(String[] args) &#123; Collection&lt;?&gt; c1 = new ArrayList&lt;Animal&gt;(); Collection&lt;?&gt; c2 = new ArrayList&lt;Object&gt;(); Collection&lt;?&gt; c3 = new ArrayList&lt;Dog&gt;(); System.out.println(&quot;----------&quot;); Collection&lt;? extends Animal&gt; cc1 = new ArrayList&lt;Animal&gt;(); Collection&lt;? extends Animal&gt; cc2 = new ArrayList&lt;Object&gt;();//提示错误。向上限定 Collection&lt;? extends Animal&gt; cc3 = new ArrayList&lt;Dog&gt;(); System.out.println(&quot;-----------&quot;); Collection&lt;? super Animal&gt; ccc1 = new ArrayList&lt;Animal&gt;(); Collection&lt;? super Animal&gt; ccc2 = new ArrayList&lt;Object&gt;(); Collection&lt;? super Animal&gt; ccc3 = new ArrayList&lt;Dog&gt;();//报错。向下限定 &#125;&#125; 三、增强for循环1.概述2.增强for的好处和弊端好处：简化了数组和集合的遍历。弊端：增强for的目标不能为null。如何解决？对增强for的目标进行判断，不是null再执行。 四、静态导入1.格式import static 包名.类名.方法名;可以直接导入到方法的级别 2.静态导入注意事项(1)方法必须是静态的(2)如果有多个同名的静态方法，容易不知道使用谁，这个时候要使用，必须加前缀。由此可见，意义不大，一般不同，能看懂即可。123456789101112131415/* * 静态导入演示 */import static java.lang.Math.abs;import static java.lang.Math.max;import static java.lang.Math.pow;public class StaticImportDemo &#123; public static void main(String[] args) &#123; System.out.println(abs(-100));//100 System.out.println(max(20,30));//30 System.out.println(pow(2,3));//8.0 &#125;&#125; 五、可变参数1.概述定义方法的时候不知道要定义多少个参数，就可以使用可变参数。 2.格式修饰符 返回值类型 方法名(数据类型… 变量名) { }注意事项：（1）这里的变量其实是一个数组（2）如果一个方法有可变参数，并且有多个参数，那么，可变参数肯定是最后一个。 3.Arrays工具类的asList()的使用public static List asList(T… a):把数组转成集合。1234567891011121314151617181920import java.util.Arrays;import java.util.List;public class ArraysDemo &#123; public static void main(String[] args) &#123; //方法1 //String[] strArr = &#123;&quot;hello&quot;,&quot;world&quot;,&quot;java&quot;&#125;; //List&lt;String&gt; list = Arrays.asList(strArr); //方法2 List&lt;String&gt; list = Arrays.asList(&quot;hello&quot;,&quot;world&quot;,&quot;java&quot;); for(String x:list) &#123; System.out.println(x); &#125; //list.add(&quot;javaee&quot;);//报错 //list.remove(1) list.set(1, &quot;javaee&quot;);//可行，因为不改变长度 &#125;&#125; 注意事项：虽然可以把数组转成集合，但是集合的长度不能改变。因为数组虽然转成了集合，但本质上还是数组，长度无法改变。 List练习1.集合的嵌套遍历我们班级有学生，每一个学生是一个对象，我们可以使用一个集合表示我们班级的学生。ArrayList但我们旁边也有班级，这也是一个ArrayList.所以我现在有多个ArrayList.也要用集合存储，怎么办呢？就是这个样子：ArrayList&lt;ArrayList&gt;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.ArrayList;/* * */public class ArrayListDemo &#123; public static void main(String[] args) &#123; //创建大集合 ArrayList&lt;ArrayList&lt;Student&gt;&gt; bigArray = new ArrayList&lt;ArrayList&lt;Student&gt;&gt;(); //创建小集合 ArrayList&lt;Student&gt; a1 = new ArrayList&lt;Student&gt;(); Student s11 = new Student(&quot;11&quot;,11); Student s12 = new Student(&quot;12&quot;,12); Student s13 = new Student(&quot;12&quot;,12); a1.add(s11); a1.add(s12); a1.add(s13); ArrayList&lt;Student&gt; a2 = new ArrayList&lt;Student&gt;(); Student s21 = new Student(&quot;21&quot;,21); Student s22 = new Student(&quot;22&quot;,22); Student s23 = new Student(&quot;23&quot;,23); a2.add(s21); a2.add(s22); a2.add(s23); ArrayList&lt;Student&gt; a3 = new ArrayList&lt;Student&gt;(); Student s31 = new Student(&quot;31&quot;,31); Student s32 = new Student(&quot;32&quot;,32); Student s33 = new Student(&quot;33&quot;,33); a3.add(s31); a3.add(s32); a3.add(s33); //大集合添加小集合 bigArray.add(a1); bigArray.add(a2); bigArray.add(a3); //遍历 for(ArrayList&lt;Student&gt; x:bigArray) &#123; for(Student y:x) &#123; System.out.println(y.getName()+&quot;---&quot;+y.getAge()); &#125; &#125; &#125;&#125; 2.获取10个1～20之间的随机数，要求不能重复12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.ArrayList;import java.util.Random;/* * 获取10个1～20之间的随机数，要求不能重复 * * 分析： * （1）创建产生随机数的变量 * （2）创建一个存储随机数的集合 * （3）定义一个统计变量，从0开始。 * （4）判断统计遍历是否小于10 * 是：先产生一个随机数，判断该随机数在集合中是否存在。如果不存在，就添加，统计变量++。存在，就不搭理它。 * 否：就退出循环。 * （5）遍历集合 */public class RandomDemo &#123; public static void main(String[] args) &#123; //创建随机数对象 Random r = new Random(); //创建一个存储随机数的集合 ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;(); //定义一个统计变量，从0开始。 int count =0; //判断统计遍历是否小于10 while(count&lt;10) &#123; int number = r.nextInt(20)+1; //判断该随机数在集合中是否存在 if(!array.contains(number)) &#123; array.add(number); count++; &#125; &#125; //遍历集合 for(Integer i:array) &#123; System.out.println(i); &#125; &#125;&#125; 3.键盘录入多个数据，以0结束，要求在控制台输出这多个数据的最大值。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.ArrayList;import java.util.Arrays;import java.util.Scanner;/* * 键盘录入多个数据，以0结束，要求在控制台输出这多个数据的最大值。 * * 分析： * （1）创建键盘录入对象 * （2）键盘录入多个数据，我们不知道多少个，所以用集合存储 * （3）以0结束，即只要键盘录入的数据是0，我们就不继续录入数据了 * （4）把集合转成数组 * （5）对数组排序 * （6）获取该数组中的最大索引的值。 */public class ArrayListDemo &#123; public static void main(String[] args) &#123; // 创建键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println(&quot;请键盘录入第一个数据：&quot;); int x = sc.nextInt(); // 创建集合 ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;(); // 如果键盘录入的不是0，就添加元素到集合 while (!(x == 0)) &#123; array.add(x); System.out.println(&quot;请继续录入数据，或以0结束：&quot;); x = sc.nextInt(); &#125; // 把集合转成数组(重点！！！) //Integer[] arr = (Integer[])array.toArray(); //这种做法是错的，因为返回的是Object[]，而Integer[]不是Object的子类 //正确做法：public &lt;T&gt; T[] toArray(T[] a) Integer[] arr = new Integer[array.size()]; array.toArray(arr); // 对数组进行排序 Arrays.sort(arr); // 获取该数组的最大索引值 System.out.println(&quot;最大值为：&quot; + arr[arr.length - 1]); &#125;&#125;]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday15]]></title>
    <url>%2F2019%2F08%2F02%2Fjavaday15%2F</url>
    <content type="text"><![CDATA[一、对象数组1.由对象组成的数组二、集合(Collection)1.集合类概述面向对象语言对事物的体现都是以对象的形式，所以为了方便对多个对象的操作，Java就提供了集合类。 2.集合和数组的区别（1）长度区别数组长度确定集合长度可变（2）内容不同数组存储的是同一类型的元素集合可以存储不同类型的元素（3）元素的数据类型问题数组可以存储基本数据类型，也可以存储引用数据类型集合只能存储引用类型。 3.集合的继承体系结构集合是存储多个元素的，但是存储多个元素我们也是有不同需求的：比如说，我要这多个元素中不能有相同的元素，再比如说，我要这多个元素按照某种规则排序一下。针对不同的需求，Java就提供了不同的集合类，这样呢，Java就提供了很多个集合类。这多个集合类的数据结构不同，但是不重要，重要的是要能够存储东西，并且还要能够给使用这些东西，比如说判断，获取等。既然这样，这多个集合类是有共性的内容的，我们把这些集合类的共性内容不断的向上提取，最终就能形成集合的继承体系。继承体系如下 Collection List SetArrayList Vector LinkedList HashSet TreeSet 4.CollectionCollection:是集合的顶层接口，它的子体系有重复的，有唯一的，有有序的，有无序的。Collection的功能概述（1）添加功能boolean add(Obejct obj):添加一个元素boolean addAll(Collection c):添加一个集合的元素（2）删除功能void clear():移除所有元素boolean remove(Object o):移除一个元素boolean removeAll(Collection c):移除一个集合的元素（3）判断功能boolean contains(Object o):判断集合中是否包含指定元素boolean containsAll(Collection c):判断集合中是否包含指定的集合元素。boolean isEmpty():判断集合是否为空。元素为空（4）获取功能Iterator iterator()(重点)（5）长度功能int size():返回集合元素的个数面试题：数组有没有length()方法呢？字符串有没有length()方法呢？集合有没有length()方法呢？答：数组没有length()，字符串有length()，集合没有length(),但是有size(),返回集合的元素个数。类似于length()（6）交集功能boolean retainAll(Collection c):两个集合都有的元素。思考元素去哪了，返回的boolean又是什么意思？（7）把集合转换为数组Object[] toArray()123456789101112131415161718192021222324252627282930313233import java.util.ArrayList;import java.util.Collection;/* * Collection功能测试 */public class ObjectArrayDemo &#123; public static void main(String[] args) &#123; Collection c = new ArrayList(); // boolean add(Obejct obj):添加一个元素 c.add(&quot;Hello&quot;); c.add(&quot;World&quot;); c.add(&quot;Java&quot;); System.out.println(&quot;c:&quot; + c);// c:[Hello, World, Java] /* * //void clear():移除所有元素 c.clear(); System.out.println(&quot;c:&quot;+c);//c:[] * * //boolean remove(Object o):移除一个元素 * System.out.println(&quot;c.remove():&quot;+c.remove(&quot;Hello&quot;));//c.remove():true * System.out.println(&quot;c:&quot;+c);//c:[World, Java] */ // // boolean contains(Object o):判断集合中是否包含指定元素 System.out.println(&quot;c.contains():&quot;+c.contains(&quot;Hello&quot;));//c.contains():true System.out.println(&quot;c.contains():&quot;+c.contains(&quot;hello&quot;));//c.contains():false System.out.println(&quot;c:&quot;+c);//c:[Hello, World, Java] //int size():返回集合元素的个数 System.out.println(&quot;c.size():&quot;+c.size());//c.size():3 &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.ArrayList;import java.util.Collection;/* * Collection包含All的功能测试 */public class CollectionDemo2 &#123; public static void main(String[] args) &#123; Collection c1 = new ArrayList(); c1.add(&quot;abc1&quot;); c1.add(&quot;abc2&quot;); c1.add(&quot;abc3&quot;); c1.add(&quot;abc4&quot;); Collection c2 = new ArrayList(); c2.add(&quot;abc4&quot;); c2.add(&quot;abc5&quot;); c2.add(&quot;abc6&quot;); c2.add(&quot;abc7&quot;); System.out.println(&quot;c1:&quot; + c1); System.out.println(&quot;c2:&quot; + c2); // boolean addAll(Collection c):添加一个集合的元素 // System.out.println(&quot;c1.addAll(c2):&quot;+c1.addAll(c2));//c1.addAll(c2):true // System.out.println(&quot;c1:&quot;+c1);//c1:[abc1, abc2, abc3, abc4, abc4,abc5, // abc6, abc7] // System.out.println(&quot;c2:&quot;+c2);//c2:[abc4, abc5, abc6, abc7] // boolean removeAll(Collection c):移除一个集合的元素 // 只要有一个元素被移除了，就返回true // System.out.println(&quot;c1.removeAll(c2):&quot;+c1.removeAll(c2));//c1.removeAll(c2):true // System.out.println(&quot;c1:&quot;+c1);//c1:[abc1, abc2, abc3] // System.out.println(&quot;c2:&quot;+c2);//c2:[abc4, abc5, abc6, abc7] // boolean containsAll(Collection c):判断集合中是否包含指定的集合元素。 // 只有包含所有的元素，才返回true //System.out.println(&quot;c1.containsAll(c2):&quot;+c1.containsAll(c2));//c1.containsAll(c2):false //boolean retainAll(Collection c):两个集合都有的元素。思考元素去哪了，返回的boolean又是什么意思？ //A对B做交集，最终的结果保存在A中，B不变。返回值表示的是A是否发生过改变。 System.out.println(&quot;c1.retainAll(c2):&quot;+c1.retainAll(c2));//c1.retainAll(c2):true //因为c1发生改变了，所以返回true。 System.out.println(&quot;c1:&quot;+c1);//c1:[abc4] System.out.println(&quot;c2:&quot;+c2);//c2:[abc4, abc5, abc6, abc7] &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738import java.util.ArrayList;import java.util.Collection;/* 把集合转换为数组 Object[] toArray() * */public class CollectionDemo3 &#123; public static void main(String[] args) &#123; //创建集合对象 Collection c = new ArrayList(); //添加元素 c.add(&quot;hello&quot;); c.add(&quot;world&quot;); c.add(&quot;java&quot;); //遍历 //Object[] toArray():把集合转为数组 Object[] objs = c.toArray(); for(int x=0;x&lt;objs.length;x++) &#123; //System.out.println(objs[x]); // hello // world // java //上述的&quot;hello&quot;，&quot;world&quot;，&quot;java&quot;虽然是以字符串的形式添加，但是返回的是Object[]类型， //即上述三个元素都变成了Object类型，这其中其实隐含了向上转型 //若要调用String类的特有功能，比如length() //则需要向下转型，举例如下 String s = (String)objs[x]; System.out.println(s+&quot;---&quot;+s.length()); //hello---5 // world---5 // java---4 &#125; &#125; 练习1.12345678910111213141516171819202122232425262728import java.util.ArrayList;import java.util.Collection;/* * 练习：用集合存储五个学生对象，并把学生对象进行遍历。 */public class StudentDemo &#123; public static void main(String[] args) &#123; Collection c = new ArrayList(); Student s1 = new Student(&quot;肖鹏&quot;,25); Student s2 = new Student(&quot;罗生银&quot;,24); Student s3 = new Student(&quot;喻勇&quot;,25); Student s4 = new Student(&quot;徐超&quot;,26); Student s5 = new Student(&quot;陈杰&quot;,26); c.add(s1); c.add(s2); c.add(s3); c.add(s4); c.add(s5); Object[] objs = c.toArray(); for(int x=0;x&lt;objs.length;x++) &#123; Student s = (Student)objs[x]; System.out.println(s.toString()); &#125; &#125;&#125; 2.12345678910111213141516171819202122232425262728293031323334353637383940import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;/* * * 练习：用集合存储5个学生对象，并用迭代器进行遍历。 */public class StudentTest &#123; public static void main(String[] args) &#123; Collection c = new ArrayList(); Student s1 = new Student(&quot;肖鹏&quot;,25); Student s2 = new Student(&quot;罗生银&quot;,24); Student s3 = new Student(&quot;喻勇&quot;,25); Student s4 = new Student(&quot;徐超&quot;,26); Student s5 = new Student(&quot;陈杰&quot;,26); c.add(s1); c.add(s2); c.add(s3); c.add(s4); c.add(s5); //创建迭代器Iterator //Iterator it = c.iterator(); //while(it.hasNext()) &#123; //Student s = (Student)it.next(); //System.out.println(s.getName()+&quot;---&quot;+s.getAge()); //&#125; //用for循环改写 for(Iterator it = c.iterator();it.hasNext();) &#123;//while格式清晰，但是使用for循环后,it已经是垃圾了，能提高内存利用率 Student s = (Student)it.next(); System.out.println(s.getName()+&quot;---&quot;+s.getAge()); //使用如下代码会出现NoSuchElementException错误 //System.out.println(((Student)it.next()).getName()+&quot;---&quot;+((Student)it.next()).getAge()); //因为它执行时，同一个语句执行了两次next()，实际上是输出了第一个学生的名字和第二个学生的年龄，所以最后一次是输出第五个学生的名字和第六个学生的年龄，因为没有第六个学生，所以报错。 &#125; &#125;&#125; 迭代器为什么不定义成一个类，而是一个接口呢？Java中提供了很多集合类，而这些集合类的数据结构是不同的。所以它们的存储方式和遍历方式应该是不同的。定义迭代器类就是一个具体实现，那方式就是一样的了。最终，就没有定义迭代器类。判断功能和获取功能应该是一个集合遍历所具备的，而每种集合的方式又不太一样，所以我们把这两个功能给提取出来，并不提供具体实现，这种方式就是接口。那么，真正的具体实现类在哪里呢？在真正的具体的子类中，以内部类的方式体现的。 三、集合(List)1.List概述（1）有序的集合（2）与set不同，List通常允许重复的元素。 2.List特有功能2.1 添加功能void add(int index,Object element):在指定索引位置添加元素。2.2 获取功能Object get(int index):获取指定位置的元素。2.3 列表迭代器ListIterator listIterator():List集合特有的迭代器。ListIterator listIterator(int index):从指定位置开始迭代。2.4 删除功能Object remove(int index):根据索引删除元素，返回被删除的元素。2.5 修改功能Object set(int index,Object element):根据索引修改元素，返回被修改的元素。123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.ArrayList;import java.util.List;/* * 2.1 添加功能 void add(int index,Object element):在指定索引位置添加元素。 2.2 获取功能 Object get(int index):获取指定位置的元素。 2.3 列表迭代器 ListIterator listIterator():List集合特有的迭代器。 ListIterator listIterator(int index):从指定位置开始迭代。 2.4 删除功能 Object remove(int index):根据索引删除元素，返回被删除的元素。 2.5 修改功能 Object set(int index,Object element):根据索引修改元素，返回被修改的元素。*/public class ListDemo &#123; public static void main(String[] args) &#123; List list = new ArrayList(); list.add(&quot;hello&quot;); list.add(&quot;world&quot;); list.add(&quot;java&quot;); System.out.println(&quot;list:&quot;+list); System.out.println(&quot;---------&quot;); //void add(int index,Object element):在指定索引位置添加元素。 //list.add(3,&quot;what&quot;);//最大索引+1位置添加元素是没有问题的。 //System.out.println(&quot;list:&quot;+list);//list:[hello, world, java, what] //Object get(int index):获取指定位置的元素。 //System.out.println(&quot;list.get(3):&quot;+list.get(3));//越界 System.out.println(&quot;list.get(2):&quot;+list.get(2));//list.get(2):java System.out.println(&quot;-------------&quot;); //Object remove(int index):根据索引删除元素，返回被删除的元素。 System.out.println(&quot;list.remove(1):&quot;+list.remove(1));//list.remove(1):world System.out.println(&quot;list:&quot;+list);//list:[hello, java] //Object set(int index,Object element):根据索引修改元素，返回被修改的元素。 System.out.println(&quot;list.set(1,\&quot;javaee\&quot;):&quot;+list.set(1, &quot;javaee&quot;));//list.set(1,&quot;javaee&quot;):java System.out.println(&quot;list:&quot;+list);//list:[hello, javaee] &#125;&#125; 2.6 List特有的遍历功能：get()和size()结合12345678910111213141516171819202122import java.util.ArrayList;import java.util.List;/* * List集合特有的遍历功能: * size()和get()结合 * */public class ListDemo2 &#123; public static void main(String[] args) &#123; List list = new ArrayList(); list.add(&quot;hello&quot;); list.add(&quot;world&quot;); list.add(&quot;java&quot;); for(int x=0;x&lt;list.size();x++) &#123; String s = (String)list.get(x); System.out.println(s); &#125; &#125;&#125; 2.7ListIterator列表迭代器ListIterator listIterator():List集合特有的迭代器该迭代器继承了Interator迭代器，所以，就可以直接使用hasNext()和next();ListIterator特有功能：hadPrevious()和previous()注意：ListIterator可以实现逆向遍历，但是必须先正向遍历，才能逆向遍历。所以无意义，一般不使用。（讲了半天结果一般不是用。23333）123456789101112131415161718192021222324252627282930import java.util.ArrayList;import java.util.List;import java.util.ListIterator;/*ListIterator特有功能： * hadPrevious()和previous() * 注意：ListIterator可以实现逆向遍历，但是必须先正向遍历，才能逆向遍历。 */public class ListIteratorDemo &#123; public static void main(String[] args) &#123; List list = new ArrayList(); list.add(&quot;hello&quot;); list.add(&quot;world&quot;); list.add(&quot;java&quot;); ListIterator lit = list.listIterator(); while(lit.hasNext()) &#123; String s = (String)lit.next(); System.out.println(s); &#125; System.out.println(&quot;------------&quot;); while(lit.hasPrevious()) &#123; String s = (String)lit.previous(); System.out.println(s); &#125; &#125;&#125; 面试题1.我有一个集合，如下，请问，我想判断里面有没有“world”这个元素，如果有，我就添加一个“javaee”元素，请写代码实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.util.ArrayList;import java.util.Iterator;import java.util.List;import java.util.ListIterator;/* * 并发修改异常产生的原因及解决办法 * * ConcurrentModificationException: * 执行代码会报上述错误，即并发修改异常。 * 产生的原因： * 迭代器是依赖于集合而存在的，在判断成功后，集合中添加了新的元素，而迭代器不知道，所以就报错了，这个错误叫并发修改异常。 * 其实这个问题描述的是：迭代器遍历元素的时候，通过集合是不能修改元素的。 * 解决方法： * （1）迭代器迭代元素，迭代器修改元素 * 而Iterator迭代器没有添加功能，所以我们使用其子接口ListIterator。 * （2）集合遍历元素，集合修改元素（普通for） * */public class ListIteratorDemo2 &#123; public static void main(String[] args) &#123; //创建List集合对象 List list = new ArrayList(); //添加元素 list.add(&quot;hello&quot;); list.add(&quot;world&quot;); list.add(&quot;java&quot;); //迭代器遍历 // Iterator it = list.iterator(); // // while(it.hasNext()) &#123; // String s = (String)it.next(); // if(&quot;world&quot;.equals(s)) &#123; // list.add(&quot;javaee&quot;); // &#125; // &#125; // （1）迭代器迭代元素，迭代器修改元素 // 而Iterator迭代器没有添加功能，所以我们使用其子接口ListIterator。 // ListIterator lit =list.listIterator(); // while(lit.hasNext()) &#123; // String s = (String)lit.next(); // if(&quot;world&quot;.equals(s)) &#123; // lit.add(&quot;javeee&quot;); // &#125; // &#125; // System.out.println(&quot;list:&quot;+list);//list:[hello, world, javaee, java] //（2）集合遍历元素，集合修改元素（普通for） for(int x=0;x&lt;list.size();x++) &#123; String s = (String)list.get(x); if(&quot;world&quot;.equals(s)) &#123; list.add(&quot;javaee&quot;); &#125; &#125; System.out.println(&quot;list:&quot;+list);//list:[hello, world, java, javaee] &#125;&#125; 2.ArrarList:底层数据结构是数组，查询快，增删慢。线程不安全，效率高Vector：底层数据结构是数组，查询快，增删慢。线程安全，效率低。现在基本不怎么用LinkedList：底层数据结构是链表，查询慢，增删快。线程不安全，效率高。 上述三者根据需求不同选择：要安全吗？要。Vector（即使要安全也不用这个，后面有替代的）不要。ArrayList和LinkedList查询多：ArrayList增删多：LinkedList 四、常见数据结构0.数据结构概述数据的组织方式面试题：常见的数据结构的优缺点？（数据结构+算法） 1.栈（先进后出）压栈：进入栈弹栈：退出栈举例：弹夹 2.队列（先进先出）举例：火车站排队买票 3.数组查询快，增删慢。 4.链表由一个链子把多个结点连起来组成的数据。结点：由数据和地址组成。（专业说法：由数据域和指针域组成） 5.树（后面讲）6.哈希表（后面讲）]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday14]]></title>
    <url>%2F2019%2F07%2F31%2Fjavaday14%2F</url>
    <content type="text"><![CDATA[一、正则表达式1.正则表达式概述正则表达式：符合一定规则的字符串 2.正则表达式的组成规则2.1字符x 字符x 举例：’a’表示字符a\ 反斜线字符\n 换行\r 回车符 2.2字符类[abc] a、b或c(简单类)三者选一[^abc] 任何字符，除了a，b，c[a-zA-Z] a到z或A到z，两头的字母包括在内(范围)[0-9] 0到9的字符都包括。同时还可以[x-y],x，y为任意个位数。 2.3预定义字符类. 任何字符。 我的就是.字符本身怎么表示？ .\d 数字:[0-9]\D 非数字:[^0-9]\w 单词字符:[a-zA-Z_0-9] 在正则表达式里面组成单词的东西必须有这些东西组成 2.4边界匹配器^ 行的开头$ 行的结尾\b 单词边界：就是不是单词的地方。 举例：hello world?haha;xixi 2.5数量词X? X,一次或一次也没有X* 零次或多次(包括1次)X+ 一次或多次X{n} 恰好n次X{n,} 至少n次X{n,m} 至少n次，但不超过m次 3.正则表达式的应用3.1判断功能String类的public boolean matches(String regex):判断字符串是否符合规定的正则表达式案例：12345678910111213141516public class RgexDemo &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入你的手机号码：&quot;); String phoneNumber = sc.nextLine(); //定义手机号的规则 String regex = &quot;[1][38]\\d&#123;9&#125;&quot;; while(!phoneNumber.matches(regex)) &#123; System.out.println(&quot;您输入的手机号码有误，请重新输入:&quot;); phoneNumber = sc.nextLine(); &#125; System.out.println(&quot;您输入的是正确的手机号码，正好在登陆，请稍等...&quot;); &#125;&#125; 练习：1.校验邮箱，测试的邮箱名如下1517806580@qq.comliuyi@163.comlinqingxia@126.comfengqingyang@sina.com.cnfqy@itcast.cn12345678910111213141516public class RegexTest &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入需要校验的邮箱：&quot;); String email = sc.nextLine(); //创建正则表达式 //String regex = &quot;[a-zA-Z_0-9]+@[a-zA-Z_0-9]&#123;2,6&#125;(\\.[a-zA-Z_0-9]&#123;2,3&#125;)+&quot;; //简化 String regex = &quot;\\w+@\\w&#123;2,6&#125;(\\.\\w&#123;2,3&#125;)+&quot;; boolean flag = email.matches(regex); System.out.println(&quot;eamilresult:&quot;+flag); &#125;&#125; 3.2分割功能String类的public String[] split(String regex)案例：百合网年龄范围选择123456789101112131415161718192021222324252627public class RegexDemo &#123; public static void main(String[] args) &#123; //创建字符串接收年龄范围限制词条 String age = &quot;18---24&quot;; //定义正则表达式 String regex = &quot;-+&quot;; //调用分割功能提取年龄 String[] strArr = age.split(regex); int startAge = Integer.parseInt(strArr[0]); int endAge = Integer.parseInt(strArr[1]); //键盘录入年龄，并通过年龄判断是否符合标准 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入你的年龄：&quot;); int a = sc.nextInt(); if(a&lt;startAge) &#123; System.out.println(&quot;你还小，好好学习&quot;); &#125;else if(a&gt;endAge) &#123; System.out.println(&quot;我还是叫你姐姐吧&quot;); &#125;else &#123; System.out.println(&quot;符合要求，对方正在向你的位置赶来...&quot;); &#125; &#125;&#125; 练习：1.分割功能练习:提取aa，bb，cc和文件路径aa,bb,ccaa.bb.ccaa bb cc123456789101112131415161718192021222324252627282930313233343536public class RegexTest &#123; public static void main(String[] args) &#123; // 定义一个字符串 String str1 = &quot;aa,bb,cc&quot;; // 定义正则表达式 String regex1 = &quot;,&quot;; String[] strArr1 = str1.split(regex1); for (int x = 0; x &lt; strArr1.length; x++) &#123; System.out.println(strArr1[x]); &#125; System.out.println(&quot;-------------&quot;); String str2 = &quot;aa.bb.cc&quot;; String regex2 = &quot;\\.&quot;; String[] strArr2 = str2.split(regex2); for (int x = 0; x &lt; strArr2.length; x++) &#123; System.out.println(strArr2[x]); &#125; System.out.println(&quot;--------------&quot;); String str3 = &quot;aa bb cc&quot;; String regex3 = &quot; +&quot;; String[] strArr3 = str3.split(regex3); for (int x = 0; x &lt; strArr3.length; x++) &#123; System.out.println(strArr3[x]); &#125; // 硬盘上的路径，我们应该用\\替代 String str4 = &quot;E:\\JavaSE\\day14\\avi&quot;; String regex4 = &quot;\\\\&quot;; String[] strArr4 = str4.split(regex4); for (int x = 0; x &lt; strArr4.length; x++) &#123; System.out.println(strArr4[x]); &#125; &#125;&#125; 2.我有如下一个字符串：“91 27 46 38 50”请写代码实现最终输出结果：“27 38 46 50 91”123456789101112131415161718192021222324252627public class RegexTest2 &#123; public static void main(String[] args) &#123; String s = &quot;91 27 46 38 50&quot;; // 定义正则表达式 String regex = &quot; +&quot;; // 实现分割功能 String[] sArr = s.split(regex); // 字符串数组转成int数组 // （其实字符串数组也可以实现排序功能，但是还没学习，也不知道为什么可以，暂时先不用） // 字符串数组排序：Arrays.sort(sArr); int[] arr = new int[sArr.length]; for (int x = 0; x &lt; sArr.length; x++) &#123; arr[x] = Integer.parseInt(sArr[x]); &#125; Arrays.sort(arr); // StringBuilder拼接 StringBuilder sb = new StringBuilder(); for (int x = 0; x &lt; arr.length; x++) &#123; sb.append(arr[x]).append(&quot; &quot;);//拼接完后最后一个数字之后还多一个空格，等下用trim()去掉 &#125; // StringBilder转String String s2 = String.valueOf(sb).trim();//trim去掉前后空格 System.out.println(s2); &#125;&#125; 3.3替换功能String类的public String replaceAll(String regex,String replacement)使用给定的repalcement替换此字符串所有匹配给定的正则表达式的子字符串。123456789101112public class RegexDemo &#123; public static void main(String[] args) &#123; String s = &quot;hello3123123world3442java&quot;; String regex = &quot;\\d&quot;; String replace = &quot;*&quot;; String result = s.replaceAll(regex, replace); System.out.println(result); &#125;&#125; 3.4获取功能Pattern类和Matcher类的使用案例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.regex.Matcher;import java.util.regex.Pattern;/* * * 获取功能案例： * da jia ting wo shuo,jin tian yao xia yu,bu shang wan zi xi,gao xing bu? * 获取该字符串中由三个字符组成的单词 */public class RegexDemo2 &#123; public static void main(String[] args) &#123; // 定义字符串 String s = &quot;da jia ting wo shuo,jin tian yao xia yu,bu shang wan zi xi,gao xing bu?&quot;; // 规则 // String regex = &quot;\\w&#123;3&#125;&quot;; String regex = &quot;\\b\\w&#123;3&#125;\\b&quot;; // 把规则编译成模式对象 Pattern p = Pattern.compile(regex); // 通过模式对象得到匹配器对象 Matcher m = p.matcher(s); /* * //调用匹配器对象的功能 //通过find()查找有没有满足对象的字串 //public boolean find() boolean * flag = m.find(); System.out.println(flag);//true //如何得到值呢？ //public * String group() String ss = m.group(); System.out.println(ss);//jia * * //再来一次 flag = m.find(); System.out.println(flag);//true ss = * m.group(); System.out.println(ss);//tin,这里出问题了，原文应该是ting， * //但是regex定的规则只是3个英文或数字字符，并没有限定边界。 //所以应该用单词边界：\b来限定。 * * //如此一来，功能就完成了，之后把前面都注释掉，通过循环改进 */ while (m.find()) &#123; System.out.println(m.group()); // 结果如下： // jia // jin // yao // xia // wan // gao &#125; &#125;&#125; 注意：先调用find()后才能调用group(),规则就是这样定的。 二、Math1.Math类概述Math类包含执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。两个成员变量：public static final double PI;圆周率pipublic static final double E;自然对数e 2.Math类的成员方法(方法都是静态的)int abs(int a):绝对值double ceil(double a):向上取整（大于a的最小整数）double floor(double a):向下取整int max(int a,int b):最大值int min(int a,int b):最小值double pow(double a,double b):a的b次幂;double random():随机数[0.0,1.0)int round(float a):四舍五入int round(double a):四舍五入double sqrt(double a):正平方根 面试题1.通过键盘录入两个int类型的值，如何获所输入的两个值范围内的int类型随机数？12345678910111213141516171819202122232425public class MathTest &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入第一个数据：&quot;); int a = sc.nextInt(); System.out.println(&quot;请输入第二个数据：&quot;); int b = sc.nextInt(); int start; int end; //方法1:三元运算符取两者中的最大值 //start = a&gt;b?b:a; //end = a&gt;b?a:b; //方法2:Math.max(),Math.min() start = Math.min(a, b); end = Math.max(a, b); for(int x=0;x&lt;100;x++) &#123; System.out.println(&quot;根据您输入的范围所产生的随机数：&quot;+(start+(int)(Math.random()*(end-start+1)))); &#125; &#125;&#125; 三、Random1.Random类概述产生随机数的类 2.Random类的构造方法public Random():没有给种子，用的是默认种子，是当前时间的毫秒值。（每次给的种子不一样）//每次随机的结果不一样public Random(long seed):给出指定的种子。//每次随机的结果一样。 3.Random类的成员方法public int nextInt():返回的是int范围内的随机数public int nextInt(int n)：返回[0,n)范围内的随机数 四、System1.System类概述(成员都是静态的，不能实例化)2.System类的成员方法public static void gc():运行垃圾回收器。public static void exit(int status):终止当前正在运行的Java虚拟机。参数用作状态码，非0的状态码表示异常终止。public static long currentTimeMills():返回以毫秒为单位的当前时间。实际返回的是当前时间与1970年1月1日0时的时间差。//1970年1月1日是因为当时的操作系统只有32位，时间最多只能表示到68年后，那个时候经过商议就定1970年1月1日是时间纪元，时间从这个时候开始算起。但是现在的操作系统已经是64位的了，它能表示的时间长度已经到达亿年以上，够我们N代后代使用了。应用：1234567891011121314public class SystemDemo &#123; public static void main(String[] args) &#123; System.out.println(System.currentTimeMillis()); System.out.println(&quot;---------&quot;); //应用：统计代码的运行时间 long start = System.currentTimeMillis(); for(int x=0;x&lt;100000;x++) &#123; System.out.println(&quot;hello:&quot;+x); &#125; long end = System.currentTimeMillis(); System.out.println(&quot;总共花了：&quot;+(end-start)+&quot;毫秒&quot;); &#125;&#125; public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length):从源数组的指定位置开始，复制到目标数组的指定位置，长度为length。1234567891011121314import java.util.Arrays;public class SystemDemo &#123; public static void main(String[] args) &#123; int[] arr = &#123; 11, 22, 33, 44, 55 &#125;; int[] arr2 = &#123; 6, 7, 8, 9, 10 &#125;; System.arraycopy(arr, 1, arr2, 2, 2); System.out.println(Arrays.toString(arr)); System.out.println(Arrays.toString(arr2)); &#125;&#125; 五、BigInteger1.BigInteger概述因为Integer的最大值为int类型的最大值，不能满足现在的使用了，所以提供一个新的BigInteger类进行使用。它的作用是可以让超过Integer范围内的数据进行计算。 2.构造方法public BigInteger(String val):将字符串格式化成数据。 3.成员方法add(BigInteger val):加abstract(BigInteger val):减multiply(BigInteger val):乘divide(BigInteger val):除以divideAndRemainder(BigInteger val):返回商和余数的数组案例：123456789101112131415public class BigIntegerDemo &#123; public static void main(String[] args) &#123; BigInteger bi1 = new BigInteger(&quot;100&quot;); BigInteger bi2 = new BigInteger(&quot;20&quot;); System.out.println(bi1.add(bi2));//120 System.out.println(bi1.subtract(bi2));//80 System.out.println(bi1.multiply(bi2));//2000 System.out.println(bi1.divide(bi2));//5 BigInteger[] biarr = bi1.divideAndRemainder(bi2); System.out.println(Arrays.toString(biarr));//[5,0] &#125;&#125; 六、BigDecimal1.BigDecimal概述案例引入：12345678public class BigDecimalDemo &#123; public static void main(String[] args) &#123; System.out.println(0.09+0.01);//0.09999999999999999 System.out.println(1.0-0.32);//0.6799999999999999 System.out.println(1.015*100);//101.49999999999999 System.out.println(1.301/100);//0.013009999999999999 &#125;&#125; 由于在计算的时候，float类型和double类型很容易丢失精度(存在循环小数，需要截取有效数字，导致结果很接近，但没办法达到真正的结果，如上述案例)。为了能精确的表示，计算浮点数，Java提供了BigDecimal类。BigDecimal:不可变的，任意精度的有符号十进制数。 2.BigDecimal构造方法public BigDeicimal(String val) 3.BigDecimal成员方法加减乘除public BigDecimal dvide(BigDecimal divisor,int scale,int roundingMode):商，小数点后留几位，如何舍取12345678910public class BigDecimalDemo &#123; public static void main(String[] args) &#123; BigDecimal bd = new BigDecimal(&quot;1.301&quot;); BigDecimal bd2 = new BigDecimal(&quot;100&quot;); System.out.println(bd.divide(bd2)); System.out.println(bd.divide(bd2, 3, BigDecimal.ROUND_HALF_UP)); &#125;&#125; 七、Date/DateFormat1.概述Date类概述类Date表示特定的瞬间，精确到毫秒。 2.构造方法public Date()：根据当前的默认毫秒值创建日期对象public Date(long date):根据给定的毫秒值创建日期对象1234567891011121314151617public class DateDemo &#123; public static void main(String[] args) &#123; //无参构造创建对象 Date d = new Date(); System.out.println(&quot;d:&quot;+d); //带参构造创建对象 long time = System.currentTimeMillis(); Date d2 = new Date(time); System.out.println(&quot;d2:&quot;+d2); //时区演示，我们是东八区 long t = 1000*60*60;//1个小时 Date d3 = new Date(t); System.out.println(&quot;d3:&quot;+d3);//d3:Thu Jan 01 09:00:00 CST 1970 &#125;&#125; 3.成员方法public long getTime():获取时间，以毫秒为单位public void setTime(long time):设置时间123456789101112131415public class DateDemo2 &#123; public static void main(String[] args) &#123; //创建对象 Date d = new Date(); //获取时间 long time = d.getTime(); System.out.println(time); System.out.println(&quot;--------&quot;); System.out.println(&quot;d:&quot;+d); d.setTime(1000); System.out.println(&quot;d:&quot;+d);//d:Thu Jan 01 08:00:01 CST 1970 &#125;&#125; 要求：学完getTime()和setTime(long time)要能够做到以下两步（1）从Date得到一个毫秒值：getTime()（2）把一个毫秒值转换为Date构造方法setTime(long time) 4.DateFormat类概述(需要导包)（1）DateFormat是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间（2）是抽象类，所以使用其子类SimpleDateFormat。可以实现日期和字符串的格式化和解析。 4.DateFormat类构造方法SimpleDateFormat():默认模式SimpleDateFormat(String pattern):给定的日期模式这个模式字符串该怎么写呢？通过查看API，我们就找到了对应的模式。年 y月 M日 d时 H分 m秒 s123456789101112public class DateFormatDemo &#123; public static void main(String[] args) &#123; //Date -- String //创建日期对象 Date d = new Date(); //创建格式化对象 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); //使用format()对日期进行格式化 String s = sdf.format(d); System.out.println(&quot;s:&quot;+s); &#125;&#125; 5.Date及DateFormat类要掌握的内容（总结）123456789101112131415161718192021222324252627282930import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/* * Date -- String(格式化) * public final String format(Date date) * String -- Date(解析) * public Date parse(String source) */public class DateFormatDemo &#123; public static void main(String[] args) throws ParseException &#123; //Date -- String //创建日期对象 Date d = new Date(); //创建格式化对象 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); //使用format()对日期进行格式化 String s = sdf.format(d); System.out.println(&quot;s:&quot;+s); //String -- Date String str = &quot;2008-08-08 12:12:12&quot;; //在把一个字符串解析为日期的时候，请注意格式必须和给定的字符串格式匹配 SimpleDateFormat sdf2 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); Date d2 = sdf2.parse(str); System.out.println(&quot;d2:&quot;+d2); &#125;&#125; Date类及DAteFormat类练习1.制作一个工具类。DateUtil123456789101112131415161718192021222324252627import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/** * 这是日期和字符串相互转换的工具类 * * @author chenjie * * * */public class DateUtil &#123; private DateUtil() &#123; &#125; public static String dateToString(Date d) &#123; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); return sdf.format(d); &#125; public static Date stringToDate(String s) throws ParseException &#123; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); return sdf.parse(s); &#125;&#125; 功能已经写完，但是文档注释写得不好，以后写的时候要改进。2.算一下你来到这个世界多少天？12345678910111213141516171819202122232425262728import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Scanner;/* * 算算你出生到现在多少天？ * * 分析: * （1）键盘录入自己的出生年月，转为Date类型，再转为毫秒值 * （2）获取现在的时间的毫秒值 * （3）现在的时间减去自己出生年月，然后把这个毫秒值数据计算成以天数计的时间 */public class DateTest &#123; public static void main(String[] args) throws ParseException &#123; //键盘录入自己的出生年月 Scanner sc= new Scanner(System.in); System.out.println(&quot;请按格式输入你的出生年月(yyyy-MM-dd):&quot;); String str1 = sc.nextLine(); //String -- Date -- 毫秒值 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date d = sdf.parse(str1); long time1 = d.getTime(); long time2 = System.currentTimeMillis(); System.out.println(&quot;你从出生到现在已经过去了&quot;+((time2-time1)/1000/60/60/24)+&quot;天了，赶紧努力吧&quot;); &#125;&#125; 八、Calendar1.概述Calendar是一个抽象类 2.成员方法public int get(int field):返回给定日历字段的值。日历类中的每个日历字段都是静态的成员变量，并且是int类型。1234567891011121314151617import java.util.Calendar;public class CalendarDemo &#123; public static void main(String[] args) &#123; // 其日历字段已由当前日期和时间初始化: Calendar rightNow = Calendar.getInstance();//子类对象，其实这个就是多态。 //获取年 int year = rightNow.get(Calendar.YEAR); //获取月 int month = rightNow.get(Calendar.MONTH); //获取日 int day = rightNow.get(Calendar.DAY_OF_MONTH); System.out.println(year+&quot;年&quot;+(month+1)+&quot;月&quot;+day+&quot;日&quot;); &#125;&#125; public void add(int field,int amount):根据给定的字段和对应的时间，来对当前的日历进行操作。public final void set(int year,int month,int date):设置当前日历的年月日。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.Calendar;/* * */public class CalendarDemo &#123; public static void main(String[] args) &#123; //获取当前的日期和时间 Calendar c = Calendar.getInstance(); //获取年 int year = c.get(Calendar.YEAR); //获取月 int month = c.get(Calendar.MONTH); //获取日 int day = c.get(Calendar.DAY_OF_MONTH); System.out.println(year+&quot;年&quot;+(month+1)+&quot;月&quot;+day+&quot;日&quot;); System.out.println(&quot;-----------&quot;); //三年前的今天 c.add(Calendar.YEAR, -3); //获取年 int year2 = c.get(Calendar.YEAR); //获取月 int month2 = c.get(Calendar.MONTH); //获取日 int day2 = c.get(Calendar.DAY_OF_MONTH); System.out.println(year2+&quot;年&quot;+(month2+1)+&quot;月&quot;+day2+&quot;日&quot;); System.out.println(&quot;-----------&quot;); //五年后的十天前 c.add(Calendar.YEAR, 5); c.add(Calendar.DAY_OF_MONTH, -10); //获取年 year2 = c.get(Calendar.YEAR); //获取月 month2 = c.get(Calendar.MONTH); //获取日 day2 = c.get(Calendar.DAY_OF_MONTH); System.out.println(year2+&quot;年&quot;+(month2+1)+&quot;月&quot;+day2+&quot;日&quot;); System.out.println(&quot;-----------&quot;); c.set(2011,11,11); //获取年 year2 = c.get(Calendar.YEAR); //获取月 month2 = c.get(Calendar.MONTH); //获取日 day2 = c.get(Calendar.DAY_OF_MONTH); System.out.println(year2+&quot;年&quot;+(month2)+&quot;月&quot;+day2+&quot;日&quot;); System.out.println(&quot;-----------&quot;); &#125;&#125; Calendar练习1.获取任意一年的二月有多少天？12345678910111213141516171819202122232425import java.util.Calendar;import java.util.Scanner;/* * * 任意一年的二月有多少天？ * 分析： * （1）键盘录入年份 * （2）Calendar设置年月日，年就是键盘录入的年份，月就是3月，日就是1日。 * （3）add（）提前一天，得出的结果就是二月的天数 */public class CalendarTest &#123; public static void main(String[] args) &#123; //键盘录入年份 Scanner sc= new Scanner(System.in); System.out.println(&quot;请输入年份：&quot;); int year = sc.nextInt(); Calendar c = Calendar.getInstance(); c.set(year,2,1); c.add(Calendar.DAY_OF_MONTH, -1); System.out.println(&quot;你输入的这个年份中二月一共有&quot;+c.get(Calendar.DAY_OF_MONTH)+&quot;天&quot;); &#125;&#125;]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday13]]></title>
    <url>%2F2019%2F07%2F30%2Fjavaday13%2F</url>
    <content type="text"><![CDATA[一、StringBuffer类1.StringBuffer类概述按照String类的拼接原理（”hello”+”world”拼接会产生三个量，在常量池开辟三个空间），每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。而StringBuffer就可以解决这个问题。StringBuffer:线程安全的可变字符串。什么叫线程安全？具体在多线程部分讲解，这里简单提一下安全的意思。安全–同步–数据是安全的不安全–不同步–效率高举例：安全–医院的网站，银行网站效率–新闻网站，论坛之类的StringBuffer和String的区别？前者长度和内容可变，后者不可变。 2.StringBuffer类的构造方法public StringBuffer():无参构造public StringBuffer(int capacity):指定容量的字符串缓冲区对象。public StringBuffer(String str):指定字符串内容的字符串缓冲区对象。 tips：StringBuffer的一个方法：public int capacity():返回当前容量。//可以看作水杯的最大容量。理论值public int length():返回长度(字符数) //可以看作水杯中现在装有的水的多少。实际值 3.StringBuffer类的成员方法3.1 StringBuffer类的添加功能3.1.1 public StringBuffer append(String str):可以把任意类型添加到字符串缓冲区里面，并返回字符串缓冲区本身。//这个方法返回类型是StringBuffer，其实返回的是它本身。3.1.2 public StringBuffer insert (int offset,String str):在指定位置把任意类型数据插入到字符串缓冲区，返回字符串缓冲区本身。123456789101112131415161718192021public class StringBufferDemo &#123; public static void main(String[] args) &#123; // public StringBuffer append(String str):可以把任意类型添加到字符串缓冲区里面,并返回字符串缓冲区本身。 StringBuffer sb = new StringBuffer(); StringBuffer sb2 = sb.append(&quot;hello&quot;); System.out.println(&quot;sb:&quot; + sb); // sb:hello System.out.println(&quot;sb2:&quot; + sb2);// sb2:hello System.out.println(sb == sb2);// true //上述结果说明sb.append(&quot;...&quot;)返回的是本身，并没有开辟新空间，这就是StringBuffer与String不同的地方 //所以上述方法可以改进如下 //sb.append(&quot;hello&quot;); sb.append(true).append(12).append(12.34); System.out.println(sb);//hellotrue1212.34 //public StringBuffer insert (int offset,String str):在指定位置把任意类型数据插入到字符串缓冲区，返回字符串缓冲区本身。 sb.insert(5, &quot;world&quot;); System.out.println(&quot;sb:&quot;+sb); &#125;&#125; 3.2 StringBuffer类的删除功能public StringBuffer deleteCharAt(int index):删除指定位置的字符，并返回本身。public StringBuffer delete(int start,int end):删除从指定位置开始到指定位置结束的内容，并返回本身。1234567891011121314151617181920212223242526272829303132333435363738394041public class StringBufferDemo &#123; public static void main(String[] args) &#123; StringBuffer sb = new StringBuffer(); //添加功能 sb.append(&quot;hello&quot;).append(&quot;world&quot;).append(&quot;java&quot;); System.out.println(&quot;sb:&quot;+sb);//sb:helloworldjava System.out.println(&quot;-------------&quot;); //public StringBuffer deleteCharAt(int index):删除指定位置的字符，并返回本身。 //需求：我要删除e这个字符 sb.deleteCharAt(1); System.out.println(&quot;sb:&quot;+sb);//sb:hlloworldjava System.out.println(&quot;-------------&quot;); //补回删除的&apos;e&apos; sb.insert(1, &apos;e&apos;); System.out.println(&quot;sb:&quot;+sb);//sb:helloworldjava //需求：我要删除第一个&apos;l&apos; sb.deleteCharAt(sb.indexOf(&quot;l&quot;)); System.out.println(&quot;sb:&quot;+sb);//sb:heloworldjava System.out.println(&quot;------------&quot;); //补回删除的&apos;l&apos; sb.insert(2, &apos;l&apos;); System.out.println(&quot;sb:&quot;+sb);//sb:helloworldjava //public StringBuffer delete(int start,int end):删除从指定位置开始到指定位置结束的内容，并返回本身。 sb.delete(5, 10); System.out.println(&quot;sb:&quot;+sb);//sb:hellojava System.out.println(&quot;---------&quot;); //补回&quot;world&quot; sb.insert(5, &quot;world&quot;); System.out.println(&quot;sb:&quot;+sb);//sb:helloworldjava //需求：我要删除所有的数据 sb.delete(0, sb.length()); System.out.println(&quot;sb:&quot;+sb);//sb: &#125;&#125; 3.3 StringBuffer类的替换功能public StringBuffer replace(int start,int end,String str):从start开始到end用str替换。12345678910public class StringBufferDemo &#123; public static void main(String[] args) &#123; StringBuffer sb = new StringBuffer(); sb.append(&quot;hello&quot;).append(&quot;world&quot;).append(&quot;java&quot;); //public StringBuffer replace(int start,int end,String str):从start开始到end用str替换。 sb.replace(5, 10, &quot;节日快乐aaa&quot;); System.out.println(&quot;sb:&quot;+sb);//sb:hello节日快乐aaajava &#125;&#125; 3.4 StringBuffer类的反转功能public StringBuffer reverse():将字符串反转,并返回本身。 3.5 StringBuffer类的截取功能public String substring(int start)public String substring(int start,int end)12345678910111213141516public class StringBufferDemo &#123; public static void main(String[] args) &#123; StringBuffer sb = new StringBuffer(&quot;helloworldjava&quot;); //public String substring(int start) String str1 = sb.substring(5); System.out.println(&quot;str1:&quot;+str1);//str1:worldjava System.out.println(&quot;sb:&quot;+sb);//sb:helloworldjava String str2 = sb.substring(5,10); System.out.println(&quot;str2:&quot;+str2);//str2:world System.out.println(&quot;sb:&quot;+sb);//sb:helloworldjava &#125;&#125; 截取功能和前面几个功能的不同返回值类型是String类型，本身没有发生改变。 StringBuffer类练习1.String和StringBuffer的相互转换为什么我们要讲解类之间的转换：A – B的转换我们把A转换为B,其实是为了使用B的功能。B – A的转换我们可能要的结果是A类型，所以还得转回来。123456789101112131415161718192021222324252627282930313233343536373839public class StringBufferTest &#123; public static void main(String[] args) &#123; //String转StringBuffer //注意：不能把字符串的值直接赋值给StringBuffer //StringBuffer sb =&quot;hello&quot;; //这样做是错误的，会报错。 //方法1:通过StringBuffer类的构造方法 String str1 = &quot;helloworld&quot;; StringBuffer sb1 = new StringBuffer(str1); System.out.println(&quot;sb1:&quot;+sb1); //方法2:通过append() StringBuffer sb2 = new StringBuffer(); sb2.append(str1); System.out.println(&quot;sb2:&quot;+sb2); System.out.println(&quot;---------&quot;); //StringBuffer转String //方法1:通过构造方法 //String(StringBuffer buffer) StringBuffer buffer1 = new StringBuffer(); buffer1.append(&quot;helloworld&quot;); String s1 = new String(buffer1); System.out.println(&quot;s1:&quot;+s1); //方法2:使用StringBuffer的截取功能 //自己想的 String s2 = buffer1.substring(0); System.out.println(&quot;s2:&quot;+s2); //方法3:String类的valueOf() //自己想的 String s3 = &quot;&quot;; s3 = s3.valueOf(buffer1); System.out.println(&quot;s3:&quot;+s3); //方式4:通过toString() String s4 = buffer1.toString(); System.out.println(&quot;s4:&quot;+s4); &#125;&#125; 2.把数组拼接成一个字符串3.把数组反转4.判断一个字符串是否是对称字符串形如“aba”或“abba”这种形式。 StringBuffer面试题1.String，StringBuffer,StringBuilder的区别？12(1)String是内容不可变的，而StringBuffer,StringBuilder的内容是可变的。(2)StringBuffer是同步的，数据安全，效率低；StringBuilder是不同步的，数据不安全，效率高。 2.StringBuffer和数组的区别?123二者都可以看成是一个容器，装其他的数据。但是，StringBuffer的数据，最终是一个字符串数据。而数组可以放置多种数据，但必须是同一种类型。 3.看程序写结果：String作为参数传递StringBuffer作为参数传递注意：String作为参数传递，效果和基本类型作为参数传递是一样的，就是形式参数的改变不影响实际参数的改变。 二、数组高级（排序和查找）以及Arrays1.排序1.1冒泡排序冒泡排序：相邻元素两两比较，大的往后放，第一次完毕后，最大值就出现在了最大索引处。同理，继续，即可得到一个排好序的数组。代码实现：123456789101112131415161718192021222324252627282930313233public class ArrayDemo &#123; public static void main(String[] args) &#123; int[] arr =&#123;24,69,80,57,13&#125;; System.out.println(&quot;排序前：&quot;); printArray(arr);//[24, 69, 80, 57, 13] maoPao(arr); System.out.println(&quot;排序后：&quot;); printArray(arr);//[13, 24, 57, 69, 80] &#125; public static void maoPao(int[] arr) &#123;//冒泡排序代码实现 for(int x=0;x&lt;arr.length-1;x++) &#123; for(int y=0;y&lt;arr.length-1-x;y++) &#123; if(arr[y]&gt;arr[y+1]) &#123; arr[y] = (arr[y]+arr[y+1])-(arr[y+1]=arr[y]); &#125; &#125; &#125; &#125; public static void printArray(int[] arr) &#123;//遍历数组 StringBuffer sb = new StringBuffer(); sb.append(&quot;[&quot;); for(int x=0;x&lt;arr.length;x++)&#123; if(x == arr.length-1) &#123; sb.append(arr[x]).append(&quot;]&quot;); &#125;else &#123; sb.append(arr[x]).append(&quot;, &quot;); &#125; &#125; System.out.println(sb.toString()); &#125;&#125; 1.2选择排序选择排序：从0索引开始，依次和后面元素比较，小的往前放，第一次完毕，最小值出现在了最小索引处。123456789101112131415161718192021222324252627public class ArrayDemo2 &#123; public static void main(String[] args) &#123; int[] arr = &#123;2,3,4,5,6,7,1,8,0,9&#125;; for(int x=0;x&lt;arr.length-1;x++) &#123;//选择排序代码实现 for(int y=x+1;y&lt;arr.length;y++) &#123; if(arr[x]&gt;arr[y]) &#123; arr[x]=(arr[x]+arr[y])-(arr[y]=arr[x]); &#125; &#125; &#125; printArray(arr); &#125; public static void printArray(int[] arr) &#123; StringBuffer sb = new StringBuffer(); sb.append(&quot;[&quot;); for(int x=0;x&lt;arr.length;x++) &#123; if(x == arr.length-1) &#123; sb.append(arr[x]).append(&quot;]&quot;); &#125;else &#123; sb.append(arr[x]).append(&quot;, &quot;); &#125; &#125; System.out.println(sb.toString()); &#125;&#125; 练习1.把字符串中的字符进行排序。举例：”dacgebf”结果：”abcdefg” 2.查找基本查找：适用于数组元素无序(从头找到尾)二分查找(折半查找)：适用于数组元素有序代码实现：123456789101112131415161718192021222324252627282930public class ArrayDemo &#123; public static void main(String[] args) &#123; int[] arr = &#123;11,22,33,44,55,66,77,88,99&#125;; int index = getIndex(arr,99); System.out.println(&quot;index:&quot;+index); &#125; //两个明确 //返回值类型：int //参数列表：int[] arr,int value public static int getIndex(int[] arr,int value) &#123;//二分查找方法实现 int min=0; int max = arr.length-1; int mid = (max+min)/2; while(arr[mid]!=value) &#123; if(arr[mid]&gt;value) &#123; max = mid-1; &#125;else if(arr[mid]&lt;value) &#123; min = mid+1; &#125; mid =(max+min)/2; if(min&gt;max) &#123; return -1; &#125; &#125; return mid; &#125;&#125; 注意：不要想着将无序的数组排序后再进行二分查找，这种想法是错误的。因为排序后原有数组元素所对应的索引已经改变，此时进行二分查找得到的结果是排序后的元素对应的索引，不是原数组该元素对应的索引。 3.Array类概述及其常用方法3.1 Array类概述针对数组进行操作的工具类(无构造方法，全是静态成员方法)，提供了排序，查找等功能。在java.util包下，使用时需要导包。 3.2 Array类的成员方法public static String toString(int[] a):把数组转成字符串，所有数组都可以，不仅仅是int数组public static void sort(int[] a):对数组进行排序，也是所有数组都可以。public static int binarySearch(int[] a,int key):二分查找,也是对所有数组都可以。 三、Integer1.基本类型包装类的引入将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据。常用的操作：用于基本数据类型与字符串之间的转换。基本数据类型和包装类的对应：Byte，Short,Integer,Long,Float,Double,Character,Boolean. 2.Integer类的构造方法public Integer(int value)public Integer(String s)1234567891011121314public class IntegerDemo &#123; public static void main(String[] args) &#123; //public Integer(int i) int i = 100; Integer ii = new Integer(i); System.out.println(&quot;ii:&quot;+ii);//ii:100 //public Integer(String s) //只能是由数字组成，不能是字母组成。 //String s = &quot;abc&quot;;//报错。NumberFormatException String s = &quot;100&quot;; Integer iii = new Integer(s); System.out.println(&quot;iii:&quot;+iii);//iii:100 &#125;&#125; 3.Integer类的成员方法3.1 int类型与String类型的转换从实用的角度讲，即int类型与String类型的转换。1234567891011121314151617181920212223242526272829303132333435363738394041/* * int与String的转换 * * int -- String * 推荐用法：String.valueOf(number) * String -- int * 推荐用法：Integer.parseInt(s) * */public class IntegerDemo &#123; public static void main(String[] args) &#123; //int -- String int number = 100; //方式1:字符串拼接 String s1 = &quot;&quot;; s1 += number; System.out.println(&quot;s1:&quot;+s1); //方式2:String.valuseOf（） String s2 = String.valueOf(number); System.out.println(&quot;s2:&quot;+s2); //方式3:int -- Integer --String Integer i = new Integer(number); String s3 = i.toString(); System.out.println(&quot;s3:&quot;+s3); //方式4:Integer静态方法接收int，返回String的toString() String s4 = Integer.toString(number); System.out.println(&quot;s4:&quot;+s4); System.out.println(&quot;--------&quot;); //String -- int String s = &quot;100&quot;; //两者没有直接的转换办法，只能通过String -- Integer -- int的方式进行转换。 //方式1:public int inValue(); Integer ii = new Integer(s); int x1 = ii.intValue(); System.out.println(&quot;x1:&quot;+x1); //方式2:public static int parseInt(String s) int x2 = Integer.parseInt(s); System.out.println(&quot;x2:&quot;+x2); &#125;&#125; 推荐用法一定要记住，其他的选记。3.2 Integer类常用的进制转换方法3.2.1 基本进制转换public static String toBinaryString(int i)public static String toOctalString(int i)public static String toHexString(int i)3.2.2 十进制到其他进制public static String toString(int i,int radix)3.2.3 其他进制到十进制public static int parseInt(String s,int radix)不用刻意记，需要用的时候再回来看看，其他进制除了二进制，八进制，十六进制，还有五进制，七进制等其他进制，就是几乎没什么用而已。进制从2开始，到36.即数字加26个字母组成。 4.JDK5的新特性：自动拆装箱自动装箱：把基本类型转换为包装类型。自动拆箱：把包装类型转换成基本类型。使用自动拆装箱时需要注意：Integer x=null;上面的代码就会报错NullPointerException空指针异常，因为自动拆装箱底层其实是在调用方法，没有对象的话无法调用方法，所以报错。 Integer面试题1.Integer i = 1;i += 1;做了哪些事情？12自动装箱自动拆箱，自动装箱 2.看程序，写结果123456789101112131415161718192021222324252627public class IntegerTest &#123; public static void main(String[] args) &#123; Integer i1 = new Integer(127); Integer i2 = new Integer(127); System.out.println(i1 == i2);//false System.out.println(i1.equals(i2));//true System.out.println(&quot;---------&quot;); Integer i3 = new Integer(128); Integer i4 = new Integer(128); System.out.println(i3 == i4);//false System.out.println(i3.equals(i4));//true System.out.println(&quot;---------------&quot;); Integer i5 = 128; Integer i6 = 128; System.out.println(i5 == i6);//false System.out.println(i5.equals(i6));//true System.out.println(&quot;------------&quot;); Integer i7 = 127; Integer i8 = 127; System.out.println(i7 == i8);//true System.out.println(i7.equals(i8));//true System.out.println(&quot;-------------&quot;); &#125;&#125; 通过查看源码，我们就知道了，针对-128至127之间的数据，做了一个数据缓冲池，如果数据是该范围内的，每次并不创建新的空间。 注意：integer的数据直接赋值，如果在-128至127之间，会直接从缓冲池里获取数据。四、Character1.Character概述Character类在对象中包装一个基本类型char的值。此外，该类提供了几种方法，以确定字符的类别（大小写，数字等），并可以实现字符的大小写转换。 2.构造方法Character（char value） 3.成员方法（都是静态修饰）public static boolean isUpperCase(char ch):判断给定的字符是否是大写字符public static boolean isLowerCase(char ch):判断给定的字符是否是小写字符public static boolean isDigit(char ch):判断给定的字符是否是数字public static char toUpperCase(char ch):把给定的字符转换成大写字符public static char toLowerCase(char ch):把给定的字符转换成小写字符 练习统计一个字符串的大写字符，小写字符，数字的数量，使用Character的成员方法。]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday12]]></title>
    <url>%2F2019%2F07%2F28%2Fjavaday12%2F</url>
    <content type="text"><![CDATA[一、Scanner类概述及其构造方法1.Scanner概述JDK5之后，用于接收键盘录入数据 2.详解Scanner sc = new Scanner(System.in);System是一个类，System类下有一个静态成员变量in:public static final InputStream in;(in的数据类型是InputStream) //标准的输入流，对应着键盘录入。根据上述的信息再去查找Scanner类的构造方法，可以发现：我们当初键盘录入创建对象所使用的构造方法是：Scanner(InputStream source)12PS：在cmd输入时，无论是a，123，String等都是字符串类型的数据，通过Scanner类创建的对象sc接收后，在使用sc.nextXxx()方法转成我们所需要的数据类型。 3.Scanner类的成员方法基本格式：（1）public boolean hasNextXxx():判断是否是某种类型的元素。（2）public Xxx nextXxx():获取该元素。默认情况下，Scanner使用空格，回车作为分隔符。常用方法：public int nextInt()public String nextLine() 4.Scanner获取数据存在的问题如果先获取一个数值，再获取一个字符串，就会出现问题：刚打完回车，准备输入字符串时，Java自动将回车认为是输入的字符串，导致真正想输入的字符串无法输入。如何解决呢？(1)先获取一个数值后，再创建一个新的键盘录入对象获取字符串。123456789public class ScannerDemo2 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int a = sc.nextInt(); Scanner sc2 = new Scanner(System.in); String str = sc2.nextLine(); System.out.println(&quot;a:&quot;+a+&quot;,str:&quot;+str); &#125;&#125; 这个方法的弊端：输入多个数据和字符串时，可能要创建多个Scanner对象。(2)把所有数据都按照字符串获取，然后要什么，你就对应的转换成什么。（推荐用这种方法） 二、String类概述及其构造方法1.String类概述字符串是由多个字符组成的一串数据（字符序列）字符串可以看成是字符数组字符串字面值”abc”也可以看成是一个字符串对象。字符串是常量，一旦被赋值，就不能被改变。 2.构造方法public String() //无参构造public String(byte[] bytes) //把字节数组转换成字符串public String(byte[] bytes,int offset,int length) //把字节数组从某个索引开始的几个数字转成字符串public String(char[] value) //把字符数组转成字符串public String(char[] value,int offset,int count) //把字符数组从某个索引开始的几个字符转成字符串public String(String original) //把字符串常量值转换成字符串tips：字符串的一个方法：public int length():返回此字符串的长度。 2.1public String() //无参构造1234567public class StringDemo &#123; public static void main(String[] args) &#123; String s1 = new String(); System.out.println(&quot;s1:&quot;+s1); //s1: System.out.println(&quot;s1.length():&quot;+s1.length());//s1.length():0 &#125;&#125; 我们知道输出一个对象的变量名等价于调用这个对象的toString()，而toString()默认全路径对象名+‘@’+转换成十六进制的地址值，而我们输出s1的接口是“ ”，说明String类改写了toString()。 2.2public String(byte[] bytes) //把字节数组转换成字符串1234byte[] bys = &#123;97,98,99,100,101&#125;;String s2 = new String(bys);System.out.println(&quot;s2:&quot;+s2); //s2:abcdeSystem.out.println(&quot;s2.length():&quot;+s2.length()); //s2.length():5 2.3public String(byte[] bytes,int offset,int length) //把字节数组从某个索引开始的几个数字转成字符串1234byte[] bys = &#123;97,98,99,100,101&#125;;String s3 = new String(bys,1,3);System.out.println(&quot;s3:&quot; + s3); //s3:bcdSystem.out.println(&quot;s3.length():&quot; + s3.length()); //s3.length():3 2.4public String(char[] value) //把字符数组转成字符串1234char[] chs = &#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;虾&apos;,&apos;哈&apos;&#125;;String s4 = new String(chs);System.out.println(&quot;s4:&quot; + s4); //s4:abcde虾哈System.out.println(&quot;s4.length():&quot; + s4.length()); //s4.length():7 2.5public String(char[] value,int offset,int count) //把字符数组从某个索引开始的几个字符转成字符串123String s5 = new String(chs,0,5);System.out.println(&quot;s5:&quot;+s5); //s5:abcdeSystem.out.println(&quot;s5.length():&quot;+s5.length()); //s5.length():5 2.6public String(String original) //把字符串常量值转换成字符串123String s6 = new String(&quot;abcde&quot;);System.out.println(&quot;s6:&quot;+s6); //s6:abcdeSystem.out.println(&quot;s6.length():&quot;+s6.length()); //s6.length():5 没什么意义，不如直接用String s6 = “abcde”; 3.String类的特点一旦被赋值，就不能改变。（指的是值不改变，引用可以变，即地址值可以变）123String s = &quot;hello&quot;;s += &quot;world&quot;;System.out.println(&quot;s:&quot;+s); //helloworld 这是通过直接赋值的方式创建String对象，字符串直接赋值时，会先到方法区中的字符串常量池里寻找是否有被赋值的字符串(hello),没有的话在常量池创建一个字符串常量，并把地址值0x001赋于String对象s。执行s += “world”时，并不是直接将hello和world进行拼接，因为字符串一旦被赋值，就不能被改变。所以真实的情况时先在常量池里寻找是否有world，没有的话就创建一个world，并赋予地址值0x002，但这个地址值并没有对象指向它。进行拼接操作时，是将创建一个由hello和world两个字符串组成的新字符串常量helloworld，并赋予地址值0x003，将0x003赋给s。 String类面试题1.String s = new String(“hello”);String s = “hello”;两者的区别？有，前者会创建两个对象；后者创建一个对象。==:进行引用类型比较，比较的是地址值是否相同equals():比较引用类型默认也是比较地址值是否相同，而String类重写了equals()，比较的是内容是否相同。12345String s1 = new String(&quot;helloworld&quot;); String s2 = &quot;helloworld&quot;; System.out.println(s1.equals(s2)); //true System.out.println(s1 == s2); //false 2.看程序写结果123456789101112131415161718192021public class StringDemo3 &#123; public static void main(String[] args) &#123; String s1 = new String(&quot;hello&quot;); String s2 = new String(&quot;hello&quot;); System.out.println(s1 == s2); // false System.out.println(s1.equals(s2)); // true System.out.println(&quot;------&quot;); String s3 = new String(&quot;hello&quot;); String s4 = &quot;hello&quot;; System.out.println(s3 == s4); // false System.out.println(s3.equals(s4)); // true System.out.println(&quot;-------&quot;); String s5 = &quot;hello&quot;; String s6 = &quot;hello&quot;; System.out.println(s5 == s6); // true System.out.println(s5.equals(s6)); // true System.out.println(&quot;------&quot;); &#125;&#125; 3.看程序写结果1234567891011public class StringDemo4 &#123; public static void main(String[] args) &#123; String s1 = &quot;hello&quot;; String s2 = &quot;world&quot;; String s3 = &quot;helloworld&quot;; System.out.println(s3 == s1 + s2); // false,因为s1，s2是变量，字符串变量进行拼接时，先开辟空间再拼接。 System.out.println(s3.equals((s1 + s2))); // true System.out.println(s3 == &quot;hello&quot; + &quot;world&quot;); // true，因为&quot;hello&quot;,&quot;world&quot;是常量，先拼接后到常量池寻找，有就直接返回以后的常量，没有就创建后再返回。 System.out.println(s3.equals(&quot;hello&quot; + &quot;world&quot;)); // true &#125;&#125; 结论：字符串如果是变量相加，先开空间，再拼接。字符串如果是常量相加，是先加，然后在常量池找，如果有就直接返回，否则，就创建。 4.String类的判断功能boolean equals(Object obj):比较字符串的内容是否相同boolean equalsIgnoreCase(String str)：比较字符串的内容是否相同，忽略大小写boolean contains(String str)：判断大串中是否包含小串boolean startsWith(String str)：判断字符串是否以某个指定的字符串开头boolean endsWith(String str)：判断字符串是否以某个指定的字符串结尾boolean isEmpty()：判断字符串是否为空。注意：内容为空和字符串对象为空不同。内容为空指对象存在，内容为空。对象为空指对象都不存在。String s = “”； //字符串内容为空String s = null; //字符串对象为空1234567891011121314151617181920212223242526272829303132333435363738public class StringDemo &#123; public static void main(String[] args) &#123; // 创建字符串对象 String s1 = &quot;helloworld&quot;; String s2 = &quot;helloworld&quot;; String s3 = &quot;HelloWorld&quot;; String s4 = &quot;&quot;; String s5 = null; // boolean equals(Object obj):比较字符串的内容是否相同 System.out.println(&quot;equals():&quot; + s1.equals(s2)); // true System.out.println(&quot;equals():&quot; + s1.equals(s3)); // flase System.out.println(&quot;------------&quot;); // boolean equalsIgnoreCase(String str)：比较字符串的内容是否相同，忽略大小写 System.out.println(&quot;equalsIgnoreCase():&quot; + s1.equalsIgnoreCase(s2)); // true System.out.println(&quot;equalsIgnoreCase():&quot; + s1.equalsIgnoreCase(s3)); // true System.out.println(&quot;------------&quot;); // boolean contains(String str)：判断大串中是否包含小串 System.out.println(&quot;contains():&quot; + s1.contains(&quot;hello&quot;)); // true System.out.println(&quot;contains():&quot; + s1.contains(&quot;hw&quot;)); // false System.out.println(&quot;------------&quot;); // boolean startsWith(String str)：判断字符串是否以某个指定的字符串开头 System.out.println(&quot;startsWith():&quot; + s1.startsWith(&quot;h&quot;)); // true System.out.println(&quot;startsWith():&quot; + s1.startsWith(&quot;hello&quot;)); // true System.out.println(&quot;------------&quot;); // boolean endsWith(String str)：判断字符串是否以某个指定的字符串结尾 System.out.println(&quot;endsWith():&quot; + s1.endsWith(&quot;world&quot;)); // true System.out.println(&quot;endsWith():&quot; + s1.endsWith(&quot;d&quot;)); // true System.out.println(&quot;------------&quot;); // boolean isEmpty()：判断字符串是否为空。 System.out.println(s1.isEmpty()); // false System.out.println(s2.isEmpty()); // false System.out.println(s3.isEmpty()); // false System.out.println(s4.isEmpty()); // true System.out.println(s5.isEmpty()); // NullPointerException,因为s5对象都不存在，无法调用方法，空指针异常。 &#125;&#125; String类判断功能练习1.模拟用户登陆案例给三次机会，错误时，提示还有多少次机会。自己的做法：123456789101112131415161718192021222324252627282930313233343536373839404142public class StringTest &#123; public static void main(String[] args) &#123; //定义正确的用户名和密码 String username = &quot;helloworld&quot;; String password = &quot;123456&quot;; String inviteNumber = &quot;hello&quot;; for(int x=1;x&lt;=3;x++) &#123; //创建键盘录入对西那个，并创建String对象进行接收 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入用户名：&quot;); String str1 = sc.nextLine(); System.out.println(&quot;请输入密码：&quot;); String str2 = sc.nextLine(); System.out.println(&quot;请输入邀请码：&quot;); String str3 = sc.nextLine(); if(str1.equals(username)) &#123; if(str2.equals(password)) &#123; if(str3.equalsIgnoreCase(inviteNumber)) &#123; System.out.println(&quot;恭喜你登陆成功&quot;); break; &#125;else &#123; System.out.println(&quot;你输入的邀请码有误&quot;); &#125; &#125;else &#123; System.out.println(&quot;你输入的密码有误&quot;); &#125; &#125;else &#123; System.out.println(&quot;你输入的用户名有误&quot;); &#125; if(x != 3) &#123; System.out.println(&quot;请重试，你还有&quot;+(3-x)+&quot;次机会&quot;); &#125;else &#123; System.out.println(&quot;登陆失败&quot;); &#125; &#125; &#125;&#125; 视频做法知识点相同，就不放上来了。Debug的点加在每个方法的第一条语句，需要使用到的每个方法都要加。2.模拟用户登陆案例，登陆成功，开始玩猜数字小游戏。登陆失败，账号冻结，不能玩游戏。（猜数字小游戏另外写一个类） 5.String类的获取功能int length():获取字符串长度。char charAt(int index):获取指定索引位置的字符。int indexOf(int ch):返回指定字符在此字符串中第一次出现处的索引。为什么这里是int类型，而不是char类型？原因是：‘a’和97其实都可以代表’a’，如果限定是char类型的话，就不能使用数字了。int类型比较方便，两个都可以接收int indexOf(String str):返回指定字符串再此字符串中第一次出现的索引。int indexOf(int ch,int fromIndex):返回指定字符在此字符串中从指定位置后第一次出现的索引。int indexOf(String str,int fromIndex):返回指定字符串在此字符串中从指定位置后第一次出现的索引。String substring(int start):从指定位置开始截取字符串。String substring(int start,int end):从指定位置开始到指定位置结束，截取字符串。1234567891011121314151617181920212223242526272829303132333435363738394041public class StringDemo &#123; public static void main(String[] args) &#123; String s = &quot;helloworld&quot;; // int length():获取字符串长度。 System.out.println(&quot;s.length():&quot; + s.length());// s.length():10 System.out.println(&quot;--------------&quot;); // char charAt(int index):获取指定索引位置的字符。 System.out.println(&quot;s.charAt():&quot; + s.charAt(7)); // s.charAt():r System.out.println(&quot;------------&quot;); // int indexOf(int ch):返回指定字符在此字符串中第一次出现处的索引。 System.out.println(&quot;s.indexOf():&quot; + s.indexOf(&apos;l&apos;)); // s.indexOf():2 System.out.println(&quot;------------&quot;); // int indexOf(String str):返回指定字符串再此字符串中第一次出现的索引。 System.out.println(&quot;s.indexOf():&quot; + s.indexOf(&quot;owo&quot;)); // s.indexOf():4 System.out.println(&quot;-----------&quot;); // int indexOf(int ch,int fromIndex):返回指定字符在此字符串中从指定位置后第一次出现的索引。 System.out.println(&quot;s.indexOf():&quot; + s.indexOf(&apos;l&apos;, 4)); // s.indexOf():8 System.out.println(&quot;s.indexOf():&quot; + s.indexOf(&apos;k&apos;, 4)); // s.indexOf():-1 System.out.println(&quot;s.indexOf():&quot; + s.indexOf(&apos;l&apos;, 40)); // s.indexOf():-1 System.out.println(&quot;-------------&quot;); // int indexOf(String str,int fromIndex):返回指定字符串在此字符串中从指定位置后第一次出现的索引。 String s2 = &quot;hellowordlhelloworld&quot;; System.out.println(&quot;s2.indexOf():&quot; + s2.indexOf(&quot;hello&quot;, 4));// s2.indexOf():10 System.out.println(&quot;---------&quot;); // String substring(int start):从指定位置开始截取字符串。 System.out.println(&quot;s.substring():&quot; + s.substring(5));// s.substring():world System.out.println(&quot;---------&quot;); //String substring(int start,int end):从指定位置开始到指定位置结束，截取字符串。 System.out.println(&quot;s.substring():&quot;+s.substring(0,5));//s.substring():hello System.out.println(&quot;----------&quot;); &#125;&#125; String类获取功能练习1.String类：字符串遍历12345678910111213141516171819202122232425/* * String类:字符串遍历 * * * 分析： * 1.如何获得每一个字符？ * char charAt(int index); * 2.我怎么知道字符到底有多少个？ * int length() */import java.util.Scanner;public class StringTest &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入想要遍历的字符串：&quot;); String str = sc.nextLine(); for(int x=0;x&lt;str.length();x++) &#123; System.out.println(str.charAt(x)); &#125; &#125;&#125; 2.统计一个字符串中大写字母字符，小写字母字符，数字字符出现的次数。（不考虑其他字符）举例：“Hello123World”结果：大写字符：2个小写字符：8个数字字符：3个1234567891011121314151617181920public class StringTest2 &#123; public static void main(String[] args) &#123; String str = &quot;Hello123World&quot;; int bigCount = 0; int smallCount = 0; int numCount = 0; for(int x=0;x&lt;str.length();x++) &#123; if(str.charAt(x)&gt;=&apos;A&apos; &amp;&amp; str.charAt(x)&lt;=&apos;Z&apos;) &#123;// 做比较运算时，char类型会先转成int类型再比较。 bigCount++; &#125;else if(str.charAt(x)&gt;=&apos;a&apos; &amp;&amp; str.charAt(x)&lt;=&apos;z&apos;) &#123; smallCount++; &#125;else if(str.charAt(x)&gt;=&apos;0&apos; &amp;&amp; str.charAt(x)&lt;=&apos;9&apos;) &#123; numCount++; &#125; &#125; System.out.println(&quot;大写字符：&quot;+bigCount); System.out.println(&quot;小写字符：&quot;+smallCount); System.out.println(&quot;数字：&quot;+numCount); &#125;&#125; 6.String类的转换功能byte[] getBytes():把字符串转换成字节数组。char[] toCharArray():把字符串转换成字符数组。static String valueOf(char[] chs):把字符数组转成字符串。static String valueOf(int i):把int类型的数据转成字符串。//不只这两个，valueOf()可以把任意类型的数据转成字符串。（包括引用类型）String toLowerCase():把字符串转成小写。String toUpperCase():把字符串转化成大写。String concat(String str):把字符串拼接。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class StringDemo &#123; public static void main(String[] args) &#123; String str = &quot;JavaSE&quot;; //byte[] getBytes():把字符串转换成字节数组。 byte[] bys = str.getBytes(); for(int x=0;x&lt;bys.length;x++) &#123; System.out.println(bys[x]); &#125; System.out.println(&quot;-----------&quot;); //char[] toCharArray():把字符串转换成字符数组。 char[] chs = str.toCharArray(); for(int x=0;x&lt;chs.length;x++) &#123; System.out.println(chs[x]); &#125; System.out.println(&quot;-----------&quot;); //static String valueOf(char[] chs):把字符数组转成字符串。 String str2 = new String().valueOf(chs); System.out.println(str2); System.out.println(&quot;-----------&quot;); //static String valueOf(int i):把int类型的数据转成字符串。 int x = 120; System.out.println(new String().valueOf(x)); System.out.println(&quot;-----------&quot;); //String toLowerCase():把字符串转成小写。 String str3 = str.toLowerCase(); System.out.println(str); System.out.println(str3); System.out.println(&quot;---------&quot;); //String toUpperCase():把字符串转化成大写。 String str4 = str.toUpperCase(); System.out.println(str); System.out.println(str4); System.out.println(&quot;------------&quot;); //String concat(String str):把字符串拼接。 String str5 = &quot;helloworld&quot;; String str6 = str.concat(str5); System.out.println(str6); System.out.println(&quot;------------&quot;); System.out.println(str.concat(&quot;helloworld&quot;)); &#125;&#125; String类转换功能练习题1.把字符串首字母转大写，其他字母转小写。1234567891011121314public class StringTest &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入想要转换的字符串：&quot;); String str = sc.nextLine(); String str2 = &quot;&quot;; String str3 = &quot;&quot;; str2 = str.toUpperCase().substring(0, 1); str3 = str.toLowerCase().substring(1); System.out.println(str2.concat(str3)); &#125;&#125; 7.String类的其他功能7.1替换功能String replace(char old,char new)String replace(String old,String new) 7.2去除字符串两端空格String trim() 7.3按字典顺序比较两个字符串int compareTo(String str)int compareToIgnoreCase(String str) String类练习1.把数组中的数据按照指定格式拼接成一个字符串举例：int[] arr = {1,2,3}; 输出结果：[1, 2, 3]自己的做法1234567891011121314public class StringTest &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,3&#125;; String str = &quot;[&quot;; for(int x=0;x&lt;arr.length;x++) &#123; if(x == arr.length-1) &#123; str = str.concat(arr[x]+&quot;]&quot;); &#125;else &#123; str = str.concat(arr[x]+&quot;, &quot;); &#125; &#125; System.out.println(str); &#125;&#125; 2.字符串反转举例：键盘录入“abc” 输出结果：”cba”123456789101112131415161718192021222324252627282930313233public class StringTest2 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入想要反转的字符串：&quot;); String str = sc.nextLine(); //方法1 System.out.println(reverse1(str)); System.out.println(&quot;----------&quot;); //方法2 System.out.println(reverse2(str)); &#125; public static String reverse1(String str) &#123; // 方法1:转成字符数组，然后倒序拼接 char[] chs = str.toCharArray(); String str2 = &quot;&quot;; for (int x = chs.length - 1; x &gt;= 0; x--) &#123; str2 += chs[x]; &#125; return str2; &#125; public static String reverse2(String str) &#123; //方法2:length()和charAt()结合。 //不用将字符串转成字符数组 String str2 = &quot;&quot;; for(int x=str.length()-1;x&gt;=0;x--) &#123; str2+=str.charAt(x); &#125; return str2; &#125;&#125; 3.统计大串中小串出现的次数举例：在字符串“woaijavawozhenaijavawozhendeaijavawozhendehenaijavaxinbuxinwoaijavagun”中java出现了5次123456789101112131415161718192021public class StringTest3 &#123; public static void main(String[] args) &#123; String maxStr = &quot;woaijavawozhenaijavawozhendeaijavawozhendehenaijavaxinbuxinwoaijavagun&quot;; String minStr = &quot;java&quot;; System.out.println(&quot;java一共出现了&quot; + con(maxStr,minStr) + &quot;次&quot;); &#125; public static int con(String maxStr,String minStr) &#123; // 创建一个统计变量 int count = 0; // 找到&quot;java&quot;第一次出现的索引 // 截取字符串。 while (maxStr.contains(minStr)) &#123; int index = maxStr.indexOf(minStr); count++; maxStr = maxStr.substring(index + minStr.length()); &#125; return count; &#125;&#125; 可以试着改成键盘录入大串，小串。]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday11]]></title>
    <url>%2F2019%2F07%2F28%2Fjavaday11%2F</url>
    <content type="text"><![CDATA[一、eclipse基本使用略。 二、API（application programming interface应用程序编程接口）1.API概述简单的说就是JDK提供的各种方便我们开发的java类。 三、Object类1.Object类概述类层次结构的根类。每个类都直接或间接继承自Object类。 2.构造方法只有public Object()无参构造。这也是子类继承父类时，默认访问无参构造的原因。 3.Object类的hashCode()方法public int hashCode():返回该对象的哈希值。哈希值是根据实际地址值利用哈希算法换算出来的一个int类型的值，与地址值有关，但并不是真正的地址值。 4.Object类的getClass()方法public final Class getClass():返回此Object的运行时类。简单记住返回的是一个Class类的类名（即返回该类的对象）即可，day27的反射会详细讲。而Class类中还有一个方法public String getName()：以String形式返回此Class对象所表示的实体名称。案例：123456Student s = new Student();Class c = s.getClass();String str = c.getName();System.out.println(str); //结果：cn.itcast_01.Student//链式编程简化System.out.println(new Student().getClass().getName()); //结果：cn.itcast_01.Student 5.Object类的toString()方法public String toString():返回该对象的字符串表示。结果是1对象名.getClass().getName()+&apos;@&apos;+Integer.toHexString(对象名.hashCode()) Integer类下的一个static方法：public static String toHexString(int i):把一个int类型的数据转成十六进制无符号形式的字符串案例：1System.out.println(s.toString()); //结果：cn.itcast_02.Student@7852e922 这个结果的组成我们已经知道了，但是我们获得这个信息是没有意义的。所以，建议所有子类都重写该方法。（说明书中也是这样建议的）怎么重写呢？把该类的所有成员变量值组成返回即可。案例：12345@Overridepublic String toString() &#123; // TODO Auto-generated method stub //return super.toString(); return &quot;姓名：&quot;+name+&quot;，年龄：&quot;+age; 也可以command+option+s自动生成(建议自动生成)1234@Override public String toString() &#123; return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; &#125; 注意：直接输出对象名称等价于调用对象的toString()方法1System.out.println(s);//Student [name=null, age=0] 6.Object类的equals()方法public boolean equals(Object obj):指示其他某个对象是否与此对象”相等“。默认比较对象的地址值。比较地址值一般来说意义不大，所以我们要重写该方法。怎么重写呢？一般都是用来比较对象的成员变量值是否相同。因为name是字符串，字符串是引用类型，用“==”和Object类的equals()方法都无法比较它的内容，好在String类中已重写equals()方法，String类的equals()方法比较的就是字符串的内容。自己重写学生类的equals()方法:12345678public boolean equals(Object obj) &#123; Student s = (Student)obj; //name和age是Student类特有的成员变量，如果不向下转型的话，obj是多态的形式，无法访问Student的特有成员变量。 if(this.name.equals(s.name) &amp;&amp; this.age == s.age) &#123; return true; &#125;else &#123; return false; &#125; &#125; 上述重写存在一些问题：（1）同一个对象是否还需要比较？（自己跟自己还用比吗？）（2）假如我接收的是一个Demo类，向下转型时会失败。所以需要先判断我接收的类是不是一个学生类。判断方法如下：格式：obj instanceof Student //instanceof是关键字，这个语句返回的是true或者false。所以改进equals()方法的代码如下：12345678910111213141516public boolean equals(Object obj) &#123; if(this == obj) &#123; //判断是否是跟自己比 return true; &#125; if(!(obj instanceof Student)) &#123; //判断接收的类是不是一个学生类 return false; &#125; Student s = (Student)obj; if(this.name.equals(s.name) &amp;&amp; this.age == s.age) &#123; return true; &#125;else &#123; return false; &#125; &#125; 同理，这个也是可以自动生成的。自动生成的代码如下：1234567891011121314151617public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) //返回字节码文件对象，同一个类的字节码文件对象在内存中只有一个，如果两者是同一个类型的对象，那它们的字节码文件相同。 return false; Student other = (Student) obj; if (age != other.age) return false; if (name == null) &#123; if (other.name != null) return false; &#125; else if (!name.equals(other.name)) return false; return true;&#125; 1234PS：比较运算符==:基本类型：比较的就是值是否形同。引用类型：比较地址值是否相同。 7.Object类的其他方法7.1 finalize()protected void finalize():当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。用于垃圾回收，但是什么时候回收不确定。 7.2 clone()protected Object clone():创建并返回此对象的一个副本。该方法是protected修饰，在此案例中是Student的父类Object类的方法，在StudentTest类（不同包下的无关类）中就算创建Object的子类对象Student也无法进行访问。如何访问呢？（1）重写该方法。借助option+/半自动生成。重写后代码如下：123protected Object clone() throws CloneNotSupportedException &#123; //抛出异常后面会讲，先不用管 return super.clone(); &#125; 测试类中代码如下：123456789public class StudentTest &#123; public static void main(String[] args) throws CloneNotSupportedException &#123;// 创建学生对象 Student s = new Student(); //克隆学生对象 Object obj = s.clone(); &#125;&#125; 上述代码会报错，需要在Student类中实现一个接口Cloneable（个人认为类默认是不能被克隆的，实现这个接口后就可以被克隆了）Cloneable:实现此接口，以指示Object.clone()方法可以合法地对该类对象进行按字段复制。这个接口是标记接口，告诉我们实现该接口的类就可以实现对象的复制了。 Object类的6个方法总结Student类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class Student implements Cloneable&#123; private String name; private int age; public Student() &#123; super(); // TODO Auto-generated constructor stub &#125; public Student(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; &#125; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + age; result = prime * result + ((name == null) ? 0 : name.hashCode()); return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Student other = (Student) obj; if (age != other.age) return false; if (name == null) &#123; if (other.name != null) return false; &#125; else if (!name.equals(other.name)) return false; return true; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; // TODO Auto-generated method stub return super.clone(); &#125; &#125; 测试类123456789101112131415161718192021222324252627public class StudentTest &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; //创建对象 Student s = new Student(); Student s2 = new Student(&quot;哈哈哈&quot;,3); //hashCode():返回地址值经过hash算法得到的int类型数据 System.out.println(s.hashCode()); //getClass():返回的时Class类的对象，Class类中有个getName()，可以返回String类型的全路径类名。 String str = s.getClass().getName(); System.out.println(str); //toString():默认输出格式时String类型的全路径名称+&apos;@&apos;+Integer.toHexString(d对象名.hashCode) //建议重写，一般自动生成，重写成显示类名和成员变量的值 String str2 = s.toString(); System.out.println(str2); //equals():默认是用比较运算符&quot;==&quot;进行比较，没有意义。一般进行重写。自动生成。 //重写后比较的是对象中的成员变量是否相等。 boolean result = s.equals(s2); System.out.println(result); //finalize():Java识别对象不再被使用时，对象的垃圾回收器调用此方法进行回收，但是回收时间不确定。 //clone():复制一个对象的副本。Java的类默认是不能复制的，需要先实现Cloneable接口后才能实现，期间的抛出异常问题先忽略，后面会讲解。 //另外，clone()也要进行重写，因为clone()是父类Object的方法，并且是protected修饰，在其他类中进行访问时（不同包下的无关类），就算是创建子类对象进行访问也不行。 //重写可以半自动生成，先打&quot;clone&quot;,之后option+/ //克隆返回的是一个Objecet类的对象，借助向下转型转成相应的对象 //在测试类中也要抛出异常，同样，这个问题后面讲解。 Student s3 = (Student)s.clone(); &#125;&#125;]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday10]]></title>
    <url>%2F2019%2F07%2F27%2Fjavaday10%2F</url>
    <content type="text"><![CDATA[一、抽象类和接口的形式参数、返回值类型问题1.形式参数：（1）基本类型（太简单，不是我今天要讲解的）（2）引用类型：类：匿名对象的时候已经讲过，需要的是类的一个对象。抽象类：需要的是该抽象类的子类对象。接口：需要的是该接口的实现类对象。 2.返回值类型（1）基本类型（太简单，不讲）（2）引用类型：类：返回的事该类的对象。抽象类：返回的是该抽象类的子类对象接口：返回的是该接口的实现类对象。 3.链式编程举例：1234StudentDemo sd = new StudentDemo();//Student s = new Student();//s.study();sd.getStudent().study(); //等同于上面两个“//”，并且之后如果有方法，还可以继续调用下去，这个就称为链式编程。 链式编程的特点：每次调用完毕方法后，返回的是一个对象。 二、包1.包的概述其实就是文件夹，作用是对类进行分类管理。 2.包的格式：package 包名; //多级包用.分开。 3.包的注意事项(1)package语句必须是程序的第一条可执行的代码。(2)package语句在一个java文件中只能有一个。(3)如果没有package，默认表示无包名。 4.带包类的编译和运行4.1手动式手动创建包（文件夹）然后在cmd里输入java cn.itcast.HelloWorld(包名，类名可修改)4.2自动式javac编译的时候带上-d即可。 java -d . Test.java执行命令和手动式一样。 5.不同包之间的访问视频10.14（了解即可，需要用的时候回来看一下就行，基本用不到） 三、导包1.前提不同包下的类之间的访问，我们发现，每次使用不同包下的类的时候，都需要加包的全路径。比较麻烦。这个时候，java就提供了导包的功能。 2.导包格式import 包名;注意：这种方式倒入是到类的名称,虽然最后可以写*，但是不建议，因为这样就导入了所有。 面试题：1.package，import，class有没有顺序关系？package–&gt;import–&gt;class只能有一个 可以有多个 可以有多个，建议是一个。 四、权限修饰符权限修饰符 本类中 同一个包下(包含子类和无关类) 不同包下子类 不同包下无关类private Y默认 Y Yprotected Y Y Ypublic Y Y Y Y 五、常见的修饰符1.类及其组成所使用的常见修饰符权限修饰符：private，默认，protected，public状态修饰符：static，final抽象修饰符：abstract 可以使用的修饰符类：权限修饰符：默认，public状态修饰符：final抽象修饰符：abstract用得最多：public 成员变量：权限修饰符：private，默认，protected，public状态修饰符：static，final用得最多：private 构造方法：权限修饰符：private，默认，protected，public用得最多：public 成员方法：权限修饰符：private，默认，protected，public状态修饰符：static，final抽象修饰符：abstract用得最多：public 除上述之外的组合规则：成员变量：public static final成员方法：public staticpublic finalpublic abstract 补充：成员内部类：权限修饰符：private，默认，protected，public状态修饰符：static，final抽象修饰符：abstract 局部内部类： //局部位置没有权限修饰符，没有意义。状态修饰符：final抽象修饰符：abstract 六、内部类1.内部类概述把类定义在其他类的内部，这个类就被称为内部类。举例：在类A中定义一个类B，类B就是内部类。 2.内部类的访问特点：（1）内部类可以直接访问外部类的成员，包括私有。（2）外部内要访问内部类的成员，必须创建对象。 3.内部类位置3.1成员内部类成员内部类：在成员位置定义的内部类称为成员内部类。如何直接访问成员内部类的成员？外部类名.内部类名 对象名 = 外部类对象.内部类对象;Outer.Inner oi = new Outer().new Inner(); 3.2成员内部类的修饰符(1)private //为了保证数据的安全性.(2)static //为了方便访问数据。注意：a、静态内部类访问的外部类数据必须用静态修饰。b、内部类被静态修饰的方法可以是静态或非静态。成员内部类被静态修饰后的访问方式：格式：外部类名.内部类名 对象名 = new 外部类名.内部类名(); 成员内部类面试题1.补齐程序12345678910111213class Outer &#123; public int num = 10; class Inner &#123; public int num = 20; public void show() &#123; int num = 30; System.out.println(?); //num System.out.println(??); //this.num System.out.println(???); //new Outer().num或者Outer.this.num &#125; &#125;&#125;在控制台分别输出30，20，10 注意：（1）内部类和外部类没有继承关系。（所以不能用super.num）（2）通过外部类名限定this对象。Outer.this 3.3局部内部类局部内部类：在局部位置定义的内部类称为局部内部类。3.3.1 局部内部类的特点： //其实这个特点就对应着上面2.内部类的访问特点。（1）可以直接访问外部类的成员。（2）在局部位置，可以创建内部类对象，通过对象调用内部类方法，来使用局部内部类功能。 3.3.2 面试题1.1234567891011121314151617class Outer &#123; private int num = 10; public void method() &#123; final int num2 = 20; //记住这个final class Inner &#123; public void show() &#123; System.out.println(num); //从内部类中访问本地变量num2，需要被声明为最终类型。 System.out.println(num2); &#125; &#125; Inner i = new Inner(); i.show(); &#125;&#125; 局部内部类访问局部变量的注意事项？局部内部类访问的局部变量必须用final修饰。因为局部变量会随着方法的调用完毕而消失，这个时候，局部对象并没有立马从堆内存消失，还要使用那个变量。为了让数据还能继续被使用，就用final修饰。这样，在堆内存里面存储的其实是一个常量值。 4.匿名内部类就是内部类的简化写法（类似于匿名对象） 4.1匿名内部类的前提存在一个类或者接口。可以是具体类也可以是抽象类。 4.2匿名内部类的格式new 类名或者接口名() { 重写方法;}；//注意这个分号的使用。//根据这个格式只能存在于方法中，要存在于类中需要如下格式：类名或接口名 标识符 = new 类名或者接口名() { 重写方法;}；本质是一个继承了该类或者实现了该接口的子类匿名对象。案例：12345678910111213interface Inter &#123; public abstract void show();&#125;class Outer &#123; public void method() &#123; new Inter() &#123; public void show() &#123; System.out.println(&quot;show&quot;); &#125; &#125;.show(); //匿名内部类的调用。这样的调用很麻烦，下面有比较方便的调用方法。 &#125;&#125; 方便的调用方法如下所示12345678910111213interface Inter &#123; public abstract void show();&#125;class Outer &#123; public void method() &#123; Inter i = new Inter() &#123; //这个是多态，不是接口创建对象（接口是不能实例化的）。new Inter() &#123;...&#125;;是接口Inter的实现类对象， public void show() &#123; System.out.println(&quot;show&quot;); &#125; &#125;.show(); //匿名内部类的调用。这样的调用很麻烦，下面有比较方便的调用方法。 &#125;&#125; 4.3匿名内部类在开发中的应用调用study方法的常规做法和匿名内部类做法，匿名内部类一般用于只调用一次的方法，调用完后变成垃圾回收。123456789101112131415161718192021222324252627282930interface Person &#123; public abstract void study(); &#125;class PersonDemo &#123; public void method(Person p) &#123; p.study(); &#125;&#125;class Student implements Person &#123; public void study() &#123; System.out.println(&quot;好好学习，天天向上&quot;); &#125;&#125;public class InnerClassTest2 &#123; public static void main(String[] args) &#123; PersonDemo pd = new PersonDemo(); pd.method(new Student()); System.out.println(&quot;----------&quot;); pd.method(new Person() &#123; public void study() &#123; System.out.println(&quot;好好学习，天天向上啊&quot;); &#125; &#125;); &#125;&#125; 匿名内部类面试题按照要求，补齐代码12345678interface Inter &#123;void show();&#125;class Outer &#123;//补齐代码&#125;class OuterDemo &#123; public static void main(String[] args) &#123; Outer.method().show(); &#125;&#125;//要求在控制台输出&quot;HelloWorld&quot; 自己的做法1234567891011121314151617181920interface Inter &#123; void show();//隐藏了public abstract&#125;class Outer &#123; public static Inter method() &#123; return new Inter() &#123; public void show() &#123; //注意这个public，对于上面的public abstract，因为实现类方法重写权限不能小于原抽象方法。 System.out.println(&quot;Helloworld&quot;); &#125; &#125;; &#125;&#125;public class OuterDemo &#123; public static void main(String[] args) &#123; Outer.method().show(); &#125;&#125;]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday09]]></title>
    <url>%2F2019%2F07%2F25%2Fjavaday09%2F</url>
    <content type="text"><![CDATA[一、final关键字1.前提：由于继承中方法存在一个现象：方法重写。所以，父类的功能，就会被子类所覆盖掉。有些时候，我们不想让子类覆盖掉父类的功能。针对这种情况，Java提供了关键字：final 2.final概述最终的意思，常见的是它可以修饰类，方法，变量。 3.final修饰类、方法、变量的特点3.1 final修饰类的特点该类不能被继承。 3.2 final修饰方法的特点该方法不能被重写。 3.3 final修饰变量的特点该变量不能被重新赋值（只能被赋值一次）。因为这个变量其实就是常量。（这个就是自定义常量，例：final int x =10;） 面试题1.final修饰局部变量的问题123456789101112131415161718192021222324252627282930class Student &#123; int age = 10;&#125;public class FinalTest &#123; public static void main(String[] args) &#123; //局部变量为基本数据类型 int x =10; x =100; System.out.println(x); final int y = 10; //无法为最终变量y分配值 //y = 100; System.out.println(y); System.out.println(&quot;--------&quot;); //局部变量是引用数据类型 Student s = new Student(); System.out.println(s.age); s.age = 100; System.out.println(s.age); System.out.println(&quot;-----------&quot;); final Student ss = new Student(); System.out.println(ss.age); ss.age = 100;//这并不会报错，因为final修饰引用类型的局部变量是指该变量的地址值不能被重新赋值，与该引用类型变量中的成员变量没有关系 System.out.println(ss.age); &#125;&#125; final修饰局部变量的特点：修饰基本数据类型的局部变量：其值不能被重新赋值。修饰引用类型的局部变量：其地址值不能被重新赋值。2.final修饰变量的初始化时机在对象构造完毕前即可。 二、多态1.多态概述多态：某一个事物（可以理解为java中的对象），在不同时刻表现出来的不同状态。举例：猫可以是猫的类型，猫 m = new 猫();同时猫也可以是动物的一种，也可以把猫称为动物。动物 d = new 猫();举例2:水在不同时刻的状态。 2.多态的前提和体现（1）有继承关系。（2）有方法重写。(没有也可以，但是就没有意义了，因为方法重写才是多态的体现，才能发挥它的作用)（3）有父类引用指向子类对象。//父 f = new 子(); 2# 根据多态前提写一个案例1234567891011121314151617class Fu &#123; public void show() &#123; System.out.println(&quot;show Fu&quot;); &#125;&#125;class Zi extends Fu&#123;//方法继承 public void show() &#123; System.out.println(&quot;show Zi&quot;);//方法重写 &#125;&#125;public class DuoTaiDemo &#123; public static void main(String[] args) &#123; Fu f = new Zi();//父类引用指向子类对象 &#125;&#125; 3.多态中成员访问的特点(1)成员变量编译看左边，运行看左边。(2)构造方法创建子类对象的时候，访问父类的构造方法，对父类的数据进行初始化。(3)成员方法编译看左边，运行看右边。(4)静态方法编译看左边，运行看左边。（静态和类相关，算不上方法重写，所以访问的还是左边的）总结：由于成员方法存在方法重写，所以它运行看右边（子类）。其他编译，运行都是看左边（父类）。 4.多态的好处（1）提高了代码的维护性。（继承保证）（2）提高了代码的扩展性。1234public static void useAnimal(Animal a) &#123;//参数列表中是Animal，但是可以接收继承Animal的所有对象，这其实就是多态，不理解看day09.08视频（多态的好处） a.eat(); a.sleep();&#125; 5.多态的弊端不能使用子类的特有功能。我就想使用子类的特有功能，行不行？行。怎们用呢？（1）创建子类对象调用方法。（可以，但是很多时候不合理，而且，太占内存了）（2）向下转型（既然能够把子类的对象赋值给父类，可以把父类的引用赋值给子类引用。）格式如下：Zi z = (Zi) f;//前提：前面已经有Fu f = new Zi();且Zi继承Fu。 5.1 对象间的转型问题(1)向上转型：Fu f = new Zi();(2)向下转型：Zi z = (Zi)f;//要求是该f必须是能转换为Zi的。回想孔子装爹案例帮助理解。 多态练习1.猫狗案例多态版12345678910111213141516171819202122232425262728293031323334353637383940414243class Animals &#123; public void eat() &#123;&#125;;&#125; class Dog extends Animals &#123; public void eat() &#123; System.out.println(&quot;狗吃肉&quot;); &#125; public void lookDoor() &#123; System.out.println(&quot;狗看门&quot;); &#125;&#125;class Cat extends Animals &#123; public void eat() &#123; System.out.println(&quot;猫吃鱼&quot;); &#125; public void playGame() &#123; System.out.println(&quot;猫做迷藏&quot;); &#125;&#125;public class DuoTaiTest &#123; public static void main(String[] args) &#123; Animals a = new Dog(); a.eat(); Dog d = (Dog)a; d.eat(); d.lookDoor(); System.out.println(&quot;-------&quot;); a = new Cat(); a.eat(); Cat c =(Cat)a; c.eat(); c.playGame(); System.out.println(&quot;-----------&quot;); &#125;&#125; 2.南北方人饮食多态版1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Person &#123; public void eat() &#123; System.out.println(&quot;吃饭&quot;); &#125;&#125;class NorthPerson extends Person &#123; public void eat() &#123; System.out.println(&quot;炖菜，吃馒头&quot;); &#125; public void yanJiu() &#123; System.out.println(&quot;研究&quot;); &#125;&#125;class SouthPerson extends Person &#123; public void eat() &#123; System.out.println(&quot;炒菜，吃米饭&quot;); &#125; public void jingShang() &#123; System.out.println(&quot;经商&quot;); &#125;&#125;public class DuoTaiTest2 &#123; public static void main(String[] args) &#123; //北方人 Person p = new NorthPerson(); p.eat(); NorthPerson np = (NorthPerson)p; np.eat(); np.yanJiu(); //南方人 p = new SouthPerson(); p.eat(); SouthPerson sp = (SouthPerson)p; sp.eat(); sp.jingShang(); &#125;&#125; 3.看程序有没有问题，如果没问题，写出结果。1234567891011121314151617181920212223242526272829303132333435class A &#123; public void show() &#123; show2(); &#125; public void show2() &#123; System.out.println(&quot;我&quot;); &#125;&#125;class B extends A &#123; public void show2() &#123; System.out.println(&quot;爱&quot;); &#125;&#125;class C extends B &#123; public void show() &#123; super.show(); &#125; public void show2() &#123; System.out.println(&quot;你&quot;); &#125;&#125;public class DuoTaiTest3 &#123; public static void main(String[] args) &#123; A a = new B(); a.show();//爱 B b = new C(); b.show();//你 &#125;&#125; 三、抽象类1.抽象类概述虽然我们前面提到了动物类，并创建了动物类对象，但这其实与实际是不相符的，因为动物是一个抽象的概念。所以，我们不应该在动物类中给出具体体现，而是应该给出一个声明即可。在Java中，一个没有方法体的方法应该定义为抽象方法，而类中，如果有抽象方法，则应该被定义为抽象类。（抽象类中其实不一定要有抽象方法，只要有abstract就是抽象类。） 2.抽象类的特点（1）抽象类和抽象方法必须用abstract关键字修饰。（2）抽象类中不一定有抽象方法，但是有抽象方法的类一定要背定义成抽象类。（3）抽象类不能实例化。但是抽象类有构造方法，构造方法的作用是：用于子类访问父类数据的初始化。（4）抽象类的子类必须是抽象类或者重写所有抽象方法的具体类。 3.抽象类的成员特点（1）成员变量：既可以是变量，也可以是常量。（2）构造方法：有。用于子类访问父类数据的初始化。（3）成员方法：既可以是抽象的，也可以是非抽象的。 抽象类练习1.猫狗案例具体事物：猫、狗共性：姓名，年龄，吃饭123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566abstract class Animal &#123; private String name; private int age; public Animal() &#123;&#125; public Animal(String name,int age) &#123; this.name = name; this.age = age; &#125; public void setName(String name) &#123; this.name =name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; public abstract void eat();&#125;class Dog extends Animal &#123; public Dog() &#123;&#125; public Dog(String name,int age) &#123; super(name,age); &#125; public void eat() &#123; System.out.println(&quot;狗吃肉&quot;); &#125;&#125;public class AbstractTest1 &#123; public static void main(String[] args) &#123; //具体类实现 Dog d = new Dog(); d.setAge(3); d.setName(&quot;旺财&quot;); System.out.println(d.getName()+&quot;---&quot;+d.getAge()); d.eat(); Dog d2 = new Dog(&quot;旺财&quot;,3); System.out.println(d.getName()+&quot;---&quot;+d.getAge()); d2.eat(); System.out.println(&quot;---------&quot;); //多态实现 Animal a = new Dog(); a.setName(&quot;旺财&quot;); a.setAge(3); System.out.println(a.getName()+&quot;----&quot;+a.getAge()); d2.eat(); Animal a2 = new Dog(&quot;旺财&quot;,3); System.out.println(a2.getName()+&quot;---&quot;+a2.getAge()); d2.eat(); &#125;&#125; 2.老师案例具体事物：基础班老师，就业班老师共性：姓名，年龄，讲课。3.学生案例具体事物：基础班学员，就业班学员共性：姓名，年龄，班级，学习，吃饭4.员工案例假如我们在开发一个系统时需要对员工类进行设计，员工包含三个属性：姓名、工号以及工资。经理也是员工，除了含有员工属性外，另外还有一个奖金属性。请使用继承的思想设计出员工类和经理类。要求类中提供必要的方法进行属性访问。 4.抽象类的几个小问题4.1 没有抽象方法的抽象类有什么意义？不让外界创建对象。让其只能通过子类去访问它。4.2 abstract不能和哪些关键字共存？abstract一般修饰的是方法和类。private 冲突 子类无法重写抽象类方法，没有意义final 冲突 final修饰的方法不能被重写，修饰的类不能被继承。static 无意义 报错。就算不报错，abstract修饰的方法没有方法体，就算用static修饰，可以使用类名调用也没有意义。 四、接口1.接口引入猫狗除了自身的吃饭，睡觉功能外，还能通过人为训练获得钻火圈，跳高等功能。但这些功能并不是一开始就具备的，放在抽象动物类不合适，也不适合放在猫，狗类中。为了体现事物功能的扩展性，Java就提供了接口来定义这些额外功能，并不给出具体实现，将来哪些猫狗需要被培训，只需要这部分猫狗把这些额外功能实现即可。 2.接口的特点(1)接口用关键字interface表示. 格式： interface 接口名 {}(2)类实现接口用implements表示格式：class 类名 implements 接口名 {}(3)接口不能实例化如果要实现实例化，必须用多态的方式来进行实例化。* 多态的三种实例化a、具体类多态（几乎没有）b、抽象类多态（常用）c、接口多态（最常用）(4)接口的子类a、可以是抽象类，但是意义不大。b、可以是具体类。要重写接口中的所有抽象方法。 3.接口的成员特点（1）成员变量：只能是常量，并且是静态的。可以理解成存在默认修饰符：public static final （建议自己手动给出）（2）构造方法：接口没有构造方法。（ps：所有类都默认继承Object类）（3）成员方法：只能是抽象方法。默认修饰符：public abstract （建议自己手动给出） 4.类与类、类与接口、接口与接口的关系（1）类与类继承关系。只能单继承，但是可以多层继承。（2）类与接口实现关系，可以单实现，也可以多实现。并且还可以在继承一个类的时候实现多个接口。（3）接口与接口继承关系。可以单继承，也可以多继承。 5.抽象类和接口的区别（1）成员区别抽象类：成员变量：可以变量，也可以常量。构造方法：有。成员方法：可以抽象，也可以非抽象。接口：成员变量：只能是常量。public static final构造方法：无。成员方法：只能是抽象方法。 public abstract(2)关系区别1）类与类继承关系。只能单继承，但是可以多层继承。2）类与接口实现关系，可以单实现，也可以多实现。并且还可以在继承一个类的时候实现多个接口。3）接口与接口继承关系。可以单继承，也可以多继承。(3)设计理念区别抽象类 被继承体现的是“is a”的关系。接口 被实现体现的是“like a”的关系。 练习1.猫狗案例，加入跳高的额外功能2.老师和学生案例，加入抽烟的额外功能3.教练和运动员案例乒乓球运动员和篮球运动员。乒乓球教练和篮球教练为了出国交流，跟乒乓球相关的人员都需要学习英语。请用所学知识，分析这个案例中有哪些抽象类，哪些接口，哪些具体类。]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday08]]></title>
    <url>%2F2019%2F07%2F19%2Fjavaday08%2F</url>
    <content type="text"><![CDATA[一、如何制作帮助文档（了解）1.零散知识点1.1在同一个文件夹下，类定义在两个文件中和定义在一个文件中其实是一样的。1.2把构造方法私有，外界就不能再创建该类的对象了。2.练习 二、通过jdk提供的api学习了Math类（掌握）1.猜数字小游戏12345678910111213141516171819import java.util.Scanner;public class GuessNumber &#123; public static void main(String[] args) &#123; int number = (int)(Math.random()*100+1); Scanner sc = new Scanner(System.in); while(true) &#123; System.out.println(&quot;请输入你猜的数字：&quot;); int guessNumber = sc.nextInt(); if(guessNumber &gt; number) &#123; System.out.println(&quot;你输入的数字大了&quot;); &#125;else if(guessNumber &lt; number) &#123; System.out.println(&quot;你输入的数字小了&quot;); &#125;else &#123; System.out.println(&quot;恭喜你猜对了&quot;); break; &#125; &#125; &#125;&#125; 三、代码块（掌握）1.局部代码块位置：局部位置（方法内）作用：限定变量生命周期，及早释放，提高内存利用率。 2.构造代码块位置：类中的成员位置，用{}括起来的代码。作用：每次调用构造方法执行前，都会先执行构造代码块。可以把多个构造方法中的共同代码放到一起，对对象进行初始化。 3.静态代码块位置：在类中的成员位置，用{}括起来的代码，只不过用static修饰了。作用：一般是对类进行初始化。 面试题静态代码块、构造代码块、构造方法的执行顺序：静态代码块–构造代码块–构造方法只执行一次–每次调用构造方法都执行 练习1.看程序写结果123456789101112131415161718192021222324252627class Student &#123; static &#123; System.out.println(&quot;Student 静态代码块&quot;); &#125; &#123; System.out.println(&quot;Student 构造代码块&quot;); &#125; public Student() &#123; System.out.println(&quot;Student 构造方法&quot;); &#125;&#125;public class StudentDemo &#123; static &#123; System.out.println(&quot;main 静态代码块&quot;); &#125; public static void main(String[] args) &#123; System.out.println(&quot;main&quot;); Student s1 = new Student(); Student s2 = new Student(); &#125;&#125; 分析：12345678910111.把带有main方法的类加载到内存中，先执行该类的静态代码块，之后执行main方法。main 静态代码块main2.生成对象前，先加载创建对象所需要的类，此时该类的静态代码块随类加载而加载，即执行Student 静态代码块3.生成对象后，按构造代码块--构造方法的顺序执行代码Student 构造代码块Student 构造方法4.生成的对象有两个，所以再重复执行一次Student 构造代码块Student 构造方法 四、继承（掌握）1.继承概述多个类中存在相同属性和行为时，将这些内容提取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。通过extends关键字可以实现类与类的继承class 子类名 extends 父类名 {}单独的这个类称为父类，基类或者超类；这多个类可以称为子类或派生类。总结：把多个类中相同的内容给提取出来定义到一个类中。 2.继承的案例和继承的好处####2.1 通过一个具体案例来演示代码案例1:学生类和老师。定义两个功能（吃饭，睡觉）案例2:加入人类后改进。 ####2.2 继承的好处（1）多个类相同的成员可以放到同一个类中，提供了代码的复用性。（2）如果功能的代码需要修改，修改一处即可，提高了代码的维护性。（3）让类与类之间产生关系，是多态的前提。这也是一个弊端：类的耦合性很强。开发原则：低耦合，高内聚。耦合：类与类的关系内聚：自己完成某件事情的能力。 3.Java中继承的特点(1)Java只支持单继承，不支持多继承。(2)Java支持多层继承。 4.Java中继承的注意事项(1)子类只能继承父类所有非私有的成员（成员方法和成员变量）(2)子类不能继承父类的构造方法，但是可以通过super（后面讲）关键字区访问父类构造方法。(3)不要为了部分功能而去继承。什么时候考虑使用继承？继承体现的是“is a”的关系，根据这个思路去判断需不需要使用继承。 5.继承中类的成员变量、构造方法、成员方法的关系5.1继承中成员变量的关系（1）子类中的成员变量和父类中的成员变量名称不同简单，不是重点。（2）子类中的成员变量和父类中的成员变量名称相同就近原则。1234在子类方法中访问一个变量的查找顺序：（1）在子类方法的局部范围内寻找，有就使用（2）在子类的成员范围找，有就使用（3）在父类的成员范围找，有就使用 5.2this和super的区别12345678910111213141516171819202122232425/* * * 我要输出局部范围的num，本类成员范围的num，父类成员范围的num。 */class Father &#123; int num = 10;&#125;class Son extends Father &#123; int num = 20; public void show() &#123; int num = 30; System.out.println(num); System.out.println(this.num); System.out.println(super.num); &#125;&#125;public class ExtendsDemo5 &#123; public static void main(String[] args) &#123; Son s = new Son(); s.show(); &#125;&#125; 5.2.1 this和super的区别？(1)this代表本类对应的引用(2)super代表父类存储空间的标识（可以理解为父类引用，可以操作父类的成员。个人理解是这个标识让子类可以操作父类的成员，但是并没有创建一个父类对象） 5.2.2 如何使用?（1）调用成员变量this.成员变量 //调用本类的成员变量super.成员变量 //调用父类的成员变量（2）调用构造方法this(…) //调用本类的构造方法super(…) //调用父类的构造方法 //super()调用父类无参构造 super(String name)调用父类带参构造（3）调用成员方法this.成员方法 //调用本类的成员方法super.成员方法 //调用父类的成员方法 5.3继承中构造方法的关系5.3.1 子类中所有构造方法默认都会访问父类中无参构造方法。为什么呢？（1）因为子类会继承父类中的数据，可能还会使用父类的数据，所以子类初始化之前，一定要先完成父类数据的初始化。（2）每一个构造方法的第一条语句默认都是：super() 5.4继承中构造方法的注意事项如果父类没有无参构造方法，那么子类的构造方法会出现什么现象？报错。如何解决？（1）在父类中加一个无参构造方法.（2）通过使用super关键字去显示的调用父类的带参构造方法。举例：123456789101112131415161718192021222324class Father &#123; public Father(String name) &#123; System.out.println(&quot;Father的带参构造方法&quot;); &#125;&#125;class Son extends Father &#123; public Son() &#123; super(&quot;随便给&quot;); System.out.println(&quot;Son的无参构造方法&quot;); &#125; public Son(String name) &#123; super(&quot;随便给&quot;); System.out.println(&quot;Son的带参构造方法&quot;); &#125;&#125;public class ExtendsDemo7 &#123; public static void main(String[] args) &#123; Son s1 = new Son(); System.out.println(&quot;-------&quot;); Son s2 = new Son(&quot;小强&quot;); &#125;&#125; （3）子类通过this去调用本类的其他构造方法(子类中一定有一个去访问父类的构造方法，否则父类数据就没有初始化)12345678910111213141516171819202122232425class Father &#123; public Father(String name) &#123; System.out.println(&quot;Father的带参构造方法&quot;); &#125;&#125;class Son extends Father &#123; public Son() &#123; super(&quot;随便给&quot;); System.out.println(&quot;Son的无参构造方法&quot;); &#125; public Son(String name) &#123; //super(&quot;随便给&quot;); this(); System.out.println(&quot;Son的带参构造方法&quot;); &#125;&#125;public class ExtendsDemo7 &#123; public static void main(String[] args) &#123; Son s1 = new Son(); System.out.println(&quot;-------&quot;); Son s2 = new Son(&quot;小强&quot;); &#125;&#125; 注意事项：this(…)或者super(…)必须出现在第一条语句上。如果不是放在第一条语句上，就可能对父类的数据进行多次初始化，所以必须放在第一条语句上。 继承中的面试题1.看程序写结果12345678910111213141516171819202122232425262728class Fu &#123; public int num = 10; public Fu() &#123; System.out.println(&quot;fu&quot;); &#125;&#125;class Zi extends Fu&#123; public int num = 20; public Zi() &#123; System.out.println(&quot;zi&quot;); &#125; public void show() &#123; int num = 30; System.out.println(num); System.out.println(this.num); System.out.println(super.num); &#125;&#125;public class ExtendsTest &#123; public static void main(String[] args) &#123; Zi z = new Zi(); z.show(); &#125;&#125; 结果：12345fuzi302010 2.看程序写结果123456789101112131415161718192021222324252627282930313233class Fu &#123; static &#123; System.out.println(&quot;静态代码块Fu&quot;); &#125; &#123; System.out.println(&quot;构造代码块Fu&quot;); &#125; public Fu() &#123; System.out.println(&quot;构造方法Fu&quot;); &#125;&#125;class Zi extends Fu&#123; static &#123; System.out.println(&quot;静态代码块Zi&quot;); &#125; &#123; System.out.println(&quot;构造代码块Zi&quot;); &#125; public Zi() &#123; System.out.println(&quot;构造方法Zi&quot;); &#125;&#125;public class ExtendsTest2 &#123; public static void main(String[] args) &#123; Zi z = new Zi(); &#125;&#125; 结果：123456静态代码块Fu静态代码块Zi构造代码块Fu构造方法Fu //子类初始化会先进行父类的初始化构造代码块Zi构造方法Zi 3.看程序写结果1234567891011121314151617181920212223242526class X &#123; Y b = new Y(); X() &#123; System.out.println(&quot;X&quot;); &#125;&#125;class Y &#123; Y() &#123; System.out.println(&quot;Y&quot;); &#125;&#125;class Z extends X &#123; Y y = new Y(); Z() &#123; //super(); System.out.println(&quot;Z&quot;); &#125; &#125;public class ExtendsTest3 &#123; public static void main(String[] args) &#123; new Z(); &#125;&#125; 结果：1YXYZ 注意：虽然子类中构造方法默认有一个super()但是初始化的时候，不是按照语句的顺序进行的而是按照分层初始化进行的。它仅仅表示要先初始化父类数据，再初始化子类数据。 5.5 继承中成员方法的关系1.子父类不同名方法访问 简单，不是重点2.子父类同名方法访问顺序：（1）先在子类中寻找。（2）然后在父类中寻找。（3）如果还是没有就报错。 5.6 方法重写5.6.1 方法重写：子类中出现了和父类中方法声明一模一样的方法。（一模一样指方法名、参数列表、返回值类型都相同）5.6.2 方法重写的应用1234567891011121314151617181920class Phone &#123; public void call(String name) &#123; System.out.println(&quot;给&quot;+name+&quot;打电话&quot;); &#125;&#125;class NewPhone extends Phone &#123; public void call(String name) &#123; //System.out.println(&quot;给&quot;+name+&quot;打电话&quot;); super.call(name); System.out.println(&quot;听天气预报&quot;); &#125;&#125;public class ExtendsDemo9 &#123; public static void main(String[] args) &#123; NewPhone np = new NewPhone(); np.call(&quot;小强&quot;); &#125;&#125; 注意super.call(name);这个语句，这是方法重写应用的关键。5.6.3 方法重写的注意事项（1）子类不能重写父类的私有方法。1234567class Father &#123; private void show() &#123;&#125;&#125;class Son extends Father &#123; private void show() &#123;&#125; //这个不是方法重写，因为Son并没有继承父类的show（），父类show（）方法是私有的&#125; （2）子类重写父类方法时，权限不能更低。（3）父类静态方法，子类也必须通过静态方法重写。（这个算不上方法重写，但是现象确实如此，至于为什么算不上方法重写，多态中会讲解）5.6.4 面试题1.方法重写和方法重载的区别？方法重载能改变返回值类型吗？Overload和Override我的答案：12方法重写指继承中，子类继承父类的方法，但对父类方法进行改进，在不改变返回值类型、参数列表、方法名的情况下。方法重载指本类中，存在多个方法名相同，但参数列表不同的方法，这是为了应对参数的不同需求，方法重载能改变返回值类型，因为它与返回值类型无关。 视频答案：12345方法重写：在子类中，出现和父类一模一样的方法声明的现象。这里的一模一样指方法名，返回值类型，参数列表都相同。方法重载：同一个类中出现的方法名相同，参数列表不同的现象。方法重载能改变返回值类型，因为它和返回值类型无关。 2.this关键字和super关键字代表什么？以及他们各自的使用场景和作用。this代表本类的对象引用。super代表父类存储空间的标识。 场景：（1）访问成员变量（2）访问构造方法this(…)super(…)（3）访问成员方法 练习1.使用继承后的老师学生类，猫狗案例演示。注意：继承类中父类的this指的是：如果子类重写了，this指的是子类的对象。如果子类没有重写，this指的是父类对象。]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>技能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday07]]></title>
    <url>%2F2019%2F07%2F18%2Fjavaday07%2F</url>
    <content type="text"><![CDATA[一、面向对象_成员变量与局部变量的区别1.在类中的位置不同成员变量：类中方法外局部变量：方法声明上或方法内 2.在内存中的位置不同成员变量：堆内存局部变量：栈内存 3.生命周期不同成员变量：随着对象存在而存在，随着对象消失而消失局部变量：随着方法调用而存在，随着方法调用完毕而消失 4.初始化值不同成员变量：有默认的初始化值局部变量：没有默认的初始化值，必须先定义、赋值，才能使用。 思考题：成员变量名称可不可以和局部变量一样？可以，但是使用的时候要注意，先找小范围，再找大范围。（就近原则） 二、形式参数的问题前面讲到：基本类型：形式参数的改变对实际参数没有影响。引用类型：形式参数的改变直接影响实际参数。类也是一种引用类型，也可以作为调用方法的一个参数，见如下案例1234567891011121314151617181920212223242526272829303132class Demo &#123; public int sum(int a,int b) &#123; return a+b; &#125;&#125;class Student &#123; public void show() &#123; System.out.println(&quot;学生学习&quot;); &#125;&#125;class StudentDemo &#123; public void method(Student s) &#123; s.show(); &#125;&#125;public class ArgsTest &#123; public static void main(String[] args) &#123; //形式参数是基本类型的调用 Demo d = new Demo(); int result = d.sum(10,20); System.out.println(result); System.out.println(&quot;---------&quot;); //形式参数是引用类型的调用 StudentDemo sd = new StudentDemo(); Student s = new Student(); sd.method(s); //类和接口作为形式参数时，实际调用的是它的一个对象。 &#125;&#125; 三、匿名对象1.匿名对象：就是没有名字的对象，是对象的一种简化表示形式。例子：12345678//匿名对象new Student();//匿名对象调用方法new Studnet().show();2.匿名对象的应用场景（1）调用方法，仅仅调用一次的时候。这种调用的好处是：匿名对象调用完毕就是垃圾，可以被垃圾回收器回收。（2）匿名对象可以作为实际参数传递。 四、封装1.封装概述为了防止类中的成员变量被直接使用（非法数据赋值），Java提供了关键字：privateprivate：私有的。可以修饰成员变量和成员方法。注意：被private修饰的成员只能在本类中被访问。这其实是一个封装的思想。封装：指隐藏对象的属性和实现细节，仅对外提供公共访问方式。封装的好处：隐藏实现细节，提供公共的访问方式提高了代码的复用性提高了安全性。封装原则：将不需要对外提供的内容隐藏起来。把属性隐藏，提供公共方法对其访问。 五、private关键字1.privare关键字概述是一个权限修饰符可以修饰成员（成员变量和成员方法）被private修饰的成员只能在本类中被访问。 2.private最常见的应用把成员变量用private修饰提供对应的getXxx()/setXxx()方法 3.private应用的标准案例12345678910111213141516171819202122232425262728293031class Student &#123; private String name; private int age; public void setName(String n) &#123; name = n; &#125; public void setAge(int a) &#123; age = a; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125;&#125;public class StudentTest &#123; public static void main(String[] args) &#123; Student s = new Student(); System.out.println(s.getName()+&quot;---&quot;+s.getAge()); s.setName(&quot;小强&quot;); s.setAge(36); System.out.println(s.getName()+&quot;---&quot;+s.getAge()); &#125;&#125; 六、this关键字1.this:代表所在类的对象引用。方法被哪个对象调用，this就代表那个对象。2.什么时候使用this？（1）局部变量隐藏成员变量（2）其他用法后面和super一起讲解。 3.标准手机类练习12345678910111213141516171819202122232425262728class Phone &#123; private String brand; private int price; public void setBrand(String brand) &#123; this.brand = brand; &#125; public void setPrice(int price) &#123; this.price = price; &#125; public String getBrand() &#123; return brand; &#125; public int getPrice() &#123; return price; &#125;&#125;public class StudentTest &#123; public static void main(String[] args) &#123; Phone p = new Phone(); p.setBrand(&quot;huawei&quot;); p.setPrice(50); System.out.println(p.getBrand()+&quot;---&quot;+p.getPrice()); &#125;&#125; 七、构造方法1.构造方法的作用：给对象的数据进行初始化2.格式方法名与类名相同没有返回值类型，连void都没有没有具体的返回值 3.构造方法的注意事项（1）如果我们没有给出构造方法，系统将自动提供一个无参构造方法。（2）如果我们给出了构造方法，系统将不再提供。 注意：这个时候，如果我们还想使用无参构造方法，就必须自己给出。建议永远自己给出无参构造方法。 4.一个类的组成有三部分：成员变量，构造方法，成员方法。练习：1.一个基本类的标准代码写法（学生类,手机类） 八、类的初始化过程Student s = new Student();在内存中做了哪些事情？加载Student.class文件进内存在栈内存为s开辟空间在堆内存为学生对象开辟空间对学生对象的成员变量进行默认初始化对学生对象的成员变量进行显示初始化通过构造方法对学生对象的成员变量进行赋值学生对象初始化完毕，把对象地址赋值给s变量。 面向对象练习1.定义一个类Demo，其中定义一个求两个数据和的方法，定义一个测试Test，进行测试。2.定义一个长方形类，定义求周长和面积的方法，然后定义一个测试类Test，进行测试。3.定义一个员工类，自己分析出几个成员，然后给出成员变量，构造方法，getXxx()/setXxx()方法，以及一个显示所有成员信息的方法，并测试。4.定义一个类MyMath,实现加减乘除功能。 九、static关键字1.前提：我们创建对象总会碰到多个对象有共同的属性值（例如：邓丽君、杨幂、凤姐都是中国的），Java提供了一个关键字static(静态)来时多个对象共享一个属性值，减少内存空间，提高程序效率。static修饰的变量被赋值后，所有对象的该属性对应的值都是被赋值的这个数据，因为它们共享同一个属性值，可以理解成它们同时共享这个属性。 2.static的特点（1）随着类的加载而加载（想想main方法）（2）优先于对象存在（3）被类的所有对象共享（饮水机可以用静态修饰，水杯不能用静态修饰）（4）可以通过类名调用（也可以和非静态一样，通过对象名调用，推荐用类名调用，静态修饰的内容我们一般称其为：与类相关的，类成员） 3.static关键字注意事项（1）在静态方法中时没有this关键字的如何理解：静态是随着类的加载而加载，而this是随着对象的创建而存在。静态优先于对象存在。在静态加载到内存时，是没有所谓的this的，因为那时候对象还没创建。（2）静态方法只能访问静态的成员变量和静态的成员方法。静态方法：成员变量：只能访问静态变量成员方法：只能访问成员方法非静态方法：成员变量：可以是静态的，也可以是非静态的。成员方法：可以是静态的成员方法，也可以是非静态的成员方法。简单记：静态只能访问静态的，而非静态的可以访问一切。 4.静态变量和成员变量的区别（1）所属不同静态变量属于类，所以也称为类变量成员变量属于对象，所以也称为实例变量（对象变量）（2）内存中位置不同静态变量存储于方法区的静态区成员变量存储于堆内存（3）内存出现时间不同静态变量随着类的加载而加载，随着类的消失而消失成员变量随着对象的创建而存在，随着对象的消失而消失（4）调用不同静态变量可以通过对象名调用，也可以通过类名调用成员变量只能通过对象名调用]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday06]]></title>
    <url>%2F2019%2F07%2F17%2Fjavaday06%2F</url>
    <content type="text"><![CDATA[一、二维数组1.二维数组概述二维数组就是元素为一维数组的数组。 2.二维数组的定义格式格式1:12345数据类型[][] 变量名 = new 数据类型[m][n];m表示二维数组有m个一维数组n表示一维数组有n个元素举例：int[][] arr = new int[3][2]; 定义了一个二维数组arr，这个二维数组有3个一维数组，分别是arr[0],arr[1],arr[2];每一个一维数组有2个元素，可以通过arr[m][n]来获取（表示获取第m+1个一维数组的第n+1个元素）注意下列定义的区别：int x,y; //定义一个x变量，一个y变量int[] x,y[]; //定义一个一维数组x，一个二维数组y练习：自己定义一个二维数组并输出二维数组名，一维数组名，部分元素。格式2:1234567数据类型[][] 变量名 = new 数据类型[m][];m表示这个二维数组有m个一维数组这一次没有直接给出一维数组，可以动态的给出int[][] arr = new int[3][];arr[0] = new int[2];arr[1] = new int[3];arr[2] = new int[1]; 格式3:1234数据类型[][] 变量名 = new 数据类型[][] &#123;&#123;元素...&#125;,&#123;元素...&#125;,&#123;元素...&#125;,...&#125;;简化版格式：数据类型[][] 变量名 = &#123;&#123;元素...&#125;,&#123;元素...&#125;,&#123;元素...&#125;,...&#125;;举例：int[][] arr = &#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6&#125;&#125; 练习：1.二维数组遍历12345678910111213141516171819202122232425public class ArrayTest &#123; public static void main(String[] args) &#123; int[][] arr = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;; printArray2(arr); &#125; public static void printArray2(int[][] arr) &#123; System.out.print(&quot;&#123;&quot;); for(int x=0;x&lt;arr.length;x++) &#123; System.out.print(&quot;&#123;&quot;); for(int y=0;y&lt;arr[x].length;y++) &#123; if(y == arr[x].length-1) &#123; if(x == arr.length-1) &#123; System.out.print(arr[x][y]+&quot;&#125;&quot;); &#125;else &#123; System.out.print(arr[x][y]+&quot;&#125;,&quot;); &#125; &#125;else &#123; System.out.print(arr[x][y]+&quot;,&quot;); &#125; &#125; &#125; System.out.println(&quot;&#125;&quot;); &#125;&#125; 2.公司年销售额求和某公司按照季度和月份统计的数据如下：单位（万元）第一季度：22，66，44第二季度：77，33，88第三季度：25，45，65第四季度：11，66，99123456789101112131415161718192021public class Array2Test2 &#123; public static void main(String[] args) &#123; int[][] arr = &#123;&#123;22,66,44&#125;,&#123;77,33,88&#125;,&#123;25,45,65&#125;,&#123;11,66,99&#125;&#125;; int sum = getSum(arr); System.out.println(&quot;sum:&quot;+sum); &#125; //两个明确： //返回值：int //参数列表：int[][] arr public static int getSum(int[][] arr) &#123; int sum=0; for(int x=0;x&lt;arr.length;x++) &#123; for(int y=0;y&lt;arr[x].length;y++) &#123; sum += arr[x][y]; &#125; &#125; return sum; &#125;&#125; 3.打印杨辉三角(行数可以键盘录入)杨辉三角： 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1自己的做法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.util.Scanner;public class Array2Test3 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入需要绘制的杨辉三角的行数：&quot;); int n = sc.nextInt(); printYang(n); &#125; //两个明确： //返回值类型：void //参数列表：int n public static void printYang(int n) &#123; //创建杨辉三角的数组形状 int[][] arr = new int[n][]; for(int x=0;x&lt;n;x++) &#123; arr[x] = new int[x+1]; &#125; //进行数组的赋值 for(int x=0;x&lt;n;x++) &#123; if(x==0 || x==1) &#123; for(int y=0;y&lt;=x;y++) &#123; arr[x][y]=1; &#125; &#125;else &#123; arr[x][0]=1; for(int y=1;y&lt;=x/2;y++) &#123; arr[x][y]=arr[x-1][y-1]+arr[x-1][y]; &#125; for(int start=0,end=arr[x].length-1;start&lt;end;start++,end--) &#123; arr[x][end] = arr[x][start]; &#125; &#125; &#125; //输出赋值后的杨辉三角 for(int x=0;x&lt;n;x++) &#123; for(int y=0;y&lt;=x;y++) &#123; System.out.print(arr[x][y]+&quot;\t&quot;); &#125; System.out.println(); &#125; &#125; &#125; 视频做法(比较简洁)1234567891011121314151617181920212223242526272829303132import java.util.Scanner;public class Array2Test2Agian &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入要输出的杨辉三角的行数：&quot;); int n = sc.nextInt(); printY(n); &#125; public static void printY(int n) &#123; int[][] arr = new int[n][n]; for(int x=0;x&lt;n;x++) &#123; arr[x][0] = 1; arr[x][x] = 1; &#125; for(int x=2;x&lt;n;x++) &#123; for(int y=1;y&lt;=x-1;y++) &#123; arr[x][y] = arr[x-1][y-1]+arr[x-1][y]; &#125; &#125; for(int x=0;x&lt;n;x++) &#123; for(int y=0;y&lt;=x;y++) &#123; System.out.print(arr[x][y]+&quot;\t&quot;); &#125; System.out.println(); &#125; &#125;&#125; 二维数组思考题：1.看程序写结果，并总结基本类型和引用类型参数的传递问题123456789101112131415161718192021222324252627282930public class Array2Think &#123; public static void main(String[] args) &#123; int a = 10; int b = 20; System.out.println(&quot;a:&quot;+a+&quot;b:&quot;+b); change(a,b); System.out.println(&quot;a:&quot;+a+&quot;b:&quot;+b);// 10,20 int[] arr = &#123;1,2,3,4,5&#125;; change(arr); System.out.println(arr[1]);//4 &#125; public static void change(int a,int b) &#123; System.out.println(&quot;a:&quot;+a+&quot;b:&quot;+b); a = b; b = a+b; System.out.println(&quot;a:&quot;+a+&quot;b:&quot;+b); &#125; public static void change(int[] arr) &#123; for(int x=0;x&lt;arr.length;x++) &#123; if(arr[x]%2==0) &#123; arr[x]*=2; &#125; &#125; &#125;&#125; Java中的参数传递问题 基本类型：形式参数的改变对实际参数没有影响。 引用类型：形式参数的改变直接影响实际参数。2.数据加密问题(重点！重点！一定要掌握)某个公司采用公用电话传递数据信息，数据是小于8位的整数，为了确保安全，在传递过程中需要加密，加密规则如下：首先将数据倒序，然后将每位数字都加上5，再用和除以10的余数代替该数字，最后将第一位和最后一位数字交换。请任意给定一个小于8位的整数，然后，把加密后的结果在控制台打印出来。该题的重点是如何把数据转换成数组：1234567891011121314151617181920212223242526272829303132333435363738import java.util.Scanner;public class Array2Think2 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入整数(少于八位)：&quot;); int num = sc.nextInt(); change(num); &#125; //两个明确 //返回值类型：void //参数列表:int num public static void change(int num) &#123; //将数据用数组存储 int[] arr = new int[8]; int index = 0; while(num&gt;0) &#123; arr[index] = num%10; index++; num/=10; &#125; //加密规则 for(int x=0;x&lt;index;x++) &#123; arr[x] = (arr[x]+5)%10; &#125; arr[0] = (arr[0]+arr[index-1])-(arr[index-1]=arr[0]); //输出数据 for(int x=0;x&lt;index;x++) &#123; System.out.print(arr[x]); &#125; &#125; &#125; 输入：123456;输出：609871. 二、面向对象1.类与对象的关系类：是一组相关的属性和行为的集合。对象：是该类事物的具体体现。举例：类：学生对象：班长就是学生类的一个对象。 2.类的定义现实世界的事物属性 人的身高、体重等行为 人可以学习、吃饭等Java中用class描述事物也是如此成员变量 就是事物的属性成员方法 就是事物的行为定义类其实就是定义类的成员（成员变量和成员方法）成员变量：和以前变量的定义是一样的格式，但是位置不同，类中方法外。成员方法：和以前的方法定义是一样的格式，但是今天把static去掉。 练习：1.学生类定义属性：姓名 年龄 地址行为：学习 吃饭 睡觉2.手机类定义属性：品牌 价格 颜色行为：打电话 发短信 玩游戏 3.在一个java文件中写两个类：一个基本的类，一个测试类。注意：文件名称和测试类名称一致。如何使用呢？ 创建对象使用如何创建对象？格式： 类名 对象名 = new 类名();如何使用成员变量？对象名.变量名如何使用成员方法？对象名.方法名(…) 练习：1.学生类和手机类的成员变量赋值输出，方法调用练习。2.三个对象的内存图]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday05]]></title>
    <url>%2F2019%2F07%2F14%2Fjavaday05%2F</url>
    <content type="text"><![CDATA[一、方法1.前言：假设有一个游戏要不断发射炮弹（植物大战僵尸），发射炮弹需要100行代码，每次发射都写100行代码的话，会很费劲，代码也会显得臃肿，可读性差。所以把这100行代码放入{}中，然后给这段代码起个名字，这样在每次发射炮弹的地方通过这个名字来调用发射炮弹的代码就ok.上述过程中，所提取出来的代码可以被看作是程序中定义的一个方法，程序在需要发射炮弹时调用该方法即可。简单的说：方法就是完成特定功能的代码块在很多语言里面都有函数的定义，函数在java中被称为方法。 2.格式：修饰符 返回值类型 方法名（参数类型 参数名1，参数类型 参数名2，…） { 方法体语句； return 返回值；}上述格式的详细解释： 修饰符：目前就用public static，后面我们再讲解其他的修饰符。 返回值类型：就是功能结果的数据类型。 方法名：符合命名规则即可。 参数： 实际参数：就是实际参与运算的。 形式参数：就是方法定义上的。用于接收实际参数的。 参数类型：就是参数的数据类型。 参数名：就是变量名。 方法体语句：完成功能的代码。 return：结束方法。 返回值：功能的结果，由return返回给调用者。 3.要想写好一个方法，需要明确两个东西：（1）返回值类型 结果的数据类型（2）参数列表 你要传递几个参数以及它们的数据类型。案例：求两个数据之和。1234567891011public class FunctionDemo &#123; public static void main(String[] args) &#123; int x=10; int y=20; &#125; public static int sum(int a,int b) &#123; return a+b; &#125;&#125; 4.方法的执行特点：不调用，不执行如何调用？（以两个数据求和案例为例）（1）有明确返回值的调用//方式1:单独调用sum(x,y); //一般来说没有意义，所以不推荐。//方式2:输出调用System.out.println(sum(x,y)); ////方式3：赋值调用int result = sum(x,y); //推荐方案System.out.println(result); 5.有明确返回值的方法练习：5.1键盘录入两个数据，返回两个数中的较大值。12345678910111213141516171819import java.util.Scanner;public class FunctionTest &#123; public static void main(String[] args) &#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入要进行比较的第一个数据：&quot;); int x = sc.nextInt(); System.out.println(&quot;请输入要进行比较的第二个数据：&quot;); int y = sc.nextInt(); int result = getMax(x,y); System.out.println(&quot;输入的两个数据中，较大值是：&quot;+result); &#125; public static int getMax(int a,int b) &#123; return a&gt;b?a:b; &#125;&#125; 5.2键盘录入两个数据，比较两个数是否相等。12345678910111213141516171819202122import java.util.Scanner;public class FunctionTest2 &#123; public static void main(String[] args) &#123; //键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入第一个数据：&quot;); int x = sc.nextInt(); System.out.println(&quot;请输入第二个数据：&quot;); int y = sc.nextInt(); boolean result = getEqual(x,y); if(result == true) &#123; System.out.println(&quot;输入的这两个数据相等&quot;); &#125;else &#123; System.out.println(&quot;输入的这两个数据不相等&quot;); &#125; &#125; public static boolean getEqual(int a,int b) &#123; return a==b; &#125;&#125; 5.3键盘录入三个数据，返回三个数中的最大值。1234567891011121314151617181920import java.util.Scanner;public class FunctionTest3 &#123; public static void main(String[] args) &#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入第一个数据：&quot;); int x = sc.nextInt(); System.out.println(&quot;请输入第二个数据：&quot;); int y = sc.nextInt(); System.out.println(&quot;请输入第三个数据：&quot;); int z = sc.nextInt(); int result = getMax(x,y,z); System.out.println(&quot;三个数中的最大值是：&quot;+result); &#125; public static int getMax(int a,int b,int c) &#123; return a&gt;b?(a&gt;c?a:c):(b&gt;c?b:c); &#125;&#125; 6.方法的注意事项(1)方法不调用，不执行。(2)方法与方法是平级关系，不能嵌套定义。(3)方法定义的时候参数之间用逗号隔开。(4)方法调用的时候不用再传递数据类型。(5)如果方法有明确的返回值，一定要有return带回一个值。 7.无明确返回值的调用案例：输出m行n列“*”(方法)1234567891011121314public class FunctionTest4 &#123; public static void main(String[] args) &#123; showStar(7,11); &#125; public static void showStar(int m,int n) &#123; for(int x=0;x&lt;m;x++) &#123; for(int y=0;y&lt;n;y++) &#123; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; &#125;&#125; （1）单独调用 //可以（2）输出调用 //报错（3）赋值调用 //报错只有单独调用是可行的。 练习：1.键盘录入行数和列数，输出对应的星形123456789101112131415161718192021import java.util.Scanner;public class FunctionTest4 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入行数：&quot;); int h = sc.nextInt(); System.out.println(&quot;请输入列数：&quot;); int l = sc.nextInt(); showStar(h,l); &#125; public static void showStar(int m,int n) &#123; for(int x=0;x&lt;m;x++) &#123; for(int y=0;y&lt;n;y++) &#123; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; &#125;&#125; 2.键盘录入一个数据n（1&lt;=n&lt;=9）,输出对应的nn乘法表123456789101112131415161718import java.util.Scanner;public class FunctionTest5 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入数据n:&quot;); int n = sc.nextInt(); printN(n); &#125; public static void printN(int n) &#123; for(int x=1;x&lt;=n;x++) &#123; for(int y=1;y&lt;=x;y++) &#123; System.out.print(x+&quot;*&quot;+y+&quot;=&quot;+x*y+&quot;\t&quot;); &#125; System.out.println(); &#125; &#125;&#125; 7.方法重载前言：需求：我要求数的和1234567891011121314151617181920class FunctionDemo4 &#123; public static void main(String[] args) &#123; &#125; //需求1:求两个数的和 public static int sum(int a,int b) &#123; return a+b; &#125; //需求2:求三个数的和 public static int sum1(int a,int b,int c) &#123; return a+b+c; &#125; //需求3:求四个数的和 public static int sum2(int a,int b,int c,int d) &#123; return a+b+c+d; &#125;&#125; 我们的需求不断的发生改变，我们就对应的提供了多个求和的方法。但是它们的名字是不一样的。而我们又要求方法命名做到：见名知意。但是，很明显，现在还没有做到。那么，怎么办呢？针对这种情况：方法功能相同，参数列表不同的情况。为了见名知意：Java允许它们起一样的名字。如下： 1234567891011121314151617181920class FunctionDemo4 &#123; public static void main(String[] args) &#123; &#125; //需求1:求两个数的和 public static int sum(int a,int b) &#123; return a+b; &#125; //需求2:求三个数的和 public static int sum(int a,int b,int c) &#123; return a+b+c; &#125; //需求3:求四个数的和 public static int sum(int a,int b,int c,int d) &#123; return a+b+c+d; &#125;&#125; 这种情况有一个专业名词：方法重载。方法重载：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。方法重载特点：与返回值无关，只看方法名和参数列表。在调用时，虚拟机通过参数列表的不同来区分同名方法。上面的案例继续：123public static float sum(float a,float b) &#123; return a+b;&#125; 调用:1System.out.println(sum(10.5f,20)); //虽然一个是float类型，一个是int类型，但是调用的是float的sum方法，因为int可以转成float（其实这里我没有理解，先记着吧）。结果输出30.5 若是没有123public static int sum(int a,int b) &#123; return a+b;&#125; 只有123public static float sum(float a ,float b) &#123; return a+b;&#125; 而在main方法里执行语句1System.out.println(sum(10,20)); 不会报错，因为这个语句会调用float类型的sum方法，10，20在方法中转为float类型进行计算。 练习：1.比较两个数据是否相等。参数类型分别为两个byte类型，两个short类型，两个int类型，两个long类型。并在main方法中进行测试。12345678910111213141516171819202122232425262728293031public class ReLoadTest &#123; public static void main(String[] args) &#123; byte b1 = 3; byte b2 = 4; System.out.println(equal(b1,b2)); short s1 = 5; short s2 = 6; System.out.println(equal(s1,s2)); &#125; public static boolean equal(byte a,byte b) &#123; System.out.println(&quot;byte&quot;); return a==b; &#125; public static boolean equal(short a,short b) &#123; System.out.println(&quot;short&quot;); return a==b; &#125; public static boolean equal(int a,int b) &#123; System.out.println(&quot;int&quot;); return a==b; &#125; public static boolean equal(long a,long b) &#123; System.out.println(&quot;long&quot;); return a==b; &#125;&#125; 二、数组1.数组概述需求：现在需要统计某公司员工的工资情况，例如计算平均工资、找到最高工资等等。假设该公司有80名员工，用前面所学的知识，程序需要先声明80个变量来分别记住每个员工的工资，然后在进行操作，这样做会显得很麻烦。为了解决这种问题，Java就提供了数组供我们使用。那么数组到底是什么呢？有什么特点？通过上面的分析，我们可以得到以下结论：（1）数组是存储多个变量（元素）的容器。（2）这多个变量的数据类型要一致。 2.数组概念数组是存储同一数据类型多个元素的集合。也可以看作是一个容器。数组既可以存储基本数据类型（byte,short,int,long,float,double,boolean,char），也可以存储引用数据类型。（引用数据类型包括类，接口，数组） 3.数组的定义格式格式1:数据类型[] 数组名;格式2:数据类型 数组名[];注意：这两种定义做完了，数组中是没有元素值的。如何对元素进行初始化呢？ 4.数组初始化（1）数组初始化概述：Java中的数组是变量，必须进行初始化才能使用。所谓初始化，就是为数组中的数组元素分配内存空间，并为每个数组元素赋值。（2）数组的初始化方式：1、动态初始化：初始化时只指定数组长度，由系统为数组分配初始值。动态初始化格式：数据类型[] 数组名 = new 数据类型[数组长度]; //数组长度就是数组中元素的个数。举例：int[] arr = new int[3]; //定义了一个int类型的数组，这个数组可以存放3个int类型的值。123456789101112131415/* * 动态初始化演示 */public class ArrayDemo &#123; public static void main(String[] args) &#123; //定义一个长度为3的int类型数组a变量 int[] arr = new int[3]; System.out.println(arr); //输出的是地址值, //如果要输出其中的元素，需要配合数组名和编号，格式为arr[0] //通用格式：数组名[元素编号] //元素编号从0开始,最后一个元素编号为数组长度-1。这个编号的专业叫法：索引 System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); &#125;&#125; 总结：如何获取数组中的元素？通过：数组名[索引]，索引就是每个元素的编号，从0开始，最大索引编号为数组长度-1； 5.Java中的内存分配Java程序在运行时，需要在内存中分配空间。为了提高运算效率，就对空间进行不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。分为：栈 存储局部变量堆 存储new出来的东西方法区（面向对象部分详细讲解）本地方法区（和系统有关）寄存器（给cpu使用）局部变量：在方法定义中或者方法声明上的变量都成为局部变量。堆内存的特点：a、每一个new出来的东西都有地址值。b、每个变量都有默认值byte,short,int,long 0float,double 0.0char ‘\u0000’boolean false引用类型c、使用完毕就变成了垃圾，但是并没有立即回收。会在垃圾回收器空闲的时候回收。练习：1.定义一个数组，输出该数组的名称和数组元素值给数组元素赋值，再次输出该数组的名称和数组元素值。2.定义两个数组，输出两个数组的名称和数组元素值然后给每个数组的元素重新赋值，再次分别输出两个数组各自的数组名及元素值。3.定义第一个数组，定义完毕后，给数组元素赋值，赋值完毕后，再输出数组名和元素。定义第二个数组，定义完毕后，给数组元素赋值，赋值完毕后，再输出数组名和元素。定义第三个数组，把第一个数组的地址值赋值给它。（注意类型一致），通过第三个数组的名称去把元素重复赋值。最后，再次输出第一个数组的名称和元素。1234567891011121314151617181920212223242526272829303132333435363738394041public class ArrayDemo4 &#123; public static void main(String[] args) &#123; //定义第一个数组并赋值 int[] arr = new int[3]; arr[0] = 88; arr[1] = 33; arr[2] = 66; System.out.println(arr); System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); System.out.println(&quot;---------&quot;); int[] arr2 = new int[3]; arr2[0] = 22; arr2[1] = 44; arr2[2] = 55; System.out.println(arr2); System.out.println(arr2[0]); System.out.println(arr2[1]); System.out.println(arr2[2]); System.out.println(&quot;------------&quot;); //定义第三个数组并赋值 int[] arr3 = arr; arr3[0] = 100; arr3[1] = 200; System.out.println(arr); System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); System.out.println(arr3); System.out.println(arr3[0]); System.out.println(arr3[1]); System.out.println(arr3[2]); &#125;&#125; 2、静态初始化：初始化时指定每个数组元素的初始值，由系统决定数组长度。格式：数据类型[] 数组名 = new 数据类型[] {元素1,元素2,…};简化版格式：数据类型[] 数组名 = {元素1,元素2,…}举例：int[] arr = new int[] {1,2,3};简化格式：int[] arr = {1,2,3};注意事项：不要同时动态和静态进行初始化。12arr = null;System.out.println(arr[0]); 报错：NullPointerException:空指针异常原因：数组已经不在指向堆内存，而你还用数组名去访问元素。 数组练习1.数组遍历(依次输出数组中的每一个元素)自己的做法123456789public class ArrayTest &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,3,4,5&#125;; System.out.println(arr); for(int x=0;x&lt;arr.length;x++) &#123; System.out.println(arr[x]); &#125; &#125;&#125; 视频做法：123456789101112131415161718192021222324public class ArrayTest &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,3,4,5&#125;; printArray(arr); &#125; //方法改进 /* * 两个明确： * 返回值类型：void * 参数列表：int[] arr */ public static void printArray(int[] arr) &#123; System.out.print(&quot;[&quot;); for(int x=0;x&lt;arr.length;x++) &#123; if(x == arr.length-1) &#123; System.out.println(arr[x]+&quot;]&quot;); &#125;else &#123; System.out.print(arr[x]+&quot;,&quot;); &#125; &#125; &#125;&#125; 2.数组获取最值（获取数组中的最大值最小值）自己的做法123456789101112public class ArrayTest2 &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,3,4,5&#125;; int max = arr[0]; for(int x=0;x&lt;arr.length;x++) &#123; if(max&lt;arr[x]) &#123; max = arr[x]; &#125; &#125; System.out.println(&quot;max:&quot;+max); &#125;&#125; 视频做法：1234567891011121314151617181920212223public class ArrayTest2 &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,3,4,5&#125;; int max = getMax(arr); System.out.println(&quot;max:&quot;+max); &#125; /* * 方法改进 * 两个明确： * 返回值类型：int * 参数列表：int[] arr */ public static int getMax(int[] arr) &#123; int max = arr[0]; for(int x=0;x&lt;arr.length;x++) &#123; if(max&lt;arr[x]) &#123; max = arr[x]; &#125; &#125; return max; &#125;&#125; 3.数组元素逆序（就是把元素对调）自己的做法12345678910111213public class ArrayTest3 &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,3,4,5&#125;; for(int x=0;x&lt;arr.length/2;x++) &#123; arr[x] = (arr[x]+arr[arr.length-1-x])-(arr[arr.length-1-x]=arr[x]); &#125; System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); System.out.println(arr[3]); System.out.println(arr[4]); &#125;&#125; 视频做法1234567891011121314151617181920212223242526272829303132public class ArrayTest3 &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,3,4,5&#125;; reverse(arr); printArray(arr); &#125; /* * 方法改进 * 两个明确： * 返回值类型：void //有人会想到应该返回逆序后的数组，但是没必要，因为这两个数组是同一个数组，引用类型和基本数据类型不一样，调用方法后变量的结果已经产生了变化。 * 参数列表：int[] arr * */ public static void reverse(int[] arr) &#123; for(int x=0;x&lt;arr.length/2;x++) &#123; arr[x] = (arr[x]+arr[arr.length-1-x])-(arr[arr.length-1-x]=arr[x]); &#125; &#125; public static void printArray(int[] arr) &#123; System.out.print(&quot;[&quot;); for(int x=0;x&lt;arr.length;x++) &#123; if(x == arr.length-1) &#123; System.out.println(arr[x]+&quot;]&quot;); &#125;else &#123; System.out.print(arr[x]+&quot;,&quot;); &#125; &#125; &#125;&#125; 视频做法21234567891011121314151617181920212223242526272829303132333435public class ArrayTest3 &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,3,4,5&#125;; printArray(arr); reverse(arr); printArray(arr); &#125; /* * 方法改进 * 两个明确： * 返回值类型：void //有人会想到应该返回逆序后的数组，但是没必要，因为这两个数组是同一个数组，引用类型和基本数据类型不一样，调用方法后变量的结果已经产生了变化。 * 参数列表：int[] arr * */ public static void reverse(int[] arr) &#123; for(int start=0,end=arr.length-1;start&lt;=end;start++,end--) &#123; int temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; &#125; &#125; public static void printArray(int[] arr) &#123; System.out.print(&quot;[&quot;); for(int x=0;x&lt;arr.length;x++) &#123; if(x == arr.length-1) &#123; System.out.println(arr[x]+&quot;]&quot;); &#125;else &#123; System.out.print(arr[x]+&quot;,&quot;); &#125; &#125; &#125;&#125; 4.数组查表法（根据键盘录入索引，查找对应星期）意思是：String[] strArray = {“星期一”,”星期二”,…}自己的做法123456789101112131415161718192021222324import java.util.Scanner;public class ArrayTest4 &#123; public static void main(String[] args) &#123; String[] strArray = &#123;&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;,&quot;星期日&quot;&#125;; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入星期对应的索引(1-7)：&quot;); int index = sc.nextInt(); String str = getWeek(index,strArray); System.out.println(&quot;您输入的索引对应的星期是：&quot;+str); &#125; /* * 方法： * 两个明确： * 返回值类型：String * 参数列表：int index,String[] strArray */ public static String getWeek(int index,String[] strArray) &#123; return strArray[index-1]; &#125;&#125; 视频做法12345678910111213import java.util.Scanner;public class ArrayTest4 &#123; public static void main(String[] args) &#123; String[] strArray = &#123;&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;,&quot;星期日&quot;&#125;; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入星期对应的索引(0-6)：&quot;); int index = sc.nextInt(); System.out.println(&quot;你要查找的日期是:&quot;+strArray[index]); &#125; &#125; 5.数组元素查找（查找指定元素第一次在数组中出现的索引）自己的做法12345678910111213141516import java.util.Scanner;public class ArrayTest5 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入要查找的元素（1-5）：&quot;); int num = sc.nextInt(); int[] arr = &#123;5,4,3,2,1,1,3,5,2,4&#125;; for(int x=0;x&lt;arr.length;x++) &#123; if(num == arr[x]) &#123; System.out.println(num+&quot;元素在数组中第一次出现的索引是&quot;+x); break; &#125; &#125; &#125;&#125; 终极版(注意方法的返回值问题！！！)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.Scanner;public class ArrayTest5 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入要查找的元素（1-5）：&quot;); int num = sc.nextInt(); int[] arr = &#123;5,4,3,2,1,1,3,5,2,4&#125;; int result = getIndex(num,arr); if(result&gt;0 &amp;&amp; result&lt;6) &#123; System.out.println(&quot;你输入的数据在数组中出现的第一次索引是：&quot;+result); &#125;else &#123; System.out.println(&quot;你输入的数据在数组中并不存在&quot;); &#125; &#125; /* * 方法 * 两个明确： * 返回值类型：int * 参数列表：int num,int[] arr */ public static int getIndex(int num,int[] arr) &#123; for(int x=0;x&lt;arr.length;x++) &#123; if(num == arr[x]) &#123; return x; &#125; &#125; return -1; &#125; //目前的代码有一个小问题 //就是假如我要查找的数据在数组中不存在，那就找不到，找不到的话，你有对应的返回吗？ //所以报错。 //只要是判断，就可能是false，所以大家要细心。 //如果找不到数据，我们一般返回一个负数即可，而且习惯是返回-1； //getIndex方法改进 /* * public static int getIndex(int num,int[] arr) &#123; int index = -1; for(int x=0;x&lt;arr.length;x++) &#123; if(num == arr[x]) &#123; index = x; &#125; &#125; return index; &#125; */&#125; 6.数组排序和二分查找（后面在数组高级部分讲解）]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday04]]></title>
    <url>%2F2019%2F07%2F08%2Fjavaday04%2F</url>
    <content type="text"><![CDATA[一、switch语句1.switch语句格式：123456789101112switch(表达式) &#123; //表达式的取值可以是byte,short,int,char。jdk5之后可以是枚举,jdk7之后可以是String。 case 值1: 语句体1； break; case 值2: 语句体2； break; ... default: 语句体n+1; break; //这个break可以省略&#125; 面试题：1.byte可以作为switch的表达式吗？可以。long可以作为switch的表达式吗？不可以。String可以作为switch的表达式吗？jdk7以后可以。 练习题：1.键盘录入一个数据，根据这个数据，输出对应的星期。 如果选择结构是与几个固定的值比较，建议使用switch。 switch语句的注意事项：1.case后面只能是常量，且不能重复2.default可以省略，但是不建议省略。除非是类似单选题这种情况。3.break可以省略，但是省略可能与预期的结果不一样，建议不省略。（注意！switch语句执行过程中并不是按顺序与case值逐一比较，而是寻找与表达式相同的值，然后从该值的位置开始执行语句。如果该值后续的语句体没有break，可能会继续执行下一个case的语句体，直到出现break为止。配合如下案例进行理解。上述现象也叫做case穿透）案例：1234567891011121314int x = 2;switch(x) &#123; case 1: System.out.println(1); break; case 2: System.out.println(2); case 3: System.out.println(3); break; default: System.out.println(&quot;输入有误&quot;)&#125; 输出结果为：1223 因为case 2后面的语句体并没有break，所以会继续执行case 3的语句，case 3有break，所以停止。4.default可以在任意位置，但一般放最后。5.switch语句执行时，遇到break或运行至最后才结束。 switch语句练习：1.看程序写结果123456789101112int x = 2;int y = 3;switch(x) &#123; default: y++; break; case 3: y++; case 4: y++;&#125;System.out.println(&quot;y=&quot;+y); 结果：y=41234567891011int a = 2;int b = 3;switch(a) &#123; default: b++; case 3: b++; case 4: b++;&#125;System.out.println(&quot;b=&quot;+b); 结果：b=62.模拟做单项选择题，根据你的选择，给出对应的答案。（表达式是字符的情况）123456789101112131415161718192021222324252627282930313233343536import java.util.Scanner;public class SwitchTest2 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;下面的几个人你最爱谁？&quot;); System.out.println(&quot;65 林青霞&quot;); System.out.println(&quot;66 张曼玉&quot;); System.out.println(&quot;67 刘德华&quot;); System.out.println(&quot;68 王力宏&quot;); System.out.println(&quot;请输入你的选择:&quot;); int choiceNumber = sc.nextInt(); //强制转换为字符类型 char choice = (char) (choiceNumber); switch(choice) &#123; case &apos;A&apos;: System.out.println(&quot;恭喜你，答对了&quot;); break; case &apos;B&apos;: System.out.println(&quot;很遗憾，你答错了&quot;); break; case &apos;C&apos;: System.out.println(&quot;很遗憾，你答错了&quot;); break; case &apos;D&apos;: System.out.println(&quot;很遗憾，你答错了&quot;); break; default: System.out.println(&quot;你输入的不是有效数字&quot;); break; &#125; &#125;&#125; 3.键盘录入字符串，根据给定的字符串，来输出你选择的字符串是什么？（表达式是字符串的情况）1234567891011121314151617181920212223242526import java.util.Scanner;public class SwitchTest3 &#123; public static void main(String[] args) &#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); //录入数据 System.out.println(&quot;请输入字符串：&quot;); String s = sc.nextLine(); switch(s) &#123; case &quot;hello&quot;: System.out.println(&quot;你输入的是hello&quot;); break; case &quot;world&quot;: System.out.println(&quot;你输入的是world&quot;); break; case &quot;java&quot;: System.out.println(&quot;你输入的是java&quot;); break; default: System.out.println(&quot;没有找到你输入的数据&quot;); break; &#125; &#125;&#125; 4.用switch语句实现键盘录入月份，输出对应的季节。12345678910111213141516171819202122232425262728293031323334353637import java.util.Scanner;public class SwitchTest4 &#123; public static void main(String[] args) &#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); //录入数据 System.out.println(&quot;请输入数据（1-12）:&quot;); int month = sc.nextInt(); switch(month) &#123; case 1: case 2: case 12: System.out.println(&quot;冬季&quot;); break; case 3: case 4: case 5: System.out.println(&quot;春季&quot;); break; case 6: case 7: case 8: System.out.println(&quot;夏季&quot;); break; case 9: case 10: case 11: System.out.println(&quot;秋季&quot;); break; default: System.out.println(&quot;你输入的数据有误&quot;); break; &#125; &#125;&#125; if语句和switch语句的区别？使用场景：if语句：（1）针对结果是boolean类型的判断（2）针对一个范围的判断。（3）针对几个常量的判断。switch语句：（1）针对几个常量的判断。 二、循环结构for语句1.前提：循环语句的组成：（1）初始化语句（2）判断条件语句（3）循环体语句（4）控制条件语句循环语句的分类：（1）for循环（2）while循环（3）do…while循环 2.for循环语句格式for(初始化语句;判断条件语句;控制条件语句) { 循环体语句;}执行流程：（1）执行初始化语句（2）执行判断条件语句，看其结果是true还是false。如果是true，继续执行；如果是false，循环结束。（3）执行循环体语句（4）执行控制条件语句（5）回到（2）继续。 3.for语句注意事项：（1）如果循环体语句只有一条语句，大括号可省略，建议永远不要省略。（2）有分号没有左大括号，有左大括号就没有分号。 for循环练习：1.请在控制台输出数据1-102.请在控制台输出数据10-13.求出1-10之间数据之和4.求出1-100之间偶数和5.求出1-100之间奇数和6.求5的阶乘7.在控制台输出所有“水仙花数”12345什么叫“水仙花数”？水仙花数是指一个三位数，其各位数字的立方和等于该数本身。举例：153就是一个水仙花数153 = 1*1*1+5*5*5+3*3*3 1234567891011121314自己想的方法：public class ForDemo &#123; public static void main(String[] args) &#123; for(int num=100;num&lt;=999;num++) &#123; int x = num/100; int y = (num-x*100)/10; int z = (num-x*100-y*10); if(num == (x*x*x+y*y*y+z*z*z)) &#123; System.out.println(num+&quot;是一个水仙花数&quot;); &#125; &#125; &#125;&#125; 12345678910111213141516视频中的方法：public class ForDemo &#123; public static void main(String[] args) &#123; int count = 0; for(int num=100;num&lt;=999;num++) &#123; int x = num%10; int y = num/10%10; int z = num/100%10; if(num == (x*x*x+y*y*y+z*z*z)) &#123; System.out.println(num+&quot;是一个水仙花数&quot;); count++; &#125; &#125; System.out.println(&quot;水仙花数一共有&quot;+count+&quot;个&quot;); &#125;&#125; 8.统计“水仙花数”共有多少个？9.请在控制台输出满足如下条件的五位数个位等于万位十位等于千位个位+十位+千位+万位=百位1234567891011121314151617public class ForDemo &#123; public static void main(String[] args) &#123; int count = 0; for(int num=10000;num&lt;=99999;num++) &#123; int ge = num%10; int shi = num/10%10; int bai = num/100%10; int qian = num/1000%10; int wan = num/10000%10; if((ge==wan)&amp;&amp;(shi==qian)&amp;&amp;(ge+shi+qian+wan == bai)) &#123; System.out.println(num+&quot;满足要求&quot;); count++; &#125; &#125; System.out.println(&quot;满足要求的数据一共有&quot;+count+&quot;个&quot;); &#125;&#125; 10.请统计1-1000之间同时满足如下条件的数据有多少个？对3整除余2对5整除余3对7整除余2123456789101112public class ForDemo &#123; public static void main(String[] args) &#123; int count = 0; for(int num=1;num&lt;=1000;num++) &#123; if((num%3 == 2)&amp;&amp;(num%5 == 3)&amp;&amp;(num%7 == 2)) &#123; System.out.println(num+&quot;满足要求&quot;); count++; &#125; &#125; System.out.println(&quot;满足要求的数据一共有&quot;+count+&quot;个&quot;); &#125;&#125; 三、while循环1.while循环语句格式：（1）基本格式：while(判断条件语句) { 循环体语句;}(2)扩展格式:初始化语句;while(判断条件语句) { 循环体语句; 控制条件语句;} 2.练习：把for循环的练习全部用while循环语句写一遍 3.for循环与while循环的区别：（1）控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问了，而while循环结束还可以继续使用，如果你想继续使用，就用while，否则推荐使用for。原因是for循环结束，该变量就从内存消失，能够提高内存的使用效率。（2）for 循环适合针对一个范围判断进行操作。while循环适合判断次数不明确操作。 四、do…while循环1.do…while循环语句格式：（1）基本格式：do { 循环语句体;}while(判断条件语句);(2)扩展格式：初始化语句do { 循环语句体； 控制条件语句；}while(判断条件语句)； 2.do..while比较少用，但效果与前两种循环语句相同。执行流程是先执行一次循环体语句，然后再判断。3.三种循环语句的区别（1）do…while至少执行一次循环体。（2）for，while循环必须先判断条件是否成立，然后决定是否执行循环体语句。案例：1234567891011121314151617public class DoWhileDemo2 &#123; public static void main(String[] args) &#123; for(int x=3;x&lt;3;x++) &#123; System.out.println(&quot;javafor&quot;); &#125; int y = 3; while(y&lt;3) &#123; System.out.println(&quot;javawhile&quot;); &#125; int z = 3; do &#123; System.out.println(&quot;javadowhile&quot;); &#125;while(z&lt;3); &#125;&#125; 4.注意死循环（1）注意控制条件语句控制的那个变量的问题（2）两种最简单的死循环格式： while(true) {…} for(;;) {…} 五、循环嵌套练习题： 请输出一个4行5列的星星(*)图案1234567891011public class ForForDemo &#123; public static void main(String[] args) &#123; for(int x=0;x&lt;4;x++) &#123; for(int y=0;y&lt;5;y++) &#123; System.out.print(&quot; *&quot;); &#125; System.out.println(); &#125; &#125;&#125; 2.输出如下图形*** 自己的想法1234567891011public class ForForDemo &#123; public static void main(String[] args) &#123; for(int x=0;x&lt;5;x++) &#123; for(int y=0;y&lt;x+1;y++) &#123; System.out.print(&quot; *&quot;); &#125; System.out.println(); &#125; &#125;&#125; 视频做法1234567891011public class ForForDemo &#123; public static void main(String[] args) &#123; for(int x=0;x&lt;5;x++) &#123; for(int y=0;y&lt;=x;y++) &#123; System.out.print(&quot; *&quot;); &#125; System.out.println(); &#125; &#125;&#125; 3.在控制台输出九九乘法表自己的想法1234567891011public class ForForDemo &#123; public static void main(String[] args) &#123; for(int x=0;x&lt;9;x++) &#123; for(int y=0;y&lt;x+1;y++) &#123; System.out.print(&quot; &quot;+(x+1)+&quot;*&quot;+(y+1)+&quot;=&quot;+((x+1)*(y+1))); &#125; System.out.println(); &#125; &#125;&#125; 视频做法1234567891011public class ForForDemo &#123; public static void main(String[] args) &#123; for(int x=1;x&lt;=9;x++) &#123; for(int y=1;y&lt;=x;y++) &#123; System.out.print(x+&quot;*&quot;+y+&quot;=&quot;+x*y+&quot;\t&quot;); &#125; System.out.println(); &#125; &#125;&#125; 注意：‘\x’ x表示任意，这种做法叫转义字符‘\t’ tab键‘\r’ 回车‘\n’ 换行在输出语句中使用单引号，双引号都可以。 六、跳转控制语句1.前言：Java中的goto是保留字，目前不能使用。虽然没有goto语句可以增强程序的安全性，但是也带来很多不便，比如说，我想在某个循环知道到某一步的时候就结束，现在就做不了这个事情。为了弥补这个缺陷，Java就提供了break,continue和return来实现控制语句的跳转和中断。break 中断continue 继续return 返回 2.跳转控制语句break(1)break的使用场景 在选择结构switch语句中 在循环语句中 离开使用场景的存在是没有意义的(2)如何使用a.跳出单层循环1234567891011public class BreakDemo &#123; public static void main(String[] args) &#123; //跳出单层循环 for(int x=0;x&lt;10;x++) &#123; if(x == 3) &#123; break; &#125; System.out.println(&quot;hello world&quot;); &#125; &#125;&#125; b.跳出多层循环要想实现这个效果，就必须知道一个东西，带标签的语句。格式： 标签名:语句 1234567891011121314public class BreakDemo &#123; public static void main(String[] args) &#123; //跳出多层循环 wc:for(int x=0;x&lt;3;x++) &#123; nc:for(int y=0;y&lt;4;y++) &#123; if(y == 2) &#123; break wc; &#125; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; &#125;&#125; 3.跳转控制语句continue（1）使用场景a.在循环语句中b.离开使用场景的存在是没有意义的（2）continue的作用a.单层循环对比break，两个的区别是：break 退出当前循环continue 退出本次循环 练习：123456for(int x=1;x&lt;=10;x++) &#123; if(x%3==0) &#123; //此处填写代码 &#125; System.out.println(&quot;Java基础班&quot;);&#125; 我想在控制台输出2次：“Java基础班”1break; 我想在控制台输出7次：“Java基础班”1continue; 我想在控制台输出13次：“Java基础班”1System.out.println(&quot;Java基础班&quot;); 也可以带标签的使用：1234567891011121314public class BreakDemo &#123; public static void main(String[] args) &#123; //跳出多层循环 wc:for(int x=0;x&lt;3;x++) &#123; nc:for(int y=0;y&lt;4;y++) &#123; if(y == 2) &#123; continue wc; &#125; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; &#125;&#125; 结果：**分析：1continue表示退出本次循环，所以continue wc;表示的是退出wc的本次（x=0）的循环，并不是退出整个wc的循环，接下来会进行下次(x=1)循环，所以结果为**（x=0）**(x=1)**(x=2) 4.跳转控制语句return return的功能就是结束一个方法，跳转到上一层的方法中，这个在方法的使用中会详细讲解。案例:123456789101112131415public class BreakDemo &#123; public static void main(String[] args) &#123; for(int x=0;x&lt;10;x++) &#123; if(x == 2) &#123; System.out.println(&quot;退出&quot;); 填写代码处 //break; //continue; //return; &#125; System.out.println(x); &#125; System.out.println(&quot;over&quot;); &#125;&#125; 填写break：123401退出over 填写continue:123456789101101退出3456789over 填写return:12301退出 练习：小芳的妈妈每天给她2.5元，她都会存起来，但是，每当这一天是存钱的第5天或者是5的倍数的话，她都会花去6元，请问经过多少天，小芳才能存够100元？无break；做法12345678910111213141516public class WhileBreakTest &#123; public static void main(String[] args) &#123; int day = 0; double sum = 0; while(sum&lt;100.0) &#123; day++; sum+=2.5; if(day%5 == 0) &#123; System.out.println(&quot;小芳在第&quot;+day+&quot;天花了6元&quot;); sum-=6; &#125; System.out.println(&quot;经过&quot;+day+&quot;天，存有&quot;+sum+&quot;元&quot;); &#125; System.out.println(&quot;经过&quot;+day+&quot;天，小芳能存够100元&quot;); &#125;&#125; 使用break;做法12345678910111213141516171819public class WhileBreakTest &#123; public static void main(String[] args) &#123; int day = 0; double sum = 0; while(true) &#123; day++; sum+=2.5; if(day%5 == 0) &#123; System.out.println(&quot;小芳在第&quot;+day+&quot;天花了6元&quot;); sum-=6; &#125; System.out.println(&quot;经过&quot;+day+&quot;天，存有&quot;+sum+&quot;元&quot;); if(sum&gt;=100) &#123; break; &#125; &#125; System.out.println(&quot;经过&quot;+day+&quot;天，小芳能存够100元&quot;); &#125;&#125;]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday03]]></title>
    <url>%2F2019%2F07%2F06%2Fjavaday03%2F</url>
    <content type="text"><![CDATA[一、运算符1.运算符就是对常量和变量进行操作的符号。2.分类（1）算术运算符+、-、*、/、%、++、–(自增和自减只能用于变量)++、–单独使用时，放在操作数的前面和后面效果一样。（常见用法）参与运算使用，放在操作数前面，先自增或自减，再参与运算；放在操作数后面，先参与运算，再自增或自减。 ++、–的练习题第一题：int a = 10；int b = 10;int c = 10; a = b++;c = --a;b = ++a;a = c--;请分别计算出a,b,c的值。1234a = b++; //a=10 b=11 c=10c = --a; //a=9 b=11 c=9b = ++a; //a=10 b=10 c=9a = c--; //a=9 b=10 c=8 第二题：int x = 4；int y = (x++)+(++x)+(x*10);请分别计算出x,y的值12345(x++) //x=5 (x++)=4(++x) //x=6 (++x)=6(x*10) //x=6 (x*10)=60y=4+6+60=70所以x=6,y=70 （2）赋值运算符=、+=、-=、*=、/=、%= += 把左边和右边做加法，然后赋值给左边。*=/=%= 面试题：short s = 1, s = s+1;short s = 1, s+=1;上面两个代码有没有问题，如果有，哪里有问题？12345short s = 1,s = s+1;有问题s是short类型，进行计算时先转为int类型后参与计算，所以+1后结果是int类型，赋值给short类型的s可能损失精度。short s = 1,s+=1;没问题因为扩展的赋值运算符隐含了一个强制类型转换。s+=1;等价于s = (s的数据类型)（s+1）; （3）比较运算符(关系运算符)==、！=、&gt;、&gt;=、&lt;、&lt;= （4）逻辑运算符&amp;、|、^、!、&amp;&amp;、||特点：逻辑运算符一般用于连接boolean类型的表达式或值.结论：&amp;：有false则false|：有true则true^：相同为false，不同为true!：非false则true，非true则false。偶数个!不改变结果（!!true=true）&amp;&amp;：结果与&amp;相同。不同在于&amp;&amp;左边是false的话，右边不执行。看以下案例。123456789101112int x = 3;int y = 4;boolean b1 = (++x == 3 &amp; y++ == 4);System.out.println(&quot;x:&quot;+x+&quot;y:&quot;+y);System.out.println(b1);int x = 3;int x = 4;boolean b2 = (++x == 3 &amp;&amp; y++ == 4);System.out.println(&quot;x:&quot;+x+&quot;y:&quot;+y);System.out.println(b1); ||：结果与|相同。不同在于||左边是true的话，右边不执行。（5）位运算符注意：要做位运算，首先要把数据转换为二进制，并且是补码。&amp;、|、^、~（两边是boolean类型，做逻辑运算；两边是数据时，做位运算。3 &amp; 4做位运算）案例：System.out.println(3 &amp; 4);System.out.println(3 | 4);System.out.println(3 ^ 4);System.out.println(~3);123456789101112131415161718192021222324252627282930分析过程：3的二进制：11常量3的存储结构：00000000 00000000 00000000 000000114的二进制：100常量4的存储结构：00000000 00000000 00000000 00000100&amp;位运算：有0则000000000 00000000 00000000 00000011&amp;00000000 00000000 00000000 00000100-----------------------------------00000000 00000000 00000000 00000000结果：0|位运算：有1则100000000 00000000 00000000 00000011|00000000 00000000 00000000 00000100-----------------------------------00000000 00000000 00000000 00000111结果：7^位运算：相同则0.不同则100000000 00000000 00000000 00000011^00000000 00000000 00000000 00000100-----------------------------------00000000 00000000 00000000 00000111结果：7~运算符：0变1，1变0~00000000 00000000 00000000 00000011-----------------------------------11111111 11111111 11111111 11111100(补)11111111 11111111 11111111 11111011(反)10000000 00000000 00000000 00000100(原)结果：-4 一个数据位异或(^)两次，该数本身不变。 面试题：1.请自己实现两个整数变量的交换。1234567891011121314151617181920212223int a = 10;int b = 20;System.out.prinyln(&quot;a:&quot;+a+&quot;,b:&quot;+b);//方式1:使用第三方变量（开发中用的）int c = a;a = b;b = c;System.out.prinyln(&quot;a:&quot;+a+&quot;,b:&quot;+b);//方式2:用位异或实现//左边：a,b,a//右边：a ^ ba = a ^ b;b = a ^ b;a = a ^ b;System.out.prinyln(&quot;a:&quot;+a+&quot;,b:&quot;+b);//方式3:用变量相加的方法a = a + b;b = a - b;a = a - b;System.out.prinyln(&quot;a:&quot;+a+&quot;,b:&quot;+b);//方式4:一句话搞定b = (a+b)-(a=b);System.out.prinyln(&quot;a:&quot;+a+&quot;,b:&quot;+b); &lt;&lt;(左移)、&gt;&gt;(右移)、&gt;&gt;&gt;(无符号右移)&lt;&lt;：左边最高位丢弃，右边补齐0. 把&lt;&lt;左边的数据*2的移动次幂 ：最高位是0，左边补0；最高位是1，左边补齐1 ：无论最高位是0或1，左边都是补齐0案例：System.out.println(3 &lt;&lt; 2);1234计算3的二进制：1100000000 00000000 00000000 00000011&lt;&lt;00000000 00000000 00000000 00001100结果：12 System.out.prinyln(24 &gt;&gt; 2); //6System.out.prinyln(24 &gt;&gt;&gt; 2); //6System.out.prinyln(-24 &gt;&gt; 2); //-6System.out.prinyln(-24 &gt;&gt;&gt; 2); //1073741818123456计算-24的二进制：1100010000000 00000000 00000000 00011000（原）11111111 11111111 11111111 11100111（反）11111111 11111111 11111111 11101000（补）&gt;&gt;&gt;00111111 11111111 11111111 11111010 (原、反、补)结果：1073741818 面试题：请用最有效率的方式写出计算2乘8的结果？12 &lt;&lt; 3 //2*2^3=16 （6）三目运算符(条件运算符)格式：表达式？表达式1:表达式2;举例：int x = 100;int y = 200;int z = x &lt; y?x:y;System.out.println(“z:”+z);练习：1.获取两个整数中的最大值。1234int x = 100;int y = 200;int max = (x&gt;y? x:y);System.out.println(&quot;max:&quot;+max); 2.获取三个整数中的最大值.12345int a = 10;int b = 30;int c = 20;int max = (a&gt;b?a:b)&gt;c?(a&gt;b?a:b):c;System.out.println(&quot;max:&quot;+max); 3.比较两个整数是否相同1234int m = 100;int n = 200;boolean flag = (m==n)?true:flase;System.out.println(boolean); 二、键盘录入1.如何实现键盘录入？（1）导包格式：import java.util.Scanner;位置：在class上面（2）创建键盘录入对象格式：Scanner sc = new Scanner(System.in);（3）通过对象获取数据格式：int x =sc.nextInt(); 练习：1.键盘录入两个数据，并对这两个数据求和，输出其结果。2.键盘录入两个数据，获取这两个数据的最大值。3.键盘录入三个数据，获取这三个数据的最大值。4.键盘录入两个数据，比较这两个数据是否相等。 三、if语句1.前言：在一个程序执行的过程中，各条语句的执行顺序对程序的结果有直接影响。所以，我们必须清楚每条语句的执行流程。而且，很多时候我们要通过控制语句的执行顺序来实现我们要完成的功能。流程控制语句分类：顺序结构，选择结构，循环结构。java语言提供了两种选择结构语句：if语句和switch语句if 语句有三种格式：if 语句的第一种格式：if（关系表达式）{语句体；}if语句的第二种格式：if(关系表达式) {语句体1；} else {语句体2；}格式2练习：1.获取两个数据中较大的值2.判断一个数是奇数还是偶数if语句第二种格式和三元运算符的区别？(根据案例解释)三元运算符实现的，都可以采用if语句实现。反之不成立。结果是输出语句无法用三元运算符实现。123456789101112131415//获取两个数据中的较大值int a = 10;int b = 20;//if语句实现int max1;if(a&gt;b) &#123;max1 = a;&#125;else &#123;max1 = b;&#125;System.out.println(&quot;max1:&quot;+max1);//三目运算符实现int max2 = (a&gt;b)?a:b;System.out.println(&quot;max2:&quot;+max2); 12345678910//判断一个数据是奇数还是偶数，并输出是奇数还是偶数int x = 100;//if语句实现if(x%2 == 0) &#123;System.out.println(&quot;100是一个偶数&quot;)&#125;else &#123;System.out.println(&quot;100是一个奇数&quot;)&#125;//三目运算符实现实现不了 if语句的第三种格式：if(关系表达式1) {语句体1；}else if(关系表达式2) {语句体2；}…else {语句体n+1;}案例：键盘录入一个成绩，判断并输出成绩的等级。（注意考虑正常数据，错误数据，边界数据。比如分数有0，100，但是没有-100） if语句练习：1.键盘录入x的值，计算出y的值并输出，y满足：x&gt;=3 y=2x+1;x-1 y=2x;x&lt;=-1 y=2x-1;2.键盘录入月份的值，输出对应的季节。3.获取三个数据中的最大值（讲解if语句的嵌套）]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaday02]]></title>
    <url>%2F2019%2F07%2F05%2Fjavaday02%2F</url>
    <content type="text"><![CDATA[一、关键字1.被java语言赋于特殊含义的单词。 二、标识符1.给类、接口、方法、变量起名字的字符序列。2.组成规则：（1）数字（2）英文大小写字母（3）$和_ 3.注意事项：（1）不能以数字开头（2）区分大小写（3）不能是关键字 4.常见的命名规则（1）包：单级包：小写 //cn多级包：小写，使用点连接 //cn.itcast（2）类和接口：1个单词：首字母大写 //Student多个单词：每个单词的首字母大写 //StudentClass（3）方法和变量1个单词：小写 //main多个单词：从第2个单词开始，首字母大写 //getNumber（4）常量：1个单词：全部大写 //PI多个单词：大写，用下划线_隔开 //FIRE_TEACHER 三、注释1.对程序进行解释说明的文字2.分类：（1）单行注释//（2）多行注释/ \/（3）文档注释/* \/ 四、常量1.在程序执行过程中其值不发生改变的量。2.分类：（1）字面值常量（2）自定义常量 3.字面值常量（1）整数常量 12（2）小数常量 12.34（3）字符串常量 “hello”（3）字符常量 ‘a’（5）布尔常量 true,flase（6）空常量null 4.java中针对整数常量提供了四种表现形式：二进制、八进制、十进制、十六进制。（整数默认十进制）五、进制转换1.其他进制到十进制系数：就是每一位上的数值基数：X进制的基数就是X。权：对每一位上的数据进行编号，从右，并且从0开始编号，对应的编号就是该数据的权。结果：系数*基数^权次幂之和。 2.十进制到其他进制除基取余，直到商为零，余数反转。 3.进制转换的快速转换法（1）十进制与二进制之间的转换8421码（2）二进制到八进制、十六进制的转换 4.小数部分二进制与十进制转换（1）十进制转二进制小数部分乘2，取结果的整数部分，之后将结果的小数部分乘2，取结果的的整数部分，以此类推，直到结果为0或一直循环为止。（2）二进制转十进制小数部分从左往右，依次乘1/2，1/4，1/8…，求和。 六、变量1.在程序的执行过程中，其值在某个范围内可以发生改变的量。2.变量的定义格式：（1）变量的定义格式：A：数据类型 变量名 = 初始化值；B：数据类型 变量名；变量名 = 初始化值； 七、数据类型1.java是一种强类型语言，针对每种数据都提供了对应的数据类型。2.分类：（1）基本数据类型：4类8种（2）引用数据类型：类，接口，数组 3.基本数据类型：（1）整数 占用字节数byte 1short 2int 4long 8（2）浮点数float 4double 8（3）布尔char 1（4）字符boolean 2注意： 整数默认int类型，浮点数默认double类型。 长整数要加l或L，单精度的浮点数要加F或f。 八、数据类型转换1.默认转换从小到大byte，short，char-int-long-float-doublebyte，short，char之间不相互转换，直接转成int类型参与计算。 2.强制转换从大到小可能会有精度损失，一般不建议这样使用。格式：目标数据类型 变量名 = （目标数据类型）（被转换的数据）； 3.布尔类型不参与转换4.思考题和面试题（1）下面两种方式有区别吗？float f1 = 12.345f；float f2 = （float）12.345；//f1是通过double转换过来的，f2本身就是float类型。（2）面试题：1.byte b1=3,b2=4,b;b=b1+b2;b=3+4;哪句是编译失败的呢？为什么呢？12345b=b1+b2编译失败。b1是byte类型，b2是byte类型。两个byte类型相加，先转换成int类型再相加，所以结果是int类型。b是byte类型，把int类型的结果赋值给byte类型的b，可能损失精度，所以报错。变量计算时，会先考虑数据类型再进行计算。 12b=3+4编译成功。因为3、4是常量，常量计算时，先把结果计算出来，然后看是否是在赋值的数据类型（byte）的范围内，如果在就不报错。 2.byte b = 130;有没有问题？如果我想让赋值正确，可以怎么做？结果是多少呢？12345678910111213有问题，可能损失精度。因为byte的范围是-128～127。130不在此范围内，所以报错。如果想让赋值正确（不报错），可以使用强制转换byte b = (byte) (130);结果是-126分析过程：获取130这个数据的二进制。130是整数常量，整数常量默认为int类型，占用4个字节。00000000 00000000 00000000 10000010这是130的原码，也是反码，还是补码。因为强制转换成byte类型（1个字节），所以对130的补码进行截取操作，从左边开始：补：10000010反：10000001原：11111110此原码对应的数值是-126. 练习：byte b = 300;12345678910111213有问题，可能损失精度。因为byte的范围是-128～127，300不在这个范围内，所以报错。如果想让赋值正确（不报错），可以使用强制转换byte b = （byte）(300);结果是分析过程：获取300的二进制。整数常量默认为int类型，占用4个字节。00000000 00000000 00000001 00101100这是300的原码，反码，补码因为强制转换成byte类型（1个字节），所以进行截取操作，从左边开始：补：00101100反：00101100原：00101100此原码对应的数值是44。正数的原反补都相同！！！！ 3.看程序写结果：System.out.println(‘a’);1a System.out.println(‘a’+1);123498&apos;a&apos; 97&apos;A&apos; 65&apos;0&apos; 48 System.out.println(“hello”+’a’+1);12helloa1字符串数据和其他数据做+，结果是字符串类型。 System.out.println(‘a’+1+”hello”);198hello System.out.println(“5+5=”+5+5);15+5=55 System.out.println(5+5+”=5+5”);110=5+5 4.17.625在float类型中是如何存储的？写出过程。（1）整数部分转为二进制（2）小数部分转为二进制（3）移动小数点找到底数和指数，指数加上127底数：因为小数点前必为1，所以IEEE规定只记录小数点后的就好，所以，此时的底数为0001101.指数：实际为4，必须加上127，所以为131，也就是10000011.（4）在float4个字节中的存储顺序为：符号部分+指数部分+底数部分+后面补0结果：01000001 10001101 00000000 000000005.Java语言中的字符char可以存储一个中文汉字吗？为什么？可以。因为Java语言中的字符占用两个字节。 PS：Java语言采用的是Unicode编码。]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年6月考核]]></title>
    <url>%2F2019%2F05%2F28%2F2019%E5%B9%B46%E6%9C%88%E8%80%83%E6%A0%B8%2F</url>
    <content type="text"><![CDATA[第一周（0527-0602）0527 周一 科研 工作 回顾统计学基础； 环境 实验室拍照；贫困认定； 其它 每日饮食完成； 状态 正常饮食，不聚餐第1天；一次只养成一个习惯，现在先养成正常饮食不聚餐的习惯； 0528 周二 科研 简单看了两篇论文； 工作 回顾了一点点统计学基础； 环境 贫困认定完成；宿舍分配完成；值班安排大部分搞定，明天小修改一下； 其它 每日饮食完成50%，晚上学工组加班，饮食不太妥当，但是没有腐败聚会，所以还好； 状态 感觉自己确实不聪明，复习一点点统计学基础就花了一下午，所以还是要踏踏实实多花时间去学习； 0529 周三 科研 看论文&lt;1； 工作 环境 端午节值班表； 其它 无效率休息半天；校篮球赛工程vs机电，机电7号和0号不错，虽然最后还是工程赢了； 状态 效率低。 0530 周四 科研 组会； 工作 环境 三全育人研讨会；第十三次学工组例会记录； 其它 状态 今天比较充实，但全是环境的事情。还是要抓紧时间做自己的事，加油； 0531 周五 科研 工作 环境 开会；排版 其它 状态 0601 周六 科研 不到半篇英文文献； 工作 环境 排版 其它 南门烧烤； 状态 0602 周日 科研 开题报告（除现状与技术路线） 工作 环境 就业信息统计； 其它 安装好虚拟机；帮天予也装了虚拟机；ted（我们所做的一切是为了什么）（负面情绪是心智在提醒我们它渴望成熟） 状态 本周总结： 优点：没闲着；逐渐变得理性；看TED； 缺点：科研与工作内容少；作息饮食不规律； 最开心的事：猛龙总决赛第1场赢了； 第二周（0603-0609）0603 周一 科研 技术路线；研究现状； 工作 环境 其它 状态 没什么问题，就是做的事太少，时间浪费太多； 0604 周二 科研 技术路线；研究现状； 工作 环境 值班；通讯稿； 其它 状态 被恋爱冲昏头脑，需要冷静一下； 0605 周三 科研 工作 环境 毕业照；排查；党支部风采大赛；整理照片 其它 状态 不可避免的效率低；尽快把这些事都做好吧； 0606 周四 科研 工作 环境 教职工大会； 其它 和sjx吃饭； 状态 开心 0607 周五 科研 找老师看开题报告； 工作 环境 其它 老友记； 状态 0608 周六 科研 工作 环境 其它 老友记； 状态 0609 周日 科研 工作 环境 其它 王老菊视频； 状态 本周总结： 优点： 缺点： 最开心的事： 第三周（0610-0616）0610 周一 科研 工作 环境 其它 状态 0611 周二 科研 工作 环境 其它 状态 0612 周三 科研 工作 环境 其它 状态 0613 周四 科研 工作 环境 其它 状态 0614 周五 科研 工作 环境 其它 状态 0615 周六 科研 工作 环境 其它 状态 0616 周日 科研 工作 环境 其它 状态 本周总结： 优点： 缺点： 最开心的事： 第四周（0617-0623）0617 周一 科研 工作 环境 其它 状态 0618 周二 科研 工作 环境 其它 状态 0619 周三 科研 工作 环境 其它 状态 0620 周四 科研 工作 环境 其它 状态 0621 周五 科研 开题ppt； 工作 环境 核对金额； 其它 买了泰拉瑞亚； 状态 这两周有点堕落，要开始改正！ 0622 周六 科研 工作 环境 其它 状态 0623 周日 科研 工作 环境 其它 状态 本周总结： 优点： 缺点： 最开心的事： 第五周（0624-0630）0624 周一 科研 工作 环境 其它 状态 0625 周二 科研 工作 环境 其它 状态 0626 周三 科研 工作 环境 其它 状态 0627 周四 科研 工作 环境 其它 状态 0628 周五 科研 工作 环境 其它 状态 0629 周六 科研 工作 环境 其它 状态 0630 周日 科研 工作 环境 其它 状态 本周总结： 优点： 缺点： 最开心的事： 六月总结：]]></content>
      <categories>
        <category>自律即自由</category>
      </categories>
      <tags>
        <tag>2019</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据的统计学基础第5周笔记]]></title>
    <url>%2F2019%2F05%2F11%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%AC%AC5%E5%91%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[0190511:]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>统计学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据的统计学基础第4周笔记]]></title>
    <url>%2F2019%2F05%2F11%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%AC%AC4%E5%91%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[0190511:]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>统计学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据的统计学基础第3周笔记]]></title>
    <url>%2F2019%2F05%2F10%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%AC%AC3%E5%91%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[0190510:]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>统计学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据的统计学基础第2周笔记]]></title>
    <url>%2F2019%2F05%2F10%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%AC%AC2%E5%91%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[20190510:]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>统计学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据的统计学基础第1周笔记]]></title>
    <url>%2F2019%2F05%2F08%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%AC%AC1%E5%91%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[20190508:]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>统计学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git基础教程]]></title>
    <url>%2F2019%2F05%2F05%2FGit%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Git 简易实用教程 for Mac1.git安装git官网下载后傻瓜式安装，安装完毕后打开终端输入“git”，回车，输出一大段介绍并且没有报错，说明安装成功 2.建立第一个版本库Repository打开终端， cd ~/desktop/jetzilch #jetzilch文件夹应当已经存在。 git config -global user.name”jetzilch” #设置用户名 git config -global user.email”**@qq.com” #设置用户email git init #在jetzlich文件夹中生成.git隐藏文件夹，在文件夹中使用“command+shift+.”显示隐藏文件夹 ls -a #在终端中输入此命令显示所在文件夹中的所有文件（包括隐藏文件） touch 1.py #新建1.py文件 git status #显示“untracked files”，此时的1.py文件没有被放入版本库（unstaged） git add 1.py #git add . ##把所有内容放入版本库 git status #显示“changes to be committed”,此时1.py已经放入版本库（staged） git commit -m “create 1.py” #commit表示提交这一次“修改”，提交的是修改而不是文件。 3.记录修改log&amp;diffgit log #显示之前所有commit的修改信息 我们对1.py文件进行修改： ··· a = 1 ··· git status #显示“modified”，此时修改的内容还没有被add和commit git add 1.py git commit -m “change 1” git log 我们对1.py文件进行修改： ··· a = 2 b = 1 ··· git diff #查看修改完后但未add的内容与上次commit后的内容的对比（查看staged） git diff —cached #修改完后add完成与上次commit后的内容的对比（查看unstaged） git diff HEAD #查看staged与unstaged git add . git commit -m “change 2” 4.回到从前reset4.1 修改已commit的版本 刚刚我们已经提交了一个commit（change 2），现在我们要添加另一个文件2.py，讲这个修改也commit进change 2 touch 2.py #这里只是新建了2.py文件，为了下面步骤的进行，需手动把1.py内的内容复制到2.py中，此处不再赘述 git add 2.py git commit —amend —no-edit #”—no-edit”:不编辑，直接合并到上一个commit git log —oneline #”—oneline”:每个commit内容显示在一行 4.2 reset到add之前 对1.py进行修改： ··· d = 3 ··· #add到staged再返回到add之前 git add 1.py git status -s #”-s”:缩写status的显示内容 git rest 1.py git status -s 4.3 reset到commit之前 git reset —hard HEAD #不管我们之前有没有做了一些add工作，这一步都会让我们回到最近的commit，在这个案例里是change 2 git log —oneline #回到change 1（两种方法） #方法1 git reset —hard HEAD^ #方法2 git reset —hard 9881585(change 1的id) git log —oneline #上述方式会导致change 2消失，想要恢复消失的change 2，可以使用reflog git reflog #显示最近HEAD的所有改动 #重复reset步骤就能回到change 2 git reset —hard 3faa921 5.回到从前（checkout针对单个文件）git log —oneline git checkout 9881585 — 1.py #将1.py文件恢复到change 1的状态（9881585为change 1的id） #此时的1.py里只有change 1的内容（a = 1），我们在1.py加上一行内容“# I went back to change 1”，然后add，commit 1.py git add 1.py git commit -m “back to change 1 and add commit for 1.py” git log —oneline 6.分支（branch）6.1 使用branch创建dev分支 git log —oneline —graph #观看分支，即log的最左边会显示*路线 git branch dev #创建dev分支 git branch #查看当前分支，*显示的是当前所在的分支 git checkout dev #切换到dev分支 git branch 创建和切换到新建的分支可以合成一步：git checkout -b dev git branch -d dev #删除dev分支 6.2 将dev的修改推送到master git commit -am “change 3 in dev” #”-am”:add所有改变并直接commit git checkout master #切换到master分支 git merge dev #将dev merge到master git log —oneline —graph 上述merge方式在log中不会有分支图案，可以采取—no-f保留 git merge —no-f -m”keep merge info” dev #保留merge信息 git log —oneline —graph 7.分支冲突merge在不同分支进行编辑，然后mege，系统会提示冲突，并在文件中把冲突的地方标示出来，在文件中修改后，再提交保存就行。 8.分支冲突rebase按照莫烦git里的讲解，有空再补充。 9.临时修改stash有空补充 10.github在线代码管理有空补充]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年5月考核]]></title>
    <url>%2F2019%2F05%2F04%2F2019%E5%B9%B45%E6%9C%88%E8%80%83%E6%A0%B8%2F</url>
    <content type="text"><![CDATA[第一周（0429-0505）0429 周一 科研 读博 环境 其它 和P同学聊到快两点。 状态 0430 周二 科研 读博 环境 其它 状态 0501 周三 科研 读博 环境 其它 状态 0502 周四 科研 读博 环境 其它 状态 0503 周五 科研 读博 环境 其它 状态 0504 周六 科研 修改论文； 读博 图书馆8:00～9:30 环境 其它 晚餐（牛排、西红柿、黄瓜、面包、黄桃罐头）；午睡；和奶奶、妈妈视频； 状态 相对充实的一天，晚上改论文时确实受到影响了，以后尽量去图书馆学习。 0505 周日 科研 看了一点点粗糙度相关论文； 工作 tensorflow的简单示例（梯度下降法训练出一条直线）； 环境 五四100周年学习体会收集；篮球赛； 其它 帮勇哥解决论文发表图的问题；外国人拿一包鸡精找我问哪有“猪精”？有点迷 三餐 地瓜粥、鸡蛋；牛排、西红柿、黄瓜、面包；火腿、西红柿、黄瓜、面包 状态 状态不错（睡眠、饮食做得好），但是事情多，特别是琐事…… 本周总结： 优点：饮食、睡眠调整效果初见成效；图书馆学习时间增加； 缺点：效率低下；注意力与时间分散于太多现阶段无关紧要的部分； 最开心的事：和P同学聊到快两点。 第二周（0506-0512）0506 周一 科研 确定渗流实验变量、实验结果量、中间量；确定JRC值的计算步骤 工作 理解hypothesis function（假设函数h），parameters（模型参数theta），cost function（代价函数），linear regression（线性回归）； 环境 整理中加秘书招聘报名表；篮球赛； 其它 帮Luo看论文；帮勇哥画图； 状态 开心 理解了cost function。 0507 周二 科研 工作 尝试讲解univariate linear regression;学习multivariate linear regression; 环境 例会；会议记录；邀请函； 其它 安装matlab for mac； 状态 在图书馆效率还不错，明天继续保持； 开心 被大家需要； 0508 周三 科研 实验方案撰写； 工作 大数据的统计学基础第1周，整理至Hexo； 环境 中加秘书招聘信息整理进行中； 其它 俭朴菜37；找完简历模版；学会origin合并两图的方法；玩台球游戏被涛子打得头皮发麻； 状态 0509 周四 科研 工作 环境 中加秘书招聘信息整理进行中；五四100周年讲话学习拍摄；篮球赛；学工组聚餐 其它 状态 很充实，忙与开心并存，希望接下来每天也能和今天一样。 开心 今天环境篮球赛赢了，很开心。 0510 周五 科研 裂隙特征实验方案撰写完毕； 工作 大数据的统计学基础第2周，整理至Hexo；大数据的统计学基础第3周，整理至Hexo； 环境 中加秘书信息整理完毕；五四讲话照片整理完毕； 其它 0.5h乒乓球； 状态 今天效率还不错，明天继续努力； 0511 周六 科研 找岩石类期刊； 工作 大数据的统计学基础第4周，整理至Hexo;大数据的统计学第5周进行中；实习生双选会； 环境 其它 和奶奶视频；给妈妈买礼物（妈妈自己挑的礼物，难得） 状态 今天学习状态不错，后程又开始囫囵吞枣，切忌；睡前洗漱习惯接近养成，证明仍具有一定可塑性，要保持自信，争取在其他领域也养成好习惯。 0512 周日 科研 工作 环境 其它 161聚餐； 状态 荒废了一天，并没有得到有效的休息；玩游戏还是会上瘾，不能玩； 开心 161聚餐； 本周总结： 优点：重点回到工作上；洗漱习惯接近养成； 缺点：学习稍有囫囵吞枣之嫌；科研方面仍需加强；玩游戏会上瘾，还是少玩的好。饮食不太健康。 最开心的事：环境篮球赛取得胜利； 第三周（0513-0519）0513 周一 科研 实验方案修改； 工作 理解什么叫随机变量 环境 找北交大附近住处；上传通讯稿；工作小组通知； 其它 涛子生日快乐； 状态 今天发生了件比较影响三观的事，以后还是做个众人，把我想表现的那一面展现在行动上。 0514 周二 科研 实验方案修改； 工作 概率论浙大四版习题； 环境 中加秘书发邮件；工作领导小组通知； 其它 状态 最近台球游戏玩得有点多，得控制一下； 0515 周三 科研 工作 环境 其它 状态 0516 周四 科研 工作 环境 其它 状态 0517 周五 科研 工作 环境 其它 状态 0518 周六 科研 看师兄答辩；修改试验方案； 工作 环境 其它 超哥请吃老四川； 状态 无所事事的一天，不太好。要记住：我们创造习惯，习惯反过来成就我们。 0519 周日 科研 开题报告修改； 工作 环境 德育会议； 其它 海底捞；师兄请小惰； 状态 师兄毕业很开心，今天小惰超哥有点抢镜啊，哈哈哈哈 本周总结： 优点：科研有所保持； 缺点：玩得太多，正经事做得有点少，重心依旧优点趋向于环境； 最开心的事：师兄毕业； 第四周（0520-0526）0520 周一 科研 工作 环境 其它 状态 0521 周二 科研 工作 环境 其它 状态 0522 周三 科研 工作 环境 其它 状态 0523 周四 科研 工作 环境 其它 状态 0524 周五 科研 工作 环境 其它 状态 0525 周六 科研 工作 环境 其它 状态 0526 周日 科研 明确毕业论文三部分内容：粗糙度，渗流传热，神经网络参数敏感性分析； 工作 环境 其它 鸡胸肉切细片，料酒腌一下，下油炒一下，少许盐，还挺和我胃口的； 状态 感觉毕业有难度，工作方面进展也慢，有点小压力； 本周总结： 优点： 缺点：各方面好像都没做好； 最开心的事：刘总给师兄的送别宴 五月总结： 整个五月有14天没有记录，刚好是一半。有点颓废，不过今天开始恢复了，晚饭自己做了，晚上也没有去聚餐；毕业和工作的压力有点大，要扛住这个压力，然后顺利完成这两个工作。]]></content>
      <categories>
        <category>自律即自由</category>
      </categories>
      <tags>
        <tag>2019</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫烦Matplotlib笔记]]></title>
    <url>%2F2019%2F04%2F21%2F%E8%8E%AB%E7%83%A6Matplotlib%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、基本用法12345678import matplotlib.pyplot as pltimport numpyx = np.linspace(-1,1,50) #linespace:将-1到1区间均分成50个数，返回这个数组y = 2*x+1plt.plot(x,y)plt.show() 二、figure使用123456789101112131415import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-3,3,50)y1 = 2*x+1y2 = x**2plt.figure(num=5,figsize=(8,3))plt.plot(x,y1)plt.figure()plt.plot(x,y2)plt.plot(x,y1,color=&apos;red&apos;,linewidth=10.0,linestyle= &apos;--&apos;)plt.show() 三、坐标轴设置123456789101112131415161718192021222324import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-2,2,50)y1 = x+1y2 = x**2plt.figure()plt.plot(x,y1)plt.plot(x,y2)plt.xlim((-1,3))plt.ylim((0,5))plt.xlabel(&quot;cycle&quot;)plt.ylabel(&quot;UCS&quot;)new_ticks = np.linspace(-1,2,5)print(new_ticks)plt.xticks(new_ticks)plt.yticks([4,3,2,1],[&apos;$really\ good$&apos;,&apos;$good$&apos;,&apos;$normal$&apos;,r&apos;$\alpha$&apos;])plt.show() 四、坐标轴设置212345678910111213141516171819202122232425262728293031import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-1,5,60)y1 = x**2-xy2 = x**2plt.figure()plt.plot(x,y1,color=&apos;red&apos;,linewidth=2.0,linestyle=&apos;--&apos;)plt.plot(x,y2,color=&apos;blue&apos;,linewidth=2.0,linestyle=&apos;-.&apos;)plt.xlim((-1,5))plt.ylim((-1,25))plt.xlabel(&apos;iamx&apos;)plt.ylabel(&apos;iamy&apos;)new_ticks = np.linspace(-1,5,7)plt.xticks(new_ticks)# gca = &apos;get current axis&apos;ax = plt.gca()ax.spines[&apos;right&apos;].set_color(&apos;none&apos;)ax.spines[&apos;top&apos;].set_color(&apos;none&apos;)ax.xaxis.set_ticks_position(&apos;bottom&apos;)ax.yaxis.set_ticks_position(&apos;left&apos;)ax.spines[&apos;bottom&apos;].set_position((&apos;data&apos;,0))ax.spines[&apos;left&apos;].set_position((&apos;data&apos;,0))plt.show() 五、legend 图例1234567891011121314151617181920212223242526# 导入需要用到的程序包import matplotlib.pyplot as pltimport numpy as np# 获得x，y函数值x = np.linspace(-80,80,100)y = x/16# 设定图片大小，画出图像、图例plt.figure(num=1,figsize=(7,5))l, = plt.plot(x,y,color=&apos;blue&apos;,linewidth=2.0,linestyle=&apos;-.&apos;,label=&apos;CJ&apos;)plt.legend(handles=[l,],labels=[&apos;aaa&apos;],loc=&apos;best&apos;)# x,y坐标轴刻度、轴名设置,还有刻度划分plt.xlim((-80,80))plt.ylim((-5,5))plt.xlabel(&apos;position&apos;)plt.ylabel(&apos;surface height&apos;)plt.xticks(np.linspace(-80,80,9))plt.yticks(np.linspace(-5,5,6))# 设定修改坐标轴位置ax = plt.gca()ax.spines[&apos;right&apos;].set_color(&apos;none&apos;)ax.spines[&apos;top&apos;].set_color(&apos;none&apos;)ax.xaxis.set_ticks_position(&apos;bottom&apos;)ax.yaxis.set_ticks_position(&apos;left&apos;)ax.spines[&apos;bottom&apos;].set_position((&apos;data&apos;,0))ax.spines[&apos;left&apos;].set_position((&apos;data&apos;,0))plt.show() 六、Annotation 注解12]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>Matplotlib</tag>
        <tag>python</tag>
        <tag>莫烦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知乎回答总结]]></title>
    <url>%2F2019%2F04%2F16%2F%E7%9F%A5%E4%B9%8E%E5%9B%9E%E7%AD%94%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[问题一：你有哪些给男孩子在谈恋爱中的忠告（侵删）谈恋爱必须具备的两项能力：（1）体会他人需求的能力：如何循序渐进的表达自己的好感和喜欢，而不只是单方面地只顾着自己的感情宣泄，以致于冒犯到他人而不自知。（2）克制自己欲望的能力：如何避免在对方不那么喜欢自己，又或者完全无感的情况下，太早喜欢上一个人，乃至于到了不可控的地步，从而引起不可避免的情感宣泄，给自己压力不说，同时也会给身边的人带来莫大的困扰。 前者体会他人需求的能力，是一种换位思考的能力，是情商的一种表现形式。后者，克制自己欲的能力是内心安全感的体现形式，内心圆满的人，有独立灵魂的人，自我圆融为一体的人，爱情对于他们而言，从来是都不是必须品。没有爱情，他们自己一个人也可以活得很好，所以他们不会轻易地爱上一个人，更不会为了一个人而寻死觅活，也由此他们的感情生活，相对于大多数缺乏安全感的人而言更为理性，不会有过多的幻想，欲望自然也不需要太用力地去克制。可是啊，对于大多数那些没有安全感的人而言，欲望地克制却是他们恋爱过程中最重要的必修课了？ 一、为什么要学会克制欲望呢？总结：因为喜欢一个人是藏不住的，对方若是在没有任何付出的情况下俘获了你的心，他就会去寻找下一座山峰。 虽然说“欲擒故纵”，是一种俘获爱情的策略，有用，但你也要知道，那仅限于你爱得不那么深的时候。心里没有期待，自然也就没什么负担，撒点小慌，对方自然看不出什么。可当我们深深地爱上一个人的时候，那就不一样了，信息语言传达信息，肢体语言传达态度。你可以口是心非，若无其事地说，没有啊，我哪里喜欢她呀，我们只是普通朋友啊！可是，你知道吗，当你说这些话的时候，你的神情很慌乱，你的眼神飘忽不定，你的肢体语言无不都在传达着：你在说谎这个事实！ 不得不承认：当我们深深地爱上一个人的时候，不管你愿不愿意，也不管你的演技再好，你都无法做得到，跟个没事的人一样。相反，你的一脸痴相无时不刻都在出卖着你，也许对方只是稍微给你露个笑脸，使个眼神，你就以为人家有意于你，开始投怀送抱了。更甚者，人家不需要做任何的什么，只是顶着一个拉风的造型，摆着一张全世界都欠他二万五的臭脸，从你身边走过，你就已经：哦，啊，好帅……这辈子就TA了！ 你的一举一动，无不向对方传达着一个信息：我愿意！人家对你还完全无动于衷呢，你愿意什么呀？也许你天真地以为，你傻傻蠢蠢的样子很可爱很招人喜欢，可事实上对方只会觉得你的爱很廉价，毕竟使个眼色就能得来的“爱”，谁又会去珍惜呢？很轻易地，毫不费力地在没有投资任何时间、感情、精力的情况下，他俘获了你的“芳心”，你满足了他的“征服欲”、他“虚荣心”，他需要的是下一座山峰，再下一座山峰，而不是你这个人！也许你可能反过来安慰自己说，“有些人不属于自己，那怕遇见，其实也挺好，”又或者你依然不死心，你打着“朋友”的名议，试图曲线救国……可是你知道吗，欲望一旦打开了，那是不可能收得回来的，得不到回应的怨气不自觉地撒到对方身上，不可避免地会给对方造成诸多困扰，什么“朋友”，什么“曲线救国”，都只不过是你单方面的一厢情愿！ 二、如何克制自己的欲望呢？总结：如何克制自己的欲望？不要太早喜欢上一个人如何不太早喜欢上一个人？树立正确恋爱观正确的恋爱观：（1）不要把好感当喜欢，不要把占有欲当作爱。（2）不要幻想，不要寻找对方喜欢自己的证据。（3）学会分析一个人对你的真实情感，不要过分去揣测一个人的心思。（4）我们接近一个人，我们社交的目的不应该是为了恋爱，而是为了让自己身边充斥着美好的肉体有趣的灵魂，再从众多美好的肉体有趣的灵魂当中挑选一个自己喜欢的，同时也是喜欢自己的人。（5）试着给彼此一个恋爱实习期。 如果想要在爱情中做到顺其自然，不给自己压力，不给对方造成太多的困扰，同时打高成功率，那最好的办法就是克制自己的欲望，不要太早喜欢上一个人，更不要太早爱上一个人。可如何做到不要太早爱上呢，这就要求你树立正确的恋爱观了，同时丰富自己好自己的生活，克制自己不要过份地沉湎于不着边际的幻想，不要去寻找对对方同样也是喜欢自己的事实！可现实是，总有很多人内心戏十足，对方给自己露了个笑脸，抛了个媚眼，就对为对方有意于自己；对方一个小时不回自己的消息，他整个人就哭天抢地，悲伤得不能自己，玻璃心又事儿妈，小心翼翼地终日惶恐怕恐…… 树立正确恋爱观： 1、不要把好感当喜欢，不要把占有欲当成爱；要了解一这点，你就必须得明白，什么是好感，什么是喜欢，什么又是爱？ 所谓的好感： 是一种流动性的，一对多的浅层次的情感，是冲动，是荷尔蒙，是性激素，是好奇……今天你可以对一个人有好感，觉得对方是一个有魅力的人，也许后天你却又发现对方不是你想象中的那样，似乎也不那么值得去“爱”，于是呼，你换了个对象，你“喜欢”上了其他的人，也许你还会自作多情地有一种“不忠”的感觉。 所谓的喜欢： 是双方在好感得以长期维持的情况下，随着时间的递进，双方之间加深了了解，什么样的性格，什么样的职业，有什么优缺点，有什么样的理想，是什么样的人，并在此基础之上产生一定程度的情感依赖，是一对多； 因为这份喜欢，你会不自觉地进入对方的空间，翻看对方的朋友圈，想更深层次地了解对方； 如果你长时间没有看到对方，或多或少你会有一种失落感和惆怅……当然这只是一种轻微地失落和惆怅，过了一段时间后，你又能恢复如初……没有对方，你会有一些小失落，但你的世界依然在转！ 相对于好感，有依赖的成份，但依然是一对多！ 所谓的爱情： 是一种长期且稳定的深层次情感，是喜欢的基础之上产生的强烈情感依赖，见过了彼此最不堪的一面，彼此暴露出最真实的自我，我知你、我懂你，离开对方，自己的生活或多或少会产生一定程度的不适，由此产生了互相占有对方的想法，随之也就有了排它的属性，是一对一。这个时候彼此之间的情感才能谈得上爱情。 不得不承认，人与人之间，你不坦诚相见个十次八次，你永远不知道对方是一个怎样的人，到底适不适合自己……面都没见过几次，饭也没吃过次，没有足够多的时间去了解彼此，不知道对方是谁，不知道也不想知道对方的过去，不了解也不想了解对方将来要过怎样的生活，只是见人家衣服穿的少了点、胸大了点，就花痴地认为自己遇到爱情了，更甚者认为对方是自己此世今生的唯一，轻易地将自己的未来和对方的未来捆绑在一起，这不是爱，是冲动，是占有欲，是好奇。 没有足够的时间去了解彼此，却轻易地将自己的未来和对方的未来捆绑在一起，这不是爱，是冲动，是占有欲，是好奇。 “爱情”从来都是一件很严肃的事情，没有个三五年，谁无都无法判断是好感还是激情，是新鲜感还是寂寞，一见钟情，钟的往往不是情，而是一副美好的皮囊。 2、不要幻想，不要寻找对方喜欢自己的证据；我曾经不止一次强调过：不要去思考一个人到底喜不喜欢你，也不要去幻想那些不着边际的未来！ 究其缘由在于，当你思考一个人到底喜不喜欢你的时候，当你幻想那些不切实际的未来的时候，那是你不断下坠的过程。为了找到他是喜欢你的证据，你会不断地，反复地思考你与他相处时的一言一行，一举一动……他多看了我一眼，他是不是喜欢我呢？上车的时候，他走过来，先帮我开车门，他是不是对我有好感呢？看见没有，他对我笑了，笑得多阳光呀，这个微笑是属于我的，不属于任何人……可是啊，为什么我发消息给他的时候，他总不能做到及时回复呢，他应该是喜欢我的呀。为什么有时候晚上聊天的时候，聊着聊着，他怎么就睡着了呢，他到底有多喜欢我，我们是不是只能是朋友了？ 唉，今天又是情人节了，室友们都出去约会去了，可是呀，你这个呆瓜木头人，为什么对我还是无动于衷……快来约我呀，来约我，约我，约我呀！ 反正呐，此世今生就是他了，唯她不娶，非他不嫁，我相信只要凭着我的努力，我就一定能获得我想要的幸福。在不远的将来，我要把TA介绍给我身边的朋友，我要带TA去看三月的樱花，六月的雨，八月的向日葵，十月的晚风，我要带她去见我的父母亲朋与好友，我们在市中心最豪华的地方买房，领证结婚，再生好多好多个孩子！可现实是，八字还没一撇呢，想多了吧？ 本来呀，你对她喜的度，爱的量，不增不减，当你放纵自己去思考：他到底喜欢还是不喜欢你时，去寻找他喜欢你的证据时，你对他的痴心却在不断地放大，乃至于不可自拔，你不断地坠落，不断地下沉，你变得不可自拔。猛然一惊: 天啊，我已经深深地坠入爱河，这辈子我再也离不开他！ 3、学会分析一个人对你的真实情感，不要过份地去揣测一个人的心思；爱情本身就是一件非常主观的事情，我爱或者不爱你，本就就是一种主观喜欢！既然是主观，那大部分分析，都基本上是偏离客观的，也就是不准确！所以人家又说了，爱情中的人，基本上都是智商等于零！ 人的行为，主要受两个因素所支配：1、情绪；2、情感； 情绪是很不稳定的，他今天可以对你很好，明天可能又做会出一些看起来讨厌你的举动，背后的因素不可考究，也许是她大姨妈来了，也有可能是她跟朋友吵架了，总之不可能是因为你的因素，同时越是不成熟的人，情绪波动也就越大，所以情绪所产生的行为几乎没有任何可参考的意义！ 真要分析一个人对你的情感，必须综合五个行为左右，而且五个行为时间必须是20天，乃至一个月不等，为何这样子呢？因为一个人的情感周期是，可以说是女生大姨妈的周期！假如一个月内10个行为举止中有三到四个，都指向抗拒你、反感你，不想跟你说话，那你就应该警醒了，你们之间的感情确实存在着危机，或者她也不是那么喜欢你啦！ 4、我们接近一个人，我们社交的目的不应该是为了恋爱，而是为了让自己身边充斥着美好的肉体有趣的灵魂，再从众多美好的肉体有趣的魂中挑选一个自己自己喜欢的，同时也是喜欢自己的人！这个世界没有那么多不负如来不负卿的感情，有些人不属于自己，那怕遇见，其实也挺好！ 不要为了“得到”的目的去接近一个人，而要抱着多认识一个人，多交一个朋友的目的去了解一个人！时常反问自己：如果你为对方付出了许多，如果对方最后并没有选择你而选择了其他的人，你还会继续对她好吗，还会把她当成朋友看待吗，还是删除对方的联系方式，老死不相往来，更甚者从中搞点小破坏，所谓的“我得不到的，别人也别想得到”！ 最开始的时候，你就不抱着太多的期待，做不了恋人，那做朋友其实也挺好的态度，期望的阈值降低了，你自然就能很好的克制自己的欲望。相应的，在两个人的相处中，你会从容许多，你也能够真心为对方乃至是无所求的真诚付出，相应的，你会从容许多，更能享受过程，成功率自然也会高出许多。 想想逝去的青春，那么多年，你删过多少优秀的值得你去爱的人呢？耐何优秀的值得你去爱的人本来就少，见一个喜欢一个，不懂得克制自己的欲望追一个，失败了再删一个……急功近利，不留余地，删删删……把这些你删过的异性集合起来，是不是能组一个足球队呢？ 现在让你组织一场聚会，你又约得出几个异性出来呢？其实她今天不适应你，不代表明天不答应你，十年后她依然不答应你啊。当然啦，要注意哦，这里的她是很多个”她“，我可从来不建议一个人在一颗树上吊死的！ 以上，是广撒网多捕鱼的策略，是克制自己欲望的过程！之所以在这个过程中你感觉到累了，那只一个原因，你期望得太多，在女生对你无感的情况下，你已经投入得太多，所以痛苦是一个必然。还是那句话，如果一个女生没给我十分明确的承诺，我会把她当朋友，是友情，但这份友情，有点那方面的意思仅此而以！ 5、试着给彼此一个恋爱实习期；如果你们聊了一些深层次的话题，你们之间建立了足够的舒适感和案例感；如果你的主动，在她那儿都能得到了良好的回应，不仅如此，时不时地她也会主动地找你聊天，你们走在路上，不管你们双肩靠得有多近，他都不感到有任何的不适，那你可以试着传达在一起的意图了，你可以试着用行为去撩一下她，拉拉她的小手，甚至是一个突袭地吻…… 如果你们做以上的这些，她都不感到尴尬，那么你们进入了一个新的阶段：试恋爱阶段！ 试恋爱阶段，顾名思义：两个人试着处一处。之所以提出这个概念是因为，爱情不是沉重和捆绑，爱情是两个青年男女轻松自然的相处出来的。如果你希望享受爱情，如果你想提高成功率，在爱情中做到顺其自然，那同样的也还是不要抱着太多的期待，也不要过早地要求彼此给对方太多的承诺，纵是我喜欢你，你也同样有意于我，也不要急着谈什么海誓山盟，应该试着给彼此一个恋爱实习期！ 以下是我跟我女友的初告白哦，希望能够给大家一个启发： 我喜欢你，我相信你同样有意于我，我也知道你对我也有那么点小心思，不过，话又说回来，你与我之间谈爱又还太早，没有真正的相处过，你我都不知道，我们到底合不合适，要求对方给自己过多的承诺也太不理性。我们先给彼此一个恋爱实习期呗，先试着处上两个月。在接下来的两个月里，我们先不公开这份关系，过程中如果你发现我有什么不足，或者做得不到位的地方，你要告诉我，我试着去改……甚至，你也可以试着拿我跟其他的男生进行比较，如果两个月结束后，你觉得我们不合适，选择了其他人，那么，我也会有些我也表示尊重和理解！ 因为没有拉升的机会，无法从普通朋友上升为好朋友；也有可能因为，你在表达好感的过程中，给了对方太多压力，使得对方远离你；也有可能是因为你应该拉升关系的时候没有拉升，从而错过了为数不多的窗口期；也有可能是你们对于将来的规划不一……太多的原因，太多的不得以，但不管怎么说，我还是希望你们：做不成恋人，还是可以做朋友！ 不要事事问个结果，不要想着自己可以走到哪一步，喜欢就去表达好感，表达倾慕之心。不要那么多结果导向，不要事事都问一个意义。任何事情，如果一定要强调什么意义，到最后你会发现哪有那么多的意义……或者说，人生本来就是没有意义的。我们活着应该更多的是为了做自己，表达自己，——信仰。这就是超越成败背后的意义！不要把人生理解为一场战斗，那太苦逼，永远记住：我们活着只是为了实现自我，这样子在这个世间没有任何人能够打败你，你就是你自己！ 行文至此，送上我最爱的经典： 有一天，你不再寻找爱情，只是去爱；你不再是渴望成功，只是去做；你不再追求成长，只是去修。那么，一切才真正开始！爱得美，做得成，修得好！灵魂是走在回家的路上，这种美妙殊胜的感觉远远超越你想要的爱情、成功、成长。——纪伯伦]]></content>
      <categories>
        <category>评</category>
      </categories>
      <tags>
        <tag>知乎</tag>
        <tag>恋爱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[句子]]></title>
    <url>%2F2019%2F04%2F13%2F%E5%8F%A5%E5%AD%90%2F</url>
    <content type="text"><![CDATA[听失败者讲话（得到失败的经验以及他失败的原因），看成功人做事。 一个好女人，能让一个男人成为好男人；而一个坏女人，能让一个男人成为哲学家。—-苏格拉底（学生是柏拉图，学生的学生：亚里士多德） 小时候父亲告诉我，女人的眼泪是脑子里进的水，当她眼泪流干的时候，就不好对付了。 如果你想急着做完一件事，说明你的心已经不在这件事上了。 我们造成习惯，习惯反过来成就我们； 我们需要艺术，以免因真相而死亡—-尼采 一个人要有多悲观，才能每天过得开开心心。 这些年，她在我心目中的形象有时万分可恶，有时又重新变得纯洁无暇，无可比拟。我对她，其实爱早就消失了，变成怀念、痛苦、嫉妒、同情、欲望，不断循环。可是没有一秒钟，我对她的感情归于平淡。没有一秒钟。 康德说他最早时瞧不起没有知识涵养的人，后来读了卢梭的书，他认识到人和人之间不应该用头脑来区分，而应该以道德来分辨。读书多肯定看世界的眼光会不一样，但那并没有什么了不起的。从社会学的角度来讲，你之所以有眼前的书，那是整个社会通力合作的结果，那些你看不起的人中，有人替你造纸，有人替你印刷，有人替你排版，更别说你身上的衣服，吃的东西，都是现代社会协作生产的结果，都是“不聪明”的大多数人制造的。没有他们，你只是一只聪明的猴子而已。换句话说，那些少看书的人未必就不聪明，只是他们也许没有你的条件，没有你的环境，仅此而已。总之，知识阶层骄傲是应该的，但是他们之所以骄傲，不应该是他们拥有知识，而应该是他们有能力承担更多的责任。]]></content>
      <categories>
        <category>评</category>
      </categories>
      <tags>
        <tag>句子</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[素描练习记录]]></title>
    <url>%2F2019%2F04%2F10%2F%E7%B4%A0%E6%8F%8F%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[20190407:20190410：]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>素描</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《人生的智慧》读书笔记]]></title>
    <url>%2F2019%2F04%2F09%2F%E3%80%8A%E4%BA%BA%E7%94%9F%E7%9A%84%E6%99%BA%E6%85%A7%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[译者序第一段：叔本华一生并不得志，后来时来运转也只是大众肤浅地追捧，经过流行的巅峰后，就重新归于相对的沉寂。因为他的哲学与大多数人的乐观世界观不相符。虽然第二次世界大战完美地打碎了令人陶醉的乐观主义，但在和平时期，人的眼睛仍旧是短视的，思想仍旧是懈怠的，所以叔本华的哲学只能在少数思想深远的人的头脑中扎根。PS：“天地不仁，以万物为刍狗”（上天并不仁慈，视万物如祭祀用的草扎的狗一般。说明上天对待万物是公平的，并不会特殊对待某人） 第二段：叔本华从来不怀疑自己的天赋使命，他笔耕不辍；不在乎外人的嘲笑。另外他是位语言大师，不仅语言精准，而且简朴。他蔑视空洞抽象，花哨虚假，不为虚名写作。PS：“上士闻道，躬而行之；中士闻道，若存若亡；下士闻道，大笑之，不笑不足以为道”（有智慧的人听了大道理后，会躬身力行；普通人听了大道理后，好像理解又好像没有理解；庸俗的人听了大道理后，对它嗤之以鼻，大声嘲笑，如果不被庸俗的人嘲笑，那么大道理也不能被称之为“道”了） 第三段：叔本华早在30岁就奠定了自己的哲学大厦，完成了叔本华哲学的核心著作《作为意欲和表象的世界》，之后的工作只是对他的哲学观点进行发挥和补充。然后这本著作首发时几乎无人问津。 第四段：叔本华接连写下许多著作，仍无人问津。 第五段：“真理可以耐心等待，因为真理是永存的”，叔本华在出版最后一本著作《附录与补遗》时，终于一夜成名。 第六段：《人生的智慧》取自《附录与补遗》，这本书尽量从世俗、实用的角度考虑问题，因此更适合大众阅读。 第七段：对“意欲”一次作简单的解释。根据叔本华的理论，意欲是这个世界的本原。（1）它超越于时间、空间和因果律以外，既没有原因，也没有目的；（2）它盲目、不顾一切地争取客体化。（我们这个存在于时间、空间，遵循着因果律的复杂多样的现象世界就是意欲的产物和表现，是意欲在时空中的客体化）由于意欲在客体化中遵循着个体化原理（就是说存在于现象世界中的具体、单个组成部分的意欲各自为战，为生存、发展而努力；（在现象世界中表现为在低一级的形态向着高一级的形态的争取、斗争）所以，意欲客体化的过程是一场永恒的、无目的的斗争和发展；它与痛苦和灾难不可分割地联系在一起。 引言 幸福不是一件容易的事：她很难求之于自身，但要想在别处得到则不可能。—–尚福尔（法国作家） 第一段：人生的智慧，其实就是如何称心、愉快地度过这一生的艺术，哲学上可称为“幸福论”，因此，这本书教导人们如何才能享有幸福的生存。但作者对于人生能否与如此定义的“幸福生存”相吻合给予了否定的答案，所以要完成幸福论的著作，作者的议论从平常的角度、实用的角度出发。 第一章、基本的划分第一段：决定凡人命运的根本内容在于三个方面：（1）人的自身。（最广泛意义上属于人个性的东西，包括健康、力量、外貌、气质、道德品格、精神智力及其潜在发展）（2）人所拥有的身外之物。（财产和其他占有物）（3）人向其他人所显示的样子。（他人的看法：名誉、地位、名声） 第二段：相比于身外之物和他人的看法，自身对造成人幸福或不幸福会产生更加根本和彻底的影响。为什么？（1）人的内心快乐或痛苦首先是人的感情、意欲和思想的产物。而自身之外的所有事物对于人的幸福只产生间接的影响。（因此同一样外在的事物和同一样的境遇，对于每个人的影响不尽相同，因为与一个人相关的是这个人对事物的看法、他的感情以及他的意欲活动。外在事物只有在刺激起他的上述东西时才发挥作用。）每个人到底生活于何样的世界，首先取决于这个人对这个世界的理解。现实生活中经历的每时每刻，都由两部分组成：主体和客体。面对完全一样的客体时，不同的主体意味着所构成的现实完全不同。PS： 大众，不分贵贱，都总是承认：众生能够得到的最大幸运，只有自身的个性。”—-歌德 第三段：对于人的快乐而言，主体远远来得比客体重要。而人的健康远远压倒一切外在的好处。为什么？一副健康、良好的体魄和由此带来的宁静和愉快的脾性，以及活跃、清晰、深刻、能够正确无误地把我事物的理解力，还有温和、节制有度的意欲以及由此产生的清白良心—-以上这些好处都是财富、地位所不能代替的。 第四段：对我们的生活幸福而言，我们的自身个性才是最重要和最关键的为什么？（1）我们的个性持久不变，它在任何情况下都发挥着作用。（2）第二、三项好处的保存只能听天由命，而自身个性却不会被剥夺。 第五段：由于自身个性对于生活幸福的重要性，所以我们唯一能做到的就是尽可能充分地利用我们既定的个性，循着符合我们个性的方向，努力争取适合个性的发展，除此之外则一概避免。（就是要选择与我们个性相匹配的地位、职业和生活方式） 第六段：虽然注重身体健康和发挥个人自身才能比全力投入获得财富更为明智，但不要错误理解为我们应该忽略获得我们的生活必需品（适当的财富）。不过，真正的财富（一般指多数的财富）对我们幸福的帮助并不大。 第七段：人的内在拥有对于人的幸福才是最关键的。而大多数不必与生活匮乏作斗争的人，在内在空虚、意识呆滞、思想贫乏的驱使下投入到社交娱乐当中。 第八段：另外两项（财富和他人看法）的重要性不需要强调，第二项是公认的。第三项分为名誉、名望、地位。每个人都可以争取得到名誉；社会地位只有服务国家政府的人才能染指；显赫的名望只有极少数人才会得到。另一方面，只有傻瓜才会把社会地位放置在财产之前。财产、名誉、声望是相互影响的关系。 第二章、人的自身第一段：自身的主要构成：健康的体魄、愉快的心情、良好的智力、高贵的品格。 第二段：人自身中最能带来幸福的是愉快的心情，而愉快心情就是从健康的身体里长出的花朵。保持身体健康的手段无非就是避免一切纵欲放荡的行为、令人不快和剧烈的情绪动荡，以及长时间紧张的精神劳累。最大的愚蠢就是为了金钱、晋升、学问、名声，甚至为了肉欲和其它片刻的欢娱而献出自己的健康。 第三段：愉快的心情不完全取决于健康的体魄，即使是有健康的体魄也会生成忧郁的心情。因为他们的感觉能力与新陈代谢的能力的比例不正常，天才常常忧郁正是因为有着超常的感觉能力。 第四段：出现不同情绪是因人有着不同的感受愉快或不愉快的能力，“郁闷”型的人虽然比“愉快”型的人少感受很多快乐，却规避了很多真实的不幸和苦难（因为他们遇事总考虑最不好的结果） 第五段：健康与美貌有着部分关联，良好的长相是一纸摊开的推荐书，它从一开始就为我们赢得了他人的心。 第六段：痛苦和无聊是人类幸福的两个死敌，我们的生活就是在这两者当中或强或弱的摇摆。这是因为痛苦和无聊存在双重的对立关系：一重是外在（客体）：生活的艰辛和匮乏产生的痛苦，丰裕和安定产生的无聊。另一重是内在（主体）：精神丰富的痛苦，精神迟钝的无聊。 第七段：人们辛苦挣来的闲暇，就是为了让人能够自由地享受意识和个性所带来的乐趣。而当闲暇来临时，凡夫俗子只关心如何去打发时间，而略具才华的人却考虑如何利用时间。为了应付无聊，人们就为意欲找出一些琐碎、微小、随意和暂时的动因，以图刺激意欲，并以此激活智力—-因为智力的任务本来就是理解、把握动因。但这些动因，较之于那些真正、自然的动因，犹如纸币比之于银元，因为前者的价值是带有随意性的；大部分游戏（纸牌）就属于前一类动因。没有游戏，他们便会摆弄手头的物品来帮助自己打发时间，雪茄就是这样的一件代替思考的物品。 第八段：如果一个人内在充足，丰富，不需要从自身之外寻求娱乐，那么，这个人就是一个最幸运的人。 无论身在何处，我们只能在我们自身寻找或者获得幸福。–《旅行者》 第九段：人的幸福全在于无拘束地施展人的突出才能。 第十段：人三种能力的发挥和活动构成了人的三人快乐的源泉： 吃喝、消化、休息和睡觉。（机体新陈代谢能力所带来的乐趣） 运动。（发挥肌肉力量所带来的乐趣） 观察、思考、感觉、阅读、默想、写作、学习、发明、演奏音乐和思考哲学（施展感觉能力方面的乐趣）感觉能力能带来的快乐远大于另外两种基本生理力量。 第十一段： 能够不受阻碍地培养、发挥一个人的突出才能，不管这种才能是什么，是为真正的幸福。 谁要是生来就具备、生来就注定要发挥某种才能，那他就会在发挥这种才能中找到最美好的人生。 PS：《叔本华论道德与自由》：叔本华认为，我们的任何行为都可以归结为一个动机。我们因为这个动机，从而做出了一个相应的行为。当我们做一件事的时候，我们意识到它符合我们的动机，从而领会到一种自由感，但我们的动机却只取决于某一意志，而这意志却不是我们所能把握的，也就是说我们可以体会到一种虚假的自由，却无法得到真正的自由。 第三章、人所拥有的财产第一段：伊比鸠鲁把人的需要分为三类： 第一类属于人的天然的和迫切的需要（食品、衣物） 第二类需要同样是天然的，但不是迫切的（性欲） 既不是天然的，也不是迫切的。（奢侈、排场、铺张和辉煌的追求） 第二段：一个人在拥有财产方面能否得到满足，由一个人所期待得到的财产和自己已经实际拥有的财产之间的关系决定。在我们心目范围之内的具体之物一旦出现，而我们又确信能够得到它，那我们就会感到幸福。但是如果得到这具体之物存在重重困难，他根本就没有得到它的希望和可能，那他就会感觉不幸和痛苦。财富犹如海水：一个人海水喝得越多，他就越感到口渴。这一道理同样适用于名声。我们在失去财富和安逸的处境以后，当我们挺住了最初的阵痛，我们惯常的心境与当初相比较，并没有发生很大的改变。这是因为当命运减少了我们的财富以后，我们自己也就相应降低了我们的要求。反过来，如果交到好运，我们的期望的压缩机就会把期望膨胀起来，我们在这过程中就感到快乐。但是，这一快乐并不会维持多久。当整个剁成全部完成以后，那扩大了的要求范围已经被我们习以为常了；并且，与新的要求相比较，我们就会对目前的拥有不以为然了。 第三段：我们之所以感到不满，原因就在于我们不断试图提高我们的要求，但同时，其它妨碍我们成功的条件因素却保持不变。 第四段：任何其它物品只能满足一个需要，而金钱能满足抽象中的普遍的多种需要。 第五段：我们应把现有的财富视为能够抵御众多可能发生的不幸和灾祸的城墙，而并不是一纸由我们寻欢作乐的许可证。以艺术为职业的人，应把应用天赋才能赚来的钱的大部分当作本金而不是利息，因为他们的才能总有枯竭的时候。以手工技术为职业的人，技术能使用的时间比较长，因此他们赚来的钱比较稳定。而商人则是使用钱来挣钱的人，他们会更好或者更精通如何使用钱。 第六段：以贫穷为现状的人，一旦获得巨额财富，会视之为身外之物，将财富享受和挥霍。 乞丐一旦跨上了坐骑，就非得把马跑死为止。—-《亨利五世》 第七段：上述的人如果是靠能力获得财富的，他对自己的运气和能力抱有过分的自信，而这个自信是在心里，而不是在脑子里。 一个习惯于处理钱财的有钱女人，会小心翼翼地花钱。但一个在结婚以后才首次获得支配金钱权力的女人，会在用钱的时候大胆妄为，她简直就是大肆挥霍。—-《约翰逊的一生》 第四章、人所展现的表象第一段：我们总是过分看重自己存在于他人心目中的样子，但他人的看法就其本身来说，对我们的幸福而言并非至关重要。太过重视他人的看法，就像把一个人的荣誉感建立在“被人夸奖就开心，被人轻视就痛苦”这种特殊的人性上，它会代替道德促使人做出良好的行为。但是对于人自身的幸福，这种荣誉感更多地产生扰乱和不良的作用。所以，从增进幸福的角度出发，我们应该抑制这一人性弱点。应该细致考虑和恰如其分地评估它的真正价值，尽量减低我们对待别人意见的敏感程度，不能称为他人看法和意见的奴隶。 使一个渴求赞语的人闷闷不乐或者兴高采烈的话语，却是多么的无足轻重！ “人的自身、人所拥有的财产”都在我们的头脑意识里发挥作用；而别人对我们的看法旨在别人的头脑意识中产生效果，它是附带种种概念性的东西呈现在别人头脑中的表象。了解这些之后，就可以逐渐对他人的评论泰然处之了。 第二段：这种把非直接为我们所存在的东西作为直接的存在来加以看重的愚蠢做法，人们称之为虚荣，以表示这种渴望、努力所具有的虚幻和空洞的本质。 第三段：隐居生活之所以对于我们的心绪宁静有一种特别良好的影响，其主要原因就在于我们不用生活在别人的视线里。 第四段：虚荣与骄傲的区别在于：骄傲就是确信自己拥有某一方面的突出价值，但虚荣则尽力让别人确信自己拥有某一方面的突出价值。骄傲是发自内在的、直接的自我敬重；而虚荣则是从外在、因而是间接地努力试图获得这一自我敬重。 第五段：如果我们善意地忽略自己的优点，在与他人的交往时也与他人一道错误地视自己与他人是一个样，那么他人就会公开坦白地把我们认定为就是这个样子。 “跟奴隶开玩笑，奴隶就会对你不屑” “你必须强迫自己接受应有的骄傲” 第六段：最廉价的骄傲就是民族的自豪感。 第七段：他人的看法可分为名誉、地位、名声。 第八段：地位、头衔的作用是要得到别人虚假的尊敬，对于增进个人幸福而言，用处不大。 第九段：客观上，名誉是他人对我们的价值的看法；主观上，则是我们对于他人看法的顾忌。 第十段：名誉感和羞耻感的来源：单独的人能够做的事寥寥可数，只有当他生活在与其他人所组成的群体里，他才能有所作为。人的意识得到了发展以后，才会认识到自己这种处境。一旦这样，他就会产生愿望，希望别人视他为人类社会中的一个有用成员，一个有能力履行自己的男人角色的人，并由此能有资格去分享社会所带来的好处。要成为这样的人，他必须首先做好每一个人都需要做好的事情；其次，他需要完成处于他那独特位置上人们所要求他和期望他做好的事。但同样，他很快就认识到问题的关键并不在于他认为自己是一个有用的人，而在于别人是否也这样认为。他要获取别人对自己良好看法的热切愿望，以及他对别人的看法的无比珍视，也就由此而来。这两者都源自人的这种内在感觉—-人们名之为“名誉感”，或者“羞耻感”，这根据情况而定。 未完待续… 第五章、建议和格言第一部分 泛论第一节第一段：理性的人追求的不是快乐，而是没有痛苦。（所有的快乐，其本质都是否定的，而痛苦的本质却是肯定的。）举例解释：1.身体只要有一处疼痛，人就会只关注疼痛的那一处，而不关心其它健康的部分。2.如果有一件事违反了我们的意愿，我们就会总惦记这件事，而不去关心其它如我们所愿发生了的事。从上述情况我们可以看到，意欲的满足总是否定的。意欲得到的满足并不直接被我们感受到，它顶多只以反省、回顾的方式进入我们的意识。但是，意欲受到的抑制却是肯定的。每一快感的产生其实就是意欲所受到的抑制得到了消除，意欲获得了解放。所以，每一种快感都持续相当短暂的时间。 快乐只不过是一场幻梦，但痛苦却是真实存在的。—-伏尔泰 生活并不是让我们享受的，我们必须忍受它和克服它。我们不应该以痛苦为代价去购买快乐，甚至只是冒着遭受痛苦的风险去这样做也不行，否则，我们就会为了那些否定、因而是虚幻的东西而付出了肯定和实在的东西。 第二部分 我们对待自己的态度第四节第一段：认识自己的第一步：了解清楚自己的首要和真正的意愿。应该大致明白自己应该从事何种职业、需要扮演何种角色以及自己与这一世界的关系。 第五节第一段：人生智慧的重要一点就是在关注现在和计划将来这两者之间达到恰到好处的平衡，这样，现在与将来才不至于互相干扰。现在才是唯一真实确切的。将来的发展几乎总是与我们设想的不同，甚至过去也与我们对过去的回想有所出入。 第二段：只能为肯定会发生的灾祸忧心，但这一类灾祸少之又少，因为将来的灾祸充其量是极可能发生或者肯定发生，但发生的事件是全然不确定的。为了保证我们的生活安宁不受影响，我们必须养成习惯，把并不肯定发生的灾祸视为永远不会发生，而并不肯定在某一时间发生的灾祸则肯定不会在很短时间内发生。 第三段：我们忘记了每一天的日子都是生命中不可缺少而又无法代替的，不要总觉得今天又将在明天重现。要珍惜每一刻可以忍受的现在，包括最平凡无奇、我们无动于衷地听任其逝去，甚至迫不及待地要打发掉的日子。 第六节第一段：所有的局限和节制都有助于增进我们的幸福。原因在于意欲受到的刺激越少，我们的痛苦也就越少。限制我们的活动范围就能消除刺激我们意欲的外在动因，而精神上的限制则可以消除内在的动因。但是精神上的制约会产生无聊，所以尽可能的外在限制能增进人们的幸福。（如果无法保证足够丰富的精神以对抗无聊的话） 第七节第一段：忙于外在生活会夺走精神生活所需要的宁静和专注，同样，持续从事精神活动会或多或少地削弱我们应付嘈杂、繁忙的现实生活的能力。所以，每过一段时间，当我们需要着力操持实际生活的首，暂时完全中断精神活动会有好处。 第八节第一段：要从生活经验中汲取一切有益的教训，我们就必须勤于反省，经常回顾做过的事情和曾经有过的感觉和体验；此外还要把我们以前对是事情的判断和现在的看法，以及订下的计划及追求和最终得到的结果及满足相互比较。一个人的生活犹如书的正文，对生活经历的咀嚼和认识则是对正文做出的解释。当时发生的事情，过后可能会忘记并难以回想起来，所以对于值得回忆的时刻，要小心保存。（比如日记） 第九节第一段：幸福属于那些容易感到满足的人，原因如下：（1）人除了依靠自身以外，无法有把握地依靠别人。（2）社会给人所带来的困难和不便、烦恼和危险难以盛数、无法避免。 第二段：获取幸福的错误方法莫过于追求花天酒地的生活，原因如下：（1）我们企图把悲惨的人生变成接连不断的快感、欢乐和享受。这样，幻灭感就会接踵而至。 第三段：社会一旦变得人多势众，平庸就会把持统治地位。 第十七段：学会在人群中保持一定程度的孤独。 第十节第一段：嫉妒是破坏幸福的敌人，我们应该多想想那些处境比我们更为恶劣的人，因为那些生活得比我们好的人只是看上去比我们更好而已。 第十一节第一段：实施某一计划前，要对其深思熟虑，但是一旦开始执行，就静待结果，不要不断回头考虑已经在做的事和的担忧可能遇到的危险。 第十二节第一段：对于已经发生、不可更改的不幸时，要看开。 第十四节第一段：相比于感慨没得到想要的东西，可以多想想已有的东西失去后，我们将会怎样看待那失去之物。 第十五节第一段：做事要一件一件做。 第十七节第一段：生命在于运动。（找一样符合自己个性的才能，然后不断学习） 第十八节第一段：我们行动和努力的指南不可以是想象中的图像，而应该是考虑清楚的概念。（不能为了想象中的东西而行动，而应该考虑实际状况所呈现出来的概念）教育就是让我们只信赖概念，而进行教育时的图像只是起到辅助性的作用。 第十九节第一段：补充第十八节内容，我们应该时刻驾驭我们对眼前现实的印象和直观认识。如果我们无法纯粹通过思想消除某一印象影响的时候，最好的办法就是运用相反的印象以中和它的作用。（忘不了不喜欢你的女生的话，可以想想其他可爱的女生，哈哈哈） 第三部分 我们对他人应该采取的态度第二十一节第一段：在这世界上生存，具备一定的预见能力和宽恕能力合乎我们争取幸福的目的：前者帮助我们避免受到伤害和损失、后者则为我们免除了人事纷争和吵闹。 第二段：“生活，也让别人生活”别人拂逆我们的心意，妨碍我们的行动，但他们这样做完全是出于一种严格的、发自他们本性的必然性，这与物体活动所根据的必然性一般无异。对待许多人，我们最聪明的想法就是：我不准备改变他们，我要利用他们。 第二十二节第一段：]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>人生的智慧</tag>
        <tag>叔本华</tag>
        <tag>哲学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[粗糙度研究现状]]></title>
    <url>%2F2019%2F04%2F06%2F%E7%B2%97%E7%B3%99%E5%BA%A6%E7%A0%94%E7%A9%B6%E7%8E%B0%E7%8A%B6%2F</url>
    <content type="text"><![CDATA[一、起源Patton（1966）用模型试验证实了规则突起岩体符合某个强度准则。 由于实际结构面大多数凹凸不平，起伏角变化较大，而且研究表明Patton起伏角在不同正应力下力学效应不同，于是 Barton提出了新的不规则岩体结构面抗剪强度经验公式，公式中JRC的量测比较困难和复杂。 二、现有确定JRC的方法 Barton标准剖面法 优点：ISRM采用，简单省时不用计算 缺点：精度不高误差大，近年已很少使用 直接测量法（结构面起伏角可通过比较七剖面的全迹长和直线迹长得到） 优点：较Barton法精度有所提高 缺点：真实的全迹长确定较为困难，即使是同一剖面每次量测结果亦均不相同。选择剖面较多，工作量大，并要动用复杂仪器。 表面粗糙参数法 优点：量测过程精度高 缺点：对仪器要求严格，工作量大，若非自动连续记录仪器量测则可导致较大误差，使精度下降。 伸长率法 优点：精度较高 缺点：物理意义不明确，精度和可靠性还有待理论上论证和时间经验积累 幅度法 优点：简单省时 缺点：仅考虑结构面最大起伏幅度是相对结构面长度而言的，没有考虑较小突起体对JRC的贡献，因此精度变化较大。 分形维数法 优点：有良好的理论基础和较高的精度，目前较为完善的方法之一。 三、粗糙度分形维数法进展早期由于设备限制，主要集中于 3.1 节理轮廓线的分形描述，主要获取方法有 针状轮廓尺法，简易纵剖面仪法，RSP-I型智能岩石表面形貌仪法，接触打孔器法，阴影轮廓线法。 近年来，随着设备推陈出新，结构面三维形貌数据较容易获得，主要获取设备有 3D型便携式岩石三位表面形貌仪，三维激光扫描岩石表面仪。 3.2 结构面的分形描述3.2.1 间接描述采用节理轮廓线分维数加1或计算结构面上一条或多条节理轮廓线的自仿射分形的Hurst指数H，然后根据D=3-H获得结构面分形维数。3.2.2 直接量测三角形棱柱表面积法投影覆盖法立方体覆盖法 四、结构面的多重分形描述五、粗糙度表征方案备选石林-3D岩体结构面粗糙度表征方法优点：1.测量便捷，能快速获取现场结构面的形态特征，且计算出的粗糙度具有精确度和可靠度；2.是一种3D角度的评价方法，更全面地考虑结构面的特征，综合反映结构面形态；3.能够反映结构面粗糙度的各向异性、尺寸效应和间距效应这三个影响因素。4.没有复杂的计算过程，具有操作简单便于推广的优点。缺点：尚未建立面积拓展率S和结构面起伏度Rs与岩体结构面抗剪强度的关系。 方法的由来：伸长率：1.伸长率法既考虑了节理相对长度，也考虑了节理剖面起伏变化的因素，而幅度法只考虑了最大的起伏幅度，没有考虑较小的起伏幅度对抗剪强度的影响。2.用伸长率确定节理粗糙度系数的精度主要取决于测量仪器的精度（现在有三维激光扫描仪能保证精度） 直边法和修正直边法：1.岩体结构面表面形态具有各质异性、各向异性和非均一性，定向统计测量方法是保证JRC测量精度的基本方法。2.直边法具有明确的物理意义，有精度保证、测速快、操作简便等优点。修正直边法是Barton直边法的扩充，具有比直边法更强的普适性。3.修正直边法的数学表达式包容了JRC的尺寸效应规律，配合计算机使用，适用于岩体结构面JRC的统计测量。#各质异性：成因、类型和规模相同的同一组结构面，由于所处岩石性质不同，结构面的表面形态和JRC存在明显差异。各向异性：成因、类型和规模相同的同一组结构面，即使处于同一岩石中，结构面的表面形态和粗糙度系数JRC也会因为岩石介质的各向异性，结构面形成时应力环境的各项异性而呈现各项异性。非均一性：处于同一岩石中的同一组结构面，即使沿同一方向进行量测时，各测量段的表面形态和粗糙度系数JRC也存在差异。 上述方法的缺点：伸长率法虽全面考虑了结构面剖面轮廓曲线的结构特征，但是没有区分大小起伏度在影响抗剪效果时的主次权重；而直边法（修正直边法）仅考虑了大的结构起伏对结构面抗剪强度的影响，忽略了小结构起伏对抗剪强度的影响作用。因此，单独使用这2种方法不能确保JRC取值的精确度和可靠度. 李化等将伸长率R和轮廓曲线的相对起伏度Ra两个指标结合起来，让2种方法得到互补，提出了更精确的计算方法. 该方法不仅考虑了结构面大的结构起伏对结构面抗剪强度的影响，同时也考虑了较小结构起伏对抗剪强度的影响，并区分了两者的影响权重，具有较高的精确性和可靠性。 对某一确定的结构面来说，面积扩展率S是一个定值，该参数可以反映结构面粗糙度的尺寸效应和间距效应，但不能反映各向异性。而相对起伏度Ra则可以很好地反映出各向异性，在沿不同剪切方向上具有不同的剖面轮廓曲线，因此该参数可以作为体现结构面粗糙度具有各向异性的指标。从描述结构面粗糙度的特征上来说，相对起伏度Ra弥补了面积扩展率S的不足，这2个参数结合描述结构面的粗糙程度具有可行性. 六、粗糙度问题 劈裂和直剪试试验得到的裂缝粗糙度差别大概在6~12之间，粗糙度正常范围在0~20值得注意的是，在目前的试验研究中，绝大多数采用劈裂或直剪方式形成岩样试验裂缝，以模拟张性裂缝或剪切裂缝。然而，对于同一岩性的岩石而言，劈裂或直剪所得到的裂隙的起伏粗糙程度差别不大，难以得到各种粗糙度的裂隙。郑少河等[9]所制试件的JRC=6～12。由于现场采取的裂隙和人工劈裂或直剪得到的裂隙仅能反映某种或某几种特定粗糙度的裂隙，这些试验结果因而难以完全反映实际裂隙的水力特性，在实际工程的应用中存在一定的局限性。（不同节理粗糙度系数单裂隙渗流特性试验研究） 七、论文依据收集 单一裂隙是构成网络裂隙的基本单元，裂隙的隙宽、粗糙起伏程度等几何参数是影响裂隙内流体流动的主要因素。（岩体裂隙面粗糙度对其渗流特性的影响研究） 粗糙裂隙渗流的数值模拟方法（岩体裂隙面粗糙度对其渗流特性的影响研究_王志良） 微观解释粗糙度。（单裂隙砂岩渗流特性实验研究_王来贵） 结构面的起伏形态对结构面的抗剪强度有直接的影响，张开度对岩体的渗流性质影响很大，所以，在结构面表征中应该对结构面的起伏形态和张开度进行研究，它对结构面的力学特性有直接的关系。（节理岩体结构面空间表征及其模型优化） 结构面的表面形态是结构面表面空间展布的几何属性，结构面的表面形态可按规模大小分为起伏度和粗糙度，起伏度表征大规模的起伏，粗糙度表征小规模的不规则凹凸点，天然结构面的表面形态是起伏度和粗糙度的不同组合。（节理岩体结构面空间表征及其模型优化） 八、裂隙面构造方法3D打印不同粗糙度的裂隙板，结合PVC管组成浇筑磨具。 九、IDEA JRC配合微观图像表征粗糙度]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>粗糙度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" $ hexo new ‘My New Post’ More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[2019聚餐]]></title>
    <url>%2F2019%2F04%2F03%2F2019%E8%81%9A%E9%A4%90%2F</url>
    <content type="text"><![CDATA[0131 去姐夫家和姐夫吃夜宵喝酒 0217 去李锡鹏家吃饭 0219 阿冰哥和姐夫请我吃赣湘楼 0219 和妈妈吃烤海鲜 0222 XP、罗新食尚 0224 返校6人聚餐（鸡公煲） 0226 9人新食尚聚餐 0304 勇哥来我这做菜（腊肠）不要再喝牛栏山了 0309 去华科大西路吃烧烤，肉串的味道比小堕好点。 0320 北阶一家还不错的菜馆，有卖烤鱼，喝了啤酒，感觉并不好喝。 0322 学工组聚餐，口味堂，有点贵啊，今天主要吃的菜，口味鱼头200+接近300，菠菜面，红豆紫薯汁、牛蛙（平锅小美蛙）、饼（包紫薯还是什么来着）、口味粉蒸排骨、三峡石烤馍、虾仁水蒸蛋（因为没有公勺，所以我尽量挖边边的部分）千层扣肉（挺好吃的，一点都不辣，感觉不像是湖南菜啊，听老师们的说话好像这是湖南菜的餐厅） 0325 罗带腊肉来我这做，外加XP、勇哥的四个人小聚（感谢罗带的肉，碗还是罗洗的，优秀） 0325 中午和博、XP在教育食堂吃的，千张肉丝，香焖土鸡，干煸四季豆，家常豆腐都挺好吃的，天予推荐的，不错不错 0331 和孙技星一起吃老街烧烤。 0401 南门天天烧烤（XP请的） 0402 教育食堂（博请的，天予） 0403 教育食堂（我请的，XP） 0407 161聚餐（猪脚，花甲，大盘鸡，鱼块，黄瓜，藕菜，花生） 0410 鸡公煲（我，XP，罗） 0413 鸡公煲（我、XP、罗、勇哥） 0417 南门烧烤（我、XP、罗、勇哥、涛子） 0420 俭朴菜品酒会（我、XP、康成、康成同学、精酒门老板） 0421 新食尚（助管） 0421 回家湘（XP、Luo） 0427 鸡公煲（Luo、XP、涛子） 0503 随便炸炸（天予、博） 0503 新食尚（XP,Luo） 0508 俭朴菜（xp，luo，勇） 0509 回家湘（学工组） 0512 161火锅（灿、超、勇、xp、luo、博、涛子、天予） 0513 涛子生日（四月初九） 0518 老四川（超哥请客，我、越奇、涛子、博、xp、天予） 0525 回家湘（刘总给师兄送行） 0525 小惰（回家湘后转场） 0528 尊宝披萨（学工组加班，感谢王主任） 0531 随便炸炸（天予，博） 0601 南门烧烤（涛子，xp,luo） 0602 鸡公煲（自己） 0606 奇味虾（sjx） 0607 161（xp,勇哥，luo，博，天予）]]></content>
      <categories>
        <category>自律即自由</category>
      </categories>
      <tags>
        <tag>聚餐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年4月考核]]></title>
    <url>%2F2019%2F04%2F03%2F2019%E5%B9%B44%E6%9C%88%E8%80%83%E6%A0%B8%2F</url>
    <content type="text"><![CDATA[第一周（0401-0407）0401 周一 科研 晚上看了粗糙度的文献，没什么收获 读博 今天做了写高数题 环境 其它 0402 周二 科研 读博 莫烦Python基础完成；莫烦Numpy和Pandas开始 环境 其它 爱，死亡与机器人看完，只留下喜欢的几集，zima blue挺有共鸣。 0403 周三 科研 读博 莫烦python看到numpy的基本运算2 环境 其它 《快速使用Hexo搭建个人博客》学到11集（markdown基本语法）；看完crash course:study skills并在Hexo做了笔记。 0404 周四 科研 读博 莫烦python看到numpy的合并 环境 参加张国旗清明纪念仪式；张老师指导拍摄技巧 其它 Hexo搭建博客学习完毕； 0405 周五 科研 读博 莫烦numpy和Pandas数据处理完毕 环境 其它 0406 周六 科研 大致了解粗糙度研究现状，并做了一定整理，发布在博客上 读博 环境 其它 开始学素描，卡在色阶和正方体的明暗上，估计是笔的原因 0407 周日 科研 读博 环境 其它 161聚餐；素描（画方体） 04月第一周考核工作：1.Python、Numpy、Pandas的基础操作(还不熟练，需要多加练习)2.粗糙度研究现状的整理(只有框架，没有深入探究)3.Hexo博客搭建完毕并开始使用（之后慢慢完善）4.学习crash course:study skills（慢慢会应用上）5.开始学素描（之后会把学习的结果发到博客）6.做了少量高数题7.环境工作：参加张国旗清明纪念仪式；张老师指导拍摄技巧 娱乐:1.看完《爱、死亡与机器人》（最喜欢zima blue，大部分也都挺好看）2.161聚餐 总结：优点：工作内容较多，娱乐时间控制较好。缺点：工作中的知识掌握得不够；工作内容没有符合现阶段的重点；缺少与家人的交流； 第二周（0408-0414）0408 周一 科研 晚上看了粗糙度的文献（有眉目，但还是乱） 读博 环境 听十佳标兵试汇报；整理部分发展报告 其它 0409 周二 科研 晚上看了粗糙度的文献，整理了一下，但是没什么思路 读博 环境 发展报告除了奖学金分布，其它都过了一遍，剩下的等周四助管整理完再继续。 其它 重新开始看《人生的智慧》，对“意欲”这个词有了更清晰的认识；重看了木鱼水心解说的红楼梦P5，慢慢觉得《红楼梦》蛮有意思的，有时间可以看看原著。 状态 中午加班了一会，下午回办公室后继续看文献，快晚上时脑袋思维有点停滞了，中午估计还是要休息会，不能一直持续工作。 0410 周三 科研 读博 环境 例会；发展报告整理；互联网+申报数量通知 其它 看了陈果的《爱情课》（大多数还是蛮认同的） 状态 下午本想好好睡一觉，结果还是因为环境的事被叫过去了，所以有点小烦，再加上被陈果的《爱情课》吸引，今天都没做太多事。 0411 周四 科研 读博 环境 助管的统计已经完毕； 其它 看了木鱼的《权力的游戏》第七季微剧场；看了《人生的智慧》 状态 最近正事越拖越多，到现在有点小心烦，明天还是要赶紧把该做的事都做完；和妈妈视频。 0412 周五 科研 修改了一会循环论文； 读博 环境 例会记录整理完；参加新疆克州招聘活动； 其它 整理《人生的智慧》人的自身、人的财富部分，并出图上传至Hexo； 状态 今天整体状态不错，心态挺好，情绪也挺愉快，就是正事干得有点少，明天要继续加油。 0413 周六 科研 修改了一会循环论文； 读博 环境 发展报告完成； 其它 看《人生的智慧》他人的看法部分；看了《调音师》 状态 心情不错，效率优点低，有点不务正业。 0414 周日 科研 修改循环论文； 读博 环境 其它 鸡公煲；回顾木鱼水心《权力的游戏》；看《人生的智慧》；和奶奶视频 04月第二周考核工作：1.整理粗糙度研究现状（依旧不是很有头绪）2.修改循环论文（几乎没改）3.环境工作：整理发展报告；例会记录；开会×24.重新读《人生的智慧》5.看了陈果的《爱情课》（朴实但还蛮有价值） 娱乐:1.回顾《权力的游戏》2.看《调音师》3.鸡公煲4.和家人视频 总结：优点：给了自己很多闲暇的时间，happiness~缺点：工作内容没有符合现阶段的重点；重心有点偏向环境工作； 下周工作内容：1.循环论文修改2.科报会3.开题报告 第三周（0415-0421）0415 周一 科研 循环论文修改了引言和应力-应变曲线部分 读博 环境 查寝（一直被以为是学生。。。）；发展报告最终版； 其它 状态 今天有点务正业了，娱乐也控制的挺好，就是效率比较低，继续保持，之后会慢慢提高的。 0416 周二 科研 循环论文力学性质部分修改； 读博 环境 其它 状态 今天有点务正业了，娱乐也控制的挺好，就是效率比较低，继续保持，之后会慢慢提高的。 0417 周三 科研 循环论文细观部分修改； 读博 环境 国家安全教育日活动；互联网+活动；例会；查寝 其它 状态 忙得有点心烦，。 0418 周四 科研 读博 环境 国家安全教育日通讯稿；互联网+通讯稿； 其它 见了妹妹； 状态 今天比较充实，不过正业还是没有做。 0419 周五 科研 修改论文； 读博 环境 发书；环境的事今天有点多，没办法一一写明了； 其它 回顾了木鱼水心的《权力的游戏》1，2，3 状态 今天一天蛮充实的，就是有点累，晚上也没干多少活，零食还吃得挺多，哈哈哈，真的累。 0420 周六 科研 修改论文； 读博 环境 其它 和XP参加品酒会，蛮开心的，吃得好，喝得好； 状态 今天主要就是改论文，改完发给师兄了；然后晚上吃了一顿开心的晚餐，一天还是蛮充实的，很幸福。 0421 周日 科研 读博 环境 其它 和助管们一起吃饭；和XP、luo去回家湘吃饭； 状态 今天有点“挥霍”，四月份就不要再整些其它的了。 04月第三周考核工作：1.循环论文改完2.环境若干工作 娱乐:1.回顾《权力的游戏》2.新食尚（助管）3.回家湘（XP、Luo）4.俭朴菜（品酒会） 总结：优点：完成了一项正经工作。缺点：重心依然在环境那边；花钱有点多。 下周工作内容：1.开题报告2.读博相关 第四周（0422-0428）0422 周一 科研 读博 环境 环科节相关活动；上传通讯稿；发毕业通知（被挖坑了）； 其它 剪头发 状态 事情多的话，到了晚上确实很累，不过还是要把重心放学习上； 0423 周二 科研 tensorflow学习（没有什么进展）； 读博 环境 其它 琐事； 状态 花了大量时间却没有收获，有点蓝瘦。 0424 周三 科研 读博 环境 修改通讯稿照片； 其它 英语语法；看了复联4 状态 0425 周四 科研 读博 环境 观看篮球队比赛；琐事 其它 状态 0426 周五 科研 读博 环境 其它 改卷； 状态 今天发生了一件很重要的事，一辈子都要记住； 0427 周六 科研 读博 环境 其它 改卷；鸡公煲 状态 0428 周日 科研 读博 环境 其它 和高中同学聊天到半夜两点，基本上都是我在说… 状态 最近感受到新的事物，需要些时间调整一下。 4月总结： 优点：过得挺充实的，科研、环境、个人、娱乐都有包含，而且整体还是处于幸福的状态。 缺点：分配给正事的时间不够，而且做正事效率低；自制力还没有达到预期，在学习、省钱方面还是要加强。 最开心的事：有人跟我表白了。 最不开心的事：同一个女生约了三次都被拒绝了。（还是同一个理由，不知道是真有事还是只是不想跟我出去，感觉是后者，哈哈哈）]]></content>
      <categories>
        <category>自律即自由</category>
      </categories>
      <tags>
        <tag>2019</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B站Hexo博客搭建的个人博客]]></title>
    <url>%2F2019%2F04%2F03%2FB%E7%AB%99Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一、主题安装Git安装然后更改_config.yml中的theme。 二、主题语言修改更改_config.yml中language(zh-CN) 三、增加标签页和分类页next主题文件夹中的_config.yml（与上述不是同一个文件）中搜索menu，找到#categories、#tags，去掉前面的#号，保存，更新。 四、正确打开标签页和分类页12$ hexo n page tags //创建标签页$ hexo n page categories //创建分类页 五、主题样式更改next文件夹中_config.yml中搜索scheme,增删#进行更改 六、更改头像next文件夹中_config.yml中搜索avatar中url:/images/avatar.gif，改成想要的图片(图片要提前存入相应的文件夹) 七、更改标题、作者以及链接在_config.yml中搜索author，对title、author、url进行修改。 八、启用侧边栏社交链接next中的_config.yml搜索social进行修改 九、启用友情链接next中的_config.yml搜索links，找到links： Title:…进行更改 十、新建一篇文章tags: - 标签名1 - 标签名2 categories: 分类名 十一、Markdown基本语法见博客中《markdown基本语法》 十二、开启打赏功能next–_fonfig.yml–搜”reward” 十三、开启订阅公众号next–_config.yml–搜”sub” 十四、设置头像为圆形可旋转视频 十五、首页文章设置阅读全文next–_config.yml–搜“auto”/&lt; !– more – &gt; 十六、添加动态背景next–_config.yml–搜”Canvas” 十七、给博客添加fork Github百度“Github corners”找到喜欢的复制，然后在next/layout/_layout.swig中的1&lt;dir class=&quot;headband&quot;&gt;&lt;/dir&gt;dir&gt; 后另起一行，粘贴，并修改1&lt;a = href=&quot;...&quot;&gt; // &quot;...&quot;为你的github网址 十九、修改文章底部带#的标签next/layout/_macro/post.swig找到….rel = “tags”&gt; # … #改成1&lt;i class = &quot;...&quot; &gt;&lt;/i&gt; 二十、增加搜索功能next/_config.yml 二十三、增加搜索功能官方文档–第三方服务–搜索–local search 二十四、增加不蒜子统计功能next/_config.yml搜“busuanzi” 二十五、增加分享内容（没找到对应内容）二十八、隐藏底部的强力驱动next/layout/_partias/footer.swig 三十、hexo博客部署到远端的githubgithub先创建仓库 – git init（博客文件夹）– npm install hexo-deployer-git – –save – hexo d PS:部分视频没有看，有需要再去看。]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown基本语法]]></title>
    <url>%2F2019%2F04%2F03%2Fmarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一级标题二级标题三级标题四级标题五级标题六级标题 列表1 列表2 子列表2.1 子列表2.2 列表3 Jetzilch的Github 斜线字体字体加粗 单行代码块 12多行代码块1多行代码块2 这部分内容是引用的，主要以原作者的内容为主。 加一条横线（视频演示的是虚的，但是这里显示的就是实的了。。。）加一条横虚线]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Crash Course:Study Skills]]></title>
    <url>%2F2019%2F04%2F03%2FCrash-Course-Study-Skills%2F</url>
    <content type="text"><![CDATA[一、笔记载体和笔记方法的选择1.1 笔记载体：Paper√/Computer原因：Paper虽然记录速度慢，但不容易分心，且能提供更多的思考空间。1.2 笔记方法：大纲法/康奈尔法/思维导图 根据实际情况选择1.3 如何记笔记：如何划重点? 摩斯电码法（觉得是重点在段落旁边画·，之后有对这个重点解释证明阐述的，在段落旁边画-） 二、阅读方法（1）现有的研究证明速读是不可能的，或者说是没有效果的。（2）不要抑制默读，抑制默读影响思考。（3）阅读顺序：浏览-问题-阅读-复述/做题/总结（4）最好的阅读法：SCAR（Stop Complaining And Reading） 三、记忆（1）记忆需要间隔。（2）适度难度原则：回忆起越难想起的记忆，记忆的效果越好，但是如果刻意延长回忆时间可能造成无法回忆起记忆而导致记忆丢失。可以使用莱特纳系统进行复习，即找到5个盒子，分别为隔1，3，5，7，考试前五个时间，学习的知识依照时间长短放入各个盒子，然后根据盒子的天数进行复习。类似的手机软件有Anki。（3）要多使用主动记忆（回忆：未见到知识而回忆起知识）而避免被动记忆（再认：见到笔记后再回想起知识）。被动记忆更适合用于设置小测验（根据笔记出题检测自己） 四、计划与整理要形成一个系统：（1）任务管理器：Evernote（2）如何整理笔记。之前的笔记可能比较散乱，要找出时间进行整理，关于知识的整理可以像这样发布在Hexo上。（3）保证笔记都有物理存储方式（每天的笔记很散乱，最好有一个物理载体能把它们归类到一起，比如一个文件盒，我暂时想到的是买散页纸的包装带，或者找文件夹）（4）开发方案，也就是制定计划（我的理解是每天和每周都做总结，就像兼辅考核表一样） 五、注意力与集中（1）注意力随时间递减（2）一般工作25~30分钟，要休息几分钟，但不要做分散注意力的事。（3）注意力与健康有关，养成好习惯（睡眠7hours，每天锻炼）（4）注意力与环境有关，尽量给自己找一个不受干扰的好环境。 六、文章与写作（对应视频第9集）（1）先进行“前写作”（针对已有的结果进行粗糙的写作）（2）带着上一版的问题定向找资源，并记录资源的量，够用就行。（3）开始写作，但不要带有完美主义。（4）修改论文时先看框架，再看语句。改完后可以大声朗读/打印出来进行修改，效果比较好。]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫烦Numpy和Pandas数据处理教程]]></title>
    <url>%2F2019%2F04%2F02%2F%E8%8E%AB%E7%83%A6Numpy%E5%92%8CPandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Numpy一、Numpy的属性12345678import numpy as nparray = np.array([[1,2,3],[2,3,4]])print(array)print(&apos;number of dim:&apos;,array.ndim) #维度print(&apos;shape:&apos;,array.shape) #几行几列print(&apos;size:&apos;,array.size) #几个元素 二、Numpy创建Array五、Numpy的索引1234import numpy as npA = np.arange(3,15)print(A) #[3 4 5 6 7 8 9 10 11 12 13 14]print(A[3]) #6 矩阵换成二维的1234567891011121314151617181920212223import numpy as npA = np.arange(3,15).reshape((3,4))print(A) #[[3 4 5 6] [7 8 9 10] [11 12 13 14]]print(A[2]) #[11 12 13 14]print(A[1][1]) #8 print(A[1,1]) #8 与上述效果一样print(A[:,1]) #第2列的所有数print(A[1,:]) #第2行的所有数print(A[1,1:2]) #[8]print(A[1,1:3]) #[8,9]for row in A: print(row) #按行输出for column in A.T: print(column) #按列输出print(A.flatten()) #把矩阵变成一维for item in A.flat: print(item) #flat和flatten()功能一样，返回值不一样。返回一维矩阵用flatten(),flat是迭代器，返回的是一串类似地址值的值 三、Numpy的Array合并合并12345678910import numpy as npA = np.array([1,1,1])B = np.array([2,2,2])print(np.vstack(A,B)) #vertical stack 上下合并# [1,1,1] [2,2,2]print(np.hstack(A,B)) #horizontal stack 左右合并# [1,1,1,2,2,2] 增加维度123456print(A[:,np.newaxis]) #增加列维度# [[1] [1] [1]]print(A[np.newaxis,:]) #增加行维度# [[1,1,1]] 例子：123456789A = np.array([1,1,1])[:,np.newaxis]B = np.array([2,2,2])[:,np.newaxis]C = np.hstack(A,B)print(C)# [1,2] [1,2] [1,2]print(A.shape,C.shape)# (3,1) (3,2) 多个Array合并123456789101112131415161718C = np.concatenate((A,B,B,A)，axis=0) # vstack和hstack都可以进行多个Array合并，# concatenate的不同在于可以在后面指定合并的方向。# 0为上下合并，1为水平合并print(C)#[[1] [1] [1] [2] [2] [2] [2] [2] [2] [1] [1] [1]] 四、Numpy的分割先生成一个array：12345678910111213141516171819import numpy as npA = np.arange(12).reshape((3,4))print(A)# [[0,1,2][3,4,5][6,7,8][9,10,11]]print(np.split(A,2,axis=1))#1是上下分开，0是左右分开# [array([[0,1], [4,5], [8,9]]), array([[2,3], [6,7], [10,11]])] split只能进行相同分割，进行不相等分割要使用array_split123456789101112print(np.array_split(A,3,axis=1))#[array([[0,1], [4,5], [8,9]]), array([[2], [6], [10]]) array([[3], [7], [11]])] 相对于合并，分割也有vsplit和hsplit123456789101112print(np.vsplit(A,3))#[array([[0,1,2,3]])],[array([[4,5,6,7]])],[array([[8,9,10,11]])]print(np.hsplit(A,2))#[array([[0,1], [4,5], [8,9]]), array([[2,3], [6,7], [10,11]])] 五、Numpy的copy和deep copy12345678910111213141516import numpy as npa = np.arange(4)b = ac = ad = ba[0] = 11 #默认格式是整数# 此时a,b,c,d都会改变，因为python中这种赋值方式下a,b,c,d是完全一样的d[1:3] = [22,33]# 此时a,b.c,d也会全部发生改变b = a.copy() #deep copya[3] = 44#a = [11,22,33,44]b = [11,22,33,3]deep copy后,a变化不会使b变化 Pandas一、Pandas的基本介绍Series123456789101112import pandas as pdimport numpy as nps = pd.Series([1,3,6,np.nan,44,1])print(s)#0 1.01 3.02 6.03 NaN4 44.05 1.0dtype: float64 DataFrame1234567891011121314151617dates = pd.date_range(&apos;20160101&apos;,periods=6)print(dates)# 先生成一个索引DatetimeIndex([&apos;2016-01-01&apos;, &apos;2016-01-02&apos;, &apos;2016-01-03&apos;, &apos;2016-01-04&apos;, &apos;2016-01-05&apos;, &apos;2016-01-06&apos;], dtype=&apos;datetime64[ns]&apos;, freq=&apos;D&apos;)df = pd.DataFrame(np.random.randn(6,4),index=dates,columns=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])print(df)# 生成DataFrame a b c d2016-01-01 0.545643 2.021614 1.210559 0.4678342016-01-02 0.666108 0.419161 -1.943871 -0.9532632016-01-03 -0.759923 -0.337458 -1.865560 0.3280372016-01-04 0.198904 0.880258 -1.369046 0.8859452016-01-05 -0.828801 -0.602095 -0.897741 0.1682772016-01-06 0.937178 -0.593869 0.043363 -0.273371 没有索引生成DataFrame1234567df1 = pd.DataFrame(np.random.randn(3,4))print(df1)# 0 1 2 30 0.378297 -0.354029 0.407989 -0.0678381 -1.210963 2.706774 0.875143 0.3606812 -0.964372 0.919133 0.768482 0.221687 按索引排序123456789df1 = pd.DataFrame(np.arange(12).reshape((3,4)))print(df1)print(df1.sort_index(axis=0,ascending=False)) # 0 1 2 32 8 9 10 111 4 5 6 70 0 1 2 3 按值排序123456print(df1.sort_values(by=2))# 0 1 2 30 0 1 2 31 4 5 6 72 8 9 10 11 二、选择数据先生成一个DataFrame1234567891011121314151617181920212223242526272829303132333435363738394041424344import pandas as pdimport numpy as npdates = pd.date_range(&apos;20130101&apos;,periods=6)df = pd.DataFrame(np.arange(24).reshape((6,4)),index=dates,columns=[&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;])print(df)print(df[&apos;A&apos;])print(df.A)# A B C D2013-01-01 0 1 2 32013-01-02 4 5 6 72013-01-03 8 9 10 112013-01-04 12 13 14 152013-01-05 16 17 18 192013-01-06 20 21 22 232013-01-01 02013-01-02 42013-01-03 82013-01-04 122013-01-05 162013-01-06 20Freq: D, Name: A, dtype: int322013-01-01 02013-01-02 42013-01-03 82013-01-04 122013-01-05 162013-01-06 20Freq: D, Name: A, dtype: int32print(df[0:3])print(df[&apos;20130102&apos;:&apos;20130104&apos;])# A B C D2013-01-01 0 1 2 32013-01-02 4 5 6 72013-01-03 8 9 10 11 A B C D2013-01-02 4 5 6 72013-01-03 8 9 10 112013-01-04 12 13 14 15 从标签来选择1234567print(df.loc[&apos;20130102&apos;])#A 4B 5C 6D 7Name: 2013-01-02 00:00:00, dtype: int32 从列标签中选择，并输出所有行结果1234567891011121314151617print(df.loc[:,[&apos;A&apos;,&apos;B&apos;]])# A B2013-01-01 0 12013-01-02 4 52013-01-03 8 92013-01-04 12 132013-01-05 16 172013-01-06 20 21print(df.loc[&apos;20130102&apos;:,[&apos;A&apos;,&apos;B&apos;]]) A B2013-01-02 4 52013-01-03 8 92013-01-04 12 132013-01-05 16 172013-01-06 20 21 从位置选择123456789101112131415161718192021222324print(df.iloc[3]) #第4行的数据#A 12B 13C 14D 15Name: 2013-01-04 00:00:00, dtype: int32print(df.iloc[3，1]) #第4行第2个数据#13print(df.iloc[3:5，1:3]) #第4行到第6行，第2位到第4位# B C2013-01-04 13 142013-01-05 17 18print(df.iloc[[1,3,5],1:3]) #第2，4，6行...# B C2013-01-02 5 62013-01-04 13 142013-01-06 21 22 混合选择123456print(df.ix[:3,[&apos;A&apos;,&apos;C&apos;]])# A C2013-01-01 0 22013-01-02 4 62013-01-03 8 10 其它1234567891011121314print(df)print(df[df.A&gt;8])# A B C D2013-01-01 0 1 2 32013-01-02 4 5 6 72013-01-03 8 9 10 112013-01-04 12 13 14 152013-01-05 16 17 18 192013-01-06 20 21 22 23 A B C D2013-01-04 12 13 14 152013-01-05 16 17 18 192013-01-06 20 21 22 23 三、Pandas设置值先生成一个DataFrame123456789101112131415161718192021222324252627282930313233343536373839dates = pd.date_range(&apos;20130101&apos;,periods=6)df = pd.DataFrame(np.arange(24).reshape((6,4)),index=dates,columns=[&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;])# A B C D2013-01-01 0 1 2 32013-01-02 4 5 6 72013-01-03 8 9 10 112013-01-04 12 13 14 152013-01-05 16 17 18 192013-01-06 20 21 22 23df.iloc[2,2] = 1111print(df)# A B C D2013-01-01 0 1 2 32013-01-02 4 5 6 72013-01-03 8 9 10 112013-01-04 12 13 14 152013-01-05 16 17 18 192013-01-06 20 21 22 23 A B C D2013-01-01 0 1 2 32013-01-02 4 5 6 72013-01-03 8 9 1111 112013-01-04 12 13 14 152013-01-05 16 17 18 192013-01-06 20 21 22 23df.loc[&apos;20130101&apos;,&apos;A&apos;] = 2222print(df)# A B C D2013-01-01 2222 1 2 32013-01-02 4 5 6 72013-01-03 8 9 1111 112013-01-04 12 13 14 152013-01-05 16 17 18 192013-01-06 20 21 22 23 另一种设置值的方法123456789101112131415161718192021df[df.A&gt;4] = 0print(df)# A B C D2013-01-01 0 1 2 32013-01-02 4 5 6 72013-01-03 0 0 0 02013-01-04 0 0 0 02013-01-05 0 0 0 02013-01-06 0 0 0 0df.A[df.A&gt;4] = 0print(df)# A B C D2013-01-01 0 1 2 32013-01-02 4 5 6 72013-01-03 0 9 10 112013-01-04 0 13 14 152013-01-05 0 17 18 192013-01-06 0 21 22 23 加一列123456789101112131415161718192021df[&apos;F&apos;] = np.nanprint(df)# A B C D F2013-01-01 0 1 2 3 NaN2013-01-02 4 5 6 7 NaN2013-01-03 8 9 10 11 NaN2013-01-04 12 13 14 15 NaN2013-01-05 16 17 18 19 NaN2013-01-06 20 21 22 23 NaNdf[&apos;E&apos;] = pd.Series([1,2,3,4,5,6],index=pd.date_range(&apos;20130101&apos;,periods=6))print(df)# A B C D E2013-01-01 0 1 2 3 12013-01-02 4 5 6 7 22013-01-03 8 9 10 11 32013-01-04 12 13 14 15 42013-01-05 16 17 18 19 52013-01-06 20 21 22 23 6 四、Pandas处理异常数据生成一个带有Nan的DataFrame12345678910111213141516171819202122232425import pandas as pdimport numpy as npdates = pd.date_range(&apos;20130101&apos;,periods=6)df = pd.DataFrame(np.arange(24).reshape((6,4)),index=dates,columns=[&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;])df.iloc[0,1] = np.nandf.iloc[1,2] = np.nanprint(df)# A B C D2013-01-01 0 NaN 2.0 32013-01-02 4 5.0 NaN 72013-01-03 8 9.0 10.0 112013-01-04 12 13.0 14.0 152013-01-05 16 17.0 18.0 192013-01-06 20 21.0 22.0 23print(df.dropna(axis=0,how=&apos;any&apos;))# A B C D2013-01-03 8 9.0 10.0 112013-01-04 12 13.0 14.0 152013-01-05 16 17.0 18.0 192013-01-06 20 21.0 22.0 23 丢掉带有数据的行或列12345678910111213141516171819print(df.dropna(axis=0,how=&apos;any&apos;)) #丢掉行# A B C D2013-01-03 8 9.0 10.0 112013-01-04 12 13.0 14.0 152013-01-05 16 17.0 18.0 192013-01-06 20 21.0 22.0 23print(df.dropna(axis=1,how=&apos;any&apos;)) #丢掉列# A D2013-01-01 0 32013-01-02 4 72013-01-03 8 112013-01-04 12 152013-01-05 16 192013-01-06 20 23print(df.dropna(axis=0,how=&apos;all&apos;)) #行或列全是Nan才删除 将没有填的空，填上数据123456789print(df.fillna(value=0))# A B C D2013-01-01 0 0.0 2.0 32013-01-02 4 5.0 0.0 72013-01-03 8 9.0 10.0 112013-01-04 12 13.0 14.0 152013-01-05 16 17.0 18.0 192013-01-06 20 21.0 22.0 23 判断整个表格中数据是否存在123456789print(df.isnull())# A B C D2013-01-01 False True False False2013-01-02 False False True False2013-01-03 False False False False2013-01-04 False False False False2013-01-05 False False False False2013-01-06 False False False False 数据太多，没办法每行每列找，可以用下列方法123print(np.any(pd.isnull()) == True)#True 五、Pandas导入导出导入表格12345678910111213141516import pandas as pdimport numpy as npdata = pd.read_csv(&apos;C:/Users/zz/Desktop/Python training/1.csv&apos;)print(data)# Student ID Name Gender Language0 1 A male C1 2 B female E2 3 C male A3 4 D female C4 5 E male E5 6 F male A6 7 G female A7 8 H female E8 9 I female C 导出表格1data.to_pickle(&apos;2.pickle&apos;) 六、Pandas合并 concate生成三个DataFrame12345678910111213141516171819202122import pandas as pdimport numpy as npdf1 =pd.DataFrame(np.ones((3,4))*0,columns=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])df2 =pd.DataFrame(np.ones((3,4))*1,columns=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])df3 =pd.DataFrame(np.ones((3,4))*2,columns=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])print(df1)print(df2)print(df3)# a b c d0 0.0 0.0 0.0 0.01 0.0 0.0 0.0 0.02 0.0 0.0 0.0 0.0 a b c d0 1.0 1.0 1.0 1.01 1.0 1.0 1.0 1.02 1.0 1.0 1.0 1.0 a b c d0 2.0 2.0 2.0 2.01 2.0 2.0 2.0 2.02 2.0 2.0 2.0 2.0 第一种合并123456789101112131415161718192021res = pd.concat([df1,df2,df3],axis=0)print(res)# a b c d0 0.0 0.0 0.0 0.01 0.0 0.0 0.0 0.02 0.0 0.0 0.0 0.00 1.0 1.0 1.0 1.01 1.0 1.0 1.0 1.02 1.0 1.0 1.0 1.00 2.0 2.0 2.0 2.01 2.0 2.0 2.0 2.02 2.0 2.0 2.0 2.0res = pd.concat([df1,df2,df3],axis=1)print(res)# a b c d a b c d a b c d0 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0 2.0 2.0 2.0 2.01 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0 2.0 2.0 2.0 2.02 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0 2.0 2.0 2.0 2.0 重新赋予左边的索引12345678910111213res = pd.concat([df1,df2,df3],axis=0，ignore_index=True)print(res)# a b c d0 0.0 0.0 0.0 0.01 0.0 0.0 0.0 0.02 0.0 0.0 0.0 0.03 1.0 1.0 1.0 1.04 1.0 1.0 1.0 1.05 1.0 1.0 1.0 1.06 2.0 2.0 2.0 2.07 2.0 2.0 2.0 2.08 2.0 2.0 2.0 2.0 另一种合并(‘outer’,’inner’)先生成两个DataFrame12345678910111213df1 = pd.DataFrame(np.ones((3,4))*0,index=[1,2,3],columns=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])df2 = pd.DataFrame(np.ones((3,4))*1,index=[2,3,4],columns=[&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;])print(df1)print(df2)# a b c d1 0.0 0.0 0.0 0.02 0.0 0.0 0.0 0.03 0.0 0.0 0.0 0.0 b c d e2 1.0 1.0 1.0 1.03 1.0 1.0 1.0 1.04 1.0 1.0 1.0 1.0 内外连接（默认为outer）1234567891011121314151617181920212223242526272829303132res = pd.concat([df1,df2],join=&apos;outer&apos;)print(res)# a b c d e1 0.0 0.0 0.0 0.0 NaN2 0.0 0.0 0.0 0.0 NaN3 0.0 0.0 0.0 0.0 NaN2 NaN 1.0 1.0 1.0 1.03 NaN 1.0 1.0 1.0 1.04 NaN 1.0 1.0 1.0 1.0res = pd.concat([df1,df2],join=&apos;inner&apos;)print(res)# b c d1 0.0 0.0 0.02 0.0 0.0 0.03 0.0 0.0 0.02 1.0 1.0 1.03 1.0 1.0 1.04 1.0 1.0 1.0res = pd.concat([df1,df2],join=&apos;inner&apos;,ignore_index=True)print(res)# b c d0 0.0 0.0 0.01 0.0 0.0 0.02 0.0 0.0 0.03 1.0 1.0 1.04 1.0 1.0 1.05 1.0 1.0 1.0 根据索引连接123456789df1 = pd.DataFrame(np.ones((3,4))*0,index=[1,2,3],columns=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])df2 = pd.DataFrame(np.ones((3,4))*1,index=[2,3,4],columns=[&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;])res = pd.concat([df1,df2],axis=1,join_axes=[df1.index])print(res)# a b c d b c d e1 0.0 0.0 0.0 0.0 NaN NaN NaN NaN2 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.03 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0 append添加123456789101112131415161718192021222324252627df1 =pd.DataFrame(np.ones((3,4))*0,columns=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])df2 =pd.DataFrame(np.ones((3,4))*1,columns=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])df3 =pd.DataFrame(np.ones((3,4))*2,columns=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])res = df1.append(df2,ignore_index=True)print(res)# a b c d0 0.0 0.0 0.0 0.01 0.0 0.0 0.0 0.02 0.0 0.0 0.0 0.03 1.0 1.0 1.0 1.04 1.0 1.0 1.0 1.05 1.0 1.0 1.0 1.0res = df1.append([df2,df3],ignore_index=True)print(res)# a b c d0 0.0 0.0 0.0 0.01 0.0 0.0 0.0 0.02 0.0 0.0 0.0 0.03 1.0 1.0 1.0 1.04 1.0 1.0 1.0 1.05 1.0 1.0 1.0 1.06 2.0 2.0 2.0 2.07 2.0 2.0 2.0 2.08 2.0 2.0 2.0 2.0 七、Pandas合并 merge生成两个DataFrame12345678910111213141516171819202122import pandas as pdimport numpy as npleft = pd.DataFrame(&#123;&apos;key&apos;: [&apos;K0&apos;, &apos;K1&apos;, &apos;K2&apos;, &apos;K3&apos;], &apos;A&apos;: [&apos;A0&apos;, &apos;A1&apos;, &apos;A2&apos;, &apos;A3&apos;], &apos;B&apos;: [&apos;B0&apos;, &apos;B1&apos;, &apos;B2&apos;, &apos;B3&apos;]&#125;)right = pd.DataFrame(&#123;&apos;key&apos;: [&apos;K0&apos;, &apos;K1&apos;, &apos;K2&apos;, &apos;K3&apos;], &apos;C&apos;: [&apos;C0&apos;, &apos;C1&apos;, &apos;C2&apos;, &apos;C3&apos;], &apos;D&apos;: [&apos;D0&apos;, &apos;D1&apos;, &apos;D2&apos;, &apos;D3&apos;]&#125;)print(left)print(right)# key A B0 K0 A0 B01 K1 A1 B12 K2 A2 B23 K3 A3 B3 key C D0 K0 C0 D01 K1 C1 D12 K2 C2 D23 K3 C3 D3 merge12345678res = pd.merge(left,right,on=&apos;key&apos;)print(res)# key A B C D0 K0 A0 B0 C0 D01 K1 A1 B1 C1 D12 K2 A2 B2 C2 D23 K3 A3 B3 C3 D3 两列key1234567891011121314151617181920212223242526left = pd.DataFrame(&#123;&apos;key1&apos;: [&apos;K0&apos;, &apos;K0&apos;, &apos;K1&apos;, &apos;K2&apos;], &apos;key2&apos;: [&apos;K0&apos;, &apos;K1&apos;, &apos;K0&apos;, &apos;K1&apos;], &apos;A&apos;: [&apos;A0&apos;, &apos;A1&apos;, &apos;A2&apos;, &apos;A3&apos;], &apos;B&apos;: [&apos;B0&apos;, &apos;B1&apos;, &apos;B2&apos;, &apos;B3&apos;]&#125;)right = pd.DataFrame(&#123;&apos;key1&apos;: [&apos;K0&apos;, &apos;K1&apos;, &apos;K1&apos;, &apos;K2&apos;], &apos;key2&apos;: [&apos;K0&apos;, &apos;K0&apos;, &apos;K0&apos;, &apos;K0&apos;], &apos;C&apos;: [&apos;C0&apos;, &apos;C1&apos;, &apos;C2&apos;, &apos;C3&apos;], &apos;D&apos;: [&apos;D0&apos;, &apos;D1&apos;, &apos;D2&apos;, &apos;D3&apos;]&#125;)res = pd.merge(left,right,on=[&apos;key1&apos;,&apos;key2&apos;])print(res)# key1 key2 A B C D0 K0 K0 A0 B0 C0 D01 K1 K0 A2 B2 C1 D12 K1 K0 A2 B2 C2 D2res = pd.merge(left,right,on=[&apos;key1&apos;,&apos;key2&apos;],how=&apos;outer&apos;)# how = [&apos;left&apos;,&apos;right&apos;,&apos;outer&apos;,&apos;inner&apos;] print(res)# key1 key2 A B C D0 K0 K0 A0 B0 C0 D01 K0 K1 A1 B1 NaN NaN2 K1 K0 A2 B2 C1 D13 K1 K0 A2 B2 C2 D24 K2 K1 A3 B3 NaN NaN5 K2 K0 NaN NaN C3 D3 indicator生成DataFrame1234df1 = pd.DataFrame(&#123;&apos;col1&apos;:[0,1], &apos;col_left&apos;:[&apos;a&apos;,&apos;b&apos;]&#125;)df2 = pd.DataFrame(&#123;&apos;col1&apos;:[1,2,2],&apos;col_right&apos;:[2,2,2]&#125;)print(df1)print(df2) 使用indicator12345678res = pd.merge(df1, df2, on=&apos;col1&apos;, how=&apos;outer&apos;, indicator=True)print(res)# col1 col_left col_right _merge0 0 a NaN left_only1 1 b 2.0 both2 2 NaN 2.0 right_only3 2 NaN 2.0 right_only index1234567891011121314left = pd.DataFrame(&#123;&apos;A&apos;: [&apos;A0&apos;, &apos;A1&apos;, &apos;A2&apos;], &apos;B&apos;: [&apos;B0&apos;, &apos;B1&apos;, &apos;B2&apos;]&#125;, index=[&apos;K0&apos;, &apos;K1&apos;, &apos;K2&apos;])right = pd.DataFrame(&#123;&apos;C&apos;: [&apos;C0&apos;, &apos;C2&apos;, &apos;C3&apos;], &apos;D&apos;: [&apos;D0&apos;, &apos;D2&apos;, &apos;D3&apos;]&#125;, index=[&apos;K0&apos;, &apos;K2&apos;, &apos;K3&apos;])res = pd.merge(left, right, left_index=True, right_index=True, how=&apos;outer&apos;)print(res)# A B C DK0 A0 B0 C0 D0K1 A1 B1 NaN NaNK2 A2 B2 C2 D2K3 NaN NaN C3 D3 handle overlapping12345678boys = pd.DataFrame(&#123;&apos;k&apos;: [&apos;K0&apos;, &apos;K1&apos;, &apos;K2&apos;], &apos;age&apos;: [1, 2, 3]&#125;)girls = pd.DataFrame(&#123;&apos;k&apos;: [&apos;K0&apos;, &apos;K0&apos;, &apos;K3&apos;], &apos;age&apos;: [4, 5, 6]&#125;)res = pd.merge(boys, girls, on=&apos;k&apos;, suffixes=[&apos;_boy&apos;, &apos;_girl&apos;], how=&apos;inner&apos;)print(res)# k age_boy age_girl0 K0 1 41 K0 1 5 八、Pandas Plot画图生成Series12345678910111213141516import pandas as pdimport numpy as npimport matplotlib.pyplot as pltdata = pd.Series(np.random.randn(1000), index=np.arange(1000))data = data.cumsum()data.plot()plt.show()data = pd.DataFrame(np.random.randn(1000, 4), index=np.arange(1000), columns=list(&quot;ABCD&quot;))data = data.cumsum()ax = data.plot.scatter(x=&apos;A&apos;, y=&apos;B&apos;, color=&apos;DarkBlue&apos;, label=&quot;Class 1&quot;)data.plot.scatter(x=&apos;A&apos;, y=&apos;C&apos;, color=&apos;LightGreen&apos;, label=&apos;Class 2&apos;, ax=ax)plt.show()]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>numpy</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫烦Python基础笔记]]></title>
    <url>%2F2019%2F04%2F01%2F%E8%8E%AB%E7%83%A6Python%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、安装注意配置环境变量和pipe3的环境变量（新版安装时打勾就可以自动配置） 二、基本使用2.1 print功能2.2 基本数学运算&emsp;&emsp;次方用**表示，区别于传统的^.&emsp;&emsp;取余用%2.3 变量variable&emsp;&emsp;命名时多个单词用下划线隔开&emsp;&emsp;多个变量复制：a,b,c = 11,12,13 三、while循环和for循环四、if判断Python中并没有类似三目运算符的命令，但是有替代。如，1234worked = True result = &apos;done&apos; if worked else &apos;not yet&apos;//如果worked是True，则&apos;done&apos;被赋值给result，false则是‘not yet’被赋值给result print(result) 五、定义功能六、变量形式七、模块安装安装Numpy 八、文件读取九、class类十、input输入十一、元组turple、列表List、字典十二、模块import]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
